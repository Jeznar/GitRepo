{
  "name": "Inspiring Leader",
  "type": "feat",
  "img": "Icons_JGB/Feats/Inspiring_Leader/Inspiring_Leader.png",
  "data": {
    "description": {
      "value": "<p>You can spend 10 minutes inspiring your companions, shoring up their resolve to fight. When you do so, choose up to&nbsp;<strong>six friendly creatures</strong>&nbsp;(which can include yourself)&nbsp;<strong>within 30 feet of you&nbsp;</strong>who can see or hear you and who can understand you.</p>\n<p>Each creature can gain temporary hit points equal to&nbsp;<strong>your level + your Charisma modifier</strong>. A creature can't gain temporary hit points from this feat again until it has finished a short or long rest.</p>\n<hr style=\"border-top: 1px solid var(--color-border-light-primary); border-bottom: 1px solid var(--color-border-light-highlight);\" />\n<p><strong>FoundryVTT:&nbsp;</strong>This is largely automated.&nbsp; The automation does not enforce the&nbsp;<em>friendly </em>requirement<em>.</em> A dialog is provded to select recipients, no pre-targeting is required (or used).</p>",
      "chat": "",
      "unidentified": ""
    },
    "source": "",
    "activation": {
      "type": "minute",
      "cost": 10,
      "condition": ""
    },
    "duration": {
      "value": 0,
      "units": ""
    },
    "target": {
      "value": null,
      "width": null,
      "units": "",
      "type": ""
    },
    "range": {
      "value": 30,
      "long": null,
      "units": "ft"
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "util",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": null
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "requirements": "",
    "recharge": {
      "value": 0,
      "charged": false
    },
    "attunement": 0
  },
  "effects": [],
  "flags": {
    "enhancedcombathud": {
      "set1p": false,
      "set2p": false,
      "set3p": false
    },
    "midi-qol": {
      "onUseMacroName": "[postActiveEffects]ItemMacro",
      "effectActivation": false
    },
    "magicitems": {
      "enabled": false,
      "equipped": false,
      "attuned": false,
      "charges": "0",
      "chargeType": "c1",
      "destroy": false,
      "destroyFlavorText": "reaches 0 charges: it crumbles into ashes and is destroyed.",
      "rechargeable": false,
      "recharge": "0",
      "rechargeType": "t1",
      "rechargeUnit": "r1",
      "sorting": "l"
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Inspiring Leader",
          "type": "script",
          "author": "ZjFlOWYxZjM5ZTZj",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const MACRONAME = \"Inspiring_Leader.1.1.js\"\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Total rewrite of Inspiring_Leader.0.6.js that implemements the Inspiring Leader Feat.\n * \n * This version uses MidiQOL.DamageOnlyWorkflow to handle the application of tempoary HP to up to six tokens. bThe majority of the\n * code deals with picking those targets.  There is no checking to see if they are \"friendly\" as this can shift unpredictably in \n * a game session.   \n * \n * Major Steps:\n *  1. Finding the set of all creatures within 30 feet that can see the caster \n *  2. Find the set of all creatures within 30 feet that can hear the caster \n *  3. Build a superset of the first two sets\n *  4. Filter out actors that have the marker buff indicating they have received this effect since last short or long rest\n *  5. Present dialog to obtain selections for the buff\n *  6. Use the return value (BUFFIES) to build an array of the tokens to be bolsetered. \n *  7. Launch VFX on caster\n *  8. Launch VFX on tokens receiving bolster\n *  9. Make the Midi call to apply the temp health (temphp)\n * 10. Apply a marker buff indicating that Inspiring Leader has been applied\n * \n * 12/19/22 1.0 Creation of Macro\n * 12/23/22 1.1 Some polish applied\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nconst MACRO = MACRONAME.split(\".\")[0]       // Trim off the version number and extension\nconst FNAME = MACRO\nconst TAG = `${MACRO} |`\nconst TL = 0;                               // Trace Level for this macro\nlet msg = \"\";                               // Global message string\n//-----------------------------------------------------------------------------------------------------------------------------------\nif (TL > 0) jez.trace(`${TAG} === Starting ===`);\nif (TL > 1) for (let i = 0; i < args.length; i++) jez.trace(`  args[${i}]`, args[i]);\n//-----------------------------------------------------------------------------------------------------------------------------------\n// Set standard variables\n//\nconst L_ARG = args[args.length - 1]; // See https://gitlab.com/tposney/dae#lastarg for contents\nlet aToken = (L_ARG.tokenId) ? canvas.tokens.get(L_ARG.tokenId) : game.actors.get(L_ARG.tokenId)\nlet aActor = aToken.actor;\nlet aItem = (args[0]?.item) ? args[0]?.item : L_ARG.efData?.flags?.dae?.itemData\nconst VERSION = Math.floor(game.VERSION);\nconst GAME_RND = game.combat ? game.combat.round : 0;\n//-----------------------------------------------------------------------------------------------------------------------------------\n// Set Macro variables\n//\nconst RANGE = 30\nlet canSeeIds = []\nlet canHearIds = []\nconst SEP_CHAR = '-'\nconst TEMP_HP = aActor.data.data.details.level + aActor.data.data.abilities.cha.mod;\n//-----------------------------------------------------------------------------------------------------------------------------------\n// 1. Finding the set of all creatures within 30 feet that can see the caster \n//\nconst CAN_SEE = await getThoseThatCanSee({ traceLvl: 0 })\nfor (let i = 0; i < CAN_SEE.length; i++) {\n    if (TL > 4) jez.trace(`${FNAME} | Can See: ${CAN_SEE[i].name}${SEP_CHAR}${CAN_SEE[i].id}`)\n    canSeeIds.push(`${CAN_SEE[i].name}${SEP_CHAR}${CAN_SEE[i].id}`)\n}\n//-----------------------------------------------------------------------------------------------------------------------------------\n// 2. Find the set of all creatures within 30 feet that can hear the caster \n//\nconst CAN_HEAR = await getThoseThatCanHear({ traceLvl: 0 })\nfor (let i = 0; i < CAN_HEAR.length; i++) {\n    if (TL > 4) jez.trace(`${FNAME} | Can Hear: ${CAN_HEAR[i].name}${SEP_CHAR}${CAN_HEAR[i].id}`)\n    canHearIds.push(`${CAN_HEAR[i].name}${SEP_CHAR}${CAN_HEAR[i].id}`)\n}\n//-----------------------------------------------------------------------------------------------------------------------------------\n// 3. Build a superset of the first two sets\n//\nlet canSeeOrHearIds = canSeeIds.concat(canHearIds);\ncanSeeOrHearIds = canSeeOrHearIds.filter((item, index) => { return (canSeeOrHearIds.indexOf(item) == index) }).sort()\nif (TL > 2) for (let i = 0; i < canSeeOrHearIds.length; i++) {\n    jez.trace(`${FNAME} | ${i + 1} Candidate: ${canSeeOrHearIds[i]}`)\n}\n// Example value of canSeeOrHearIds (7)Â [\n//    'Acolyte-3LcEh5rpD6ax8Ll7', 'Acolyte-eIzYNsFkw8YKCBHh', 'Gate Guard-r78yGjIFRFzX6giL', \n//    'Guard Captain-1CWFDI7gXlSrAjPs', 'Guard-qYxnYBuL8fWepCdR', 'Militia Leader-grzlDpnm3M8AOgmS', \n//    'Minnie McWizard-VqULthPX1ZdfAPcs']\n//-----------------------------------------------------------------------------------------------------------------------------------\n// 4. Filter out actors that have the marker buff indicating they have received this effect since last short or long rest\n//\nlet unFilteredTokenNames = [] // Array that contains the token names of candidates, corresponds with tokenNames\nlet unFilteredtTokenIds = []  // Array that contains the token Ids of those that can see or hear\nlet filteredTokenNames = []\nlet filteredTokenIds = []\nlet filteredOut = []\nlet filteredCount = 0\nfor (let i = 0; i < canSeeOrHearIds.length; i++) {\n    const ATOMS = canSeeOrHearIds[i].split(SEP_CHAR)\n    if (TL > 2) jez.trace(`${TAG} ${ATOMS.length} ATOMS`, ATOMS)\n    if (ATOMS.length === 1) return jez.badNews(`Bad Juju. id value found for ${canSeeOrHearIds[i]}`)\n    let unFilteredTokenName = ''\n    for (let j = 0; j < ATOMS.length - 1; j++) unFilteredTokenName += ATOMS[j] // Rebuild name\n    unFilteredTokenNames.push(unFilteredTokenName)              // Push name into display array\n    unFilteredtTokenIds.push(ATOMS[ATOMS.length - 1])                          // Push correponding id\n    // Search for the token data that matches our current id\n    let unFilteredToken5e = canvas.tokens.placeables.find(ef => ef.id === unFilteredtTokenIds[i])\n    if (!unFilteredToken5e) return jez.badNews(`Could not find ${unFilteredTokenNames[i]} ${unFilteredtTokenIds[i]}`,'w')\n    // Search our subject token for the marker buff from this item\n    let aEffect = await unFilteredToken5e.actor?.effects?.find(ef => ef?.data?.label === aItem.name)\n    if (aEffect) {\n        if (TL > 2) jez.trace(`${TAG} ${aItem.name} found on ${unFilteredToken5e.name}, skipping`)\n        filteredOut.push(unFilteredToken5e.name)\n        continue\n    }\n    filteredTokenNames.push(`${++filteredCount}. ${unFilteredTokenNames[i]}`)\n    filteredTokenIds.push(unFilteredtTokenIds[i])\n}\nif (TL > 1) jez.trace(`${TAG} array contents`,'filteredTokenNames',filteredTokenNames,'filteredTokenIds',filteredTokenIds,\n    'filteredOut',filteredOut)\n//-----------------------------------------------------------------------------------------------------------------------------------\n// 5. Present dialog to obtain selections for the buff\n//\nconst BUFFIES = await pickBuffies(filteredTokenNames, '', filteredOut, { traceLvl: TL })\nif (!BUFFIES) {\n    if (TL > 3) jez.trace(`${TAG} BUFFIES`, BUFFIES)\n    return\n}\nif (!BUFFIES === undefined) return\n//-----------------------------------------------------------------------------------------------------------------------------------\n// 6. Use the return value (BUFFIES) to build an array of the tokens to be bolsetered.  \n// Buffies might contain: ['4. Guard Captain', '6. Militia Leader', '7. Minnie McWizard']\n// The number indicates the position in the array of potential targets.\n//\nlet bolsterTokens = []\nlet indexes = []\nif (TL > 2) jez.trace(`${TAG} Buffies`, BUFFIES);\nfor (let i = 0; i < BUFFIES.length; i++) indexes.push(parseInt(BUFFIES[i]))\nif (TL > 3) jez.trace(`${TAG} indexes`, indexes);\nfor (let i = 0; i < indexes.length; i++) {\n    bolsterTokens.push(canvas.tokens.placeables.find(ef => ef.id === filteredTokenIds[indexes[i] - 1]))\n}\nif (TL > 3) jez.trace(`${TAG} bolsterTokens`, bolsterTokens);\n//-----------------------------------------------------------------------------------------------------------------------------------\n// 7. Launch VFX on caster\n//\nrunVFXCaster(aToken)\n//-----------------------------------------------------------------------------------------------------------------------------------\n// 8. Launch VFX on tokens receiving bolster\n//\nrunVFX(bolsterTokens)\n//-----------------------------------------------------------------------------------------------------------------------------------\n// 9. Make the Midi call to apply the temp health (temphp)\n//\nconst DAM_TYPE = 'temphp'\nlet TEMP_HP_ROLL = new Roll(`${TEMP_HP}`).evaluate({ async: false });\nawait new MidiQOL.DamageOnlyWorkflow(aActor, aToken, TEMP_HP, DAM_TYPE, bolsterTokens, TEMP_HP_ROLL, {\n    flavor: `(${CONFIG.DND5E.healingTypes[DAM_TYPE]})`, itemCardId: args[0].itemCardId, useOther: false\n});\nreplaceHitsWithBolsters() // Updates chat card to say \"Bolsters\" instead of \"hits\"\n//-----------------------------------------------------------------------------------------------------------------------------------\n// 10. Apply a marker buff indicating that Inspiring Leader has been applied\n//\nconst EXPIRE = [\"longRest\", \"shortRest\"];\nlet effectData = [{\n    label: aItem.name,\n    icon: aItem.img,\n    disabled: false,\n    origin: aItem.uuid,\n    flags: {\n        dae: {\n            macroRepeat: \"none\",\n            specialDuration: EXPIRE\n        },\n        convenientDescription: `${aToken.name}'s Inspiring Leader Benefit Received.`\n    },\n}];\nfor (let i = 0; i < bolsterTokens.length; i++) {\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: bolsterTokens[i].actor.uuid, effects: effectData });\n}\n//-----------------------------------------------------------------------------------------------------------------------------------\n// All Done\n//\nif (TL > 1) jez.trace(`${TAG} === Finished ===`);\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ***********************************************************************************************************************************\n * Finding the set of all creatures within 30 feet that can see the caster \n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function getThoseThatCanSee(options = {}) {\n    const FUNCNAME = \"getThoseThatCanSee(options = {}\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    //\n    let opts = {\n        exclude: \"none\",        // self, friendly, or none (self is default)\n        chkSight: true,         // Boolean (false is default)\n        chkBlind: true,         // Boolean (false is default)\n        traceLvl: TL,            // Trace level, integer typically 0 to 5\n    }\n    let returned = await jez.inRangeTargets(aToken, RANGE, opts);\n    // if (returned.length === 0) return jez.badNews(`No effectable targets in range`, \"i\")\n    // if (TL>1) for (let i = 0; i < returned.length; i++) jez.trace(`${FNAME} | Targeting: ${returned[i].name}`)\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (TL > 0) jez.trace(`${TAG} --- Finished ---`);\n    return returned;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n* Find the set of all creatures within 30 feet that can hear the caster \n*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function getThoseThatCanHear(options = {}) {\n    const FUNCNAME = \"getThoseThatCanSee(options = {}\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    //\n    let opts = {\n        exclude: \"none\",        // self, friendly, or none (self is default)\n        chkHear: true,\n        chkDeaf: true,          // Boolean (false is default)\n        traceLvl: TL,           // Trace level, integer typically 0 to 5\n    }\n    let returned = await jez.inRangeTargets(aToken, RANGE, opts);\n    // if (returned.length === 0) return jez.badNews(`No effectable targets in range`, \"i\")\n    // if (TL>1) for (let i = 0; i < returned.length; i++) jez.trace(`${FNAME} | Targeting: ${returned[i].name}`)\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (TL > 0) jez.trace(`${TAG} --- Finished ---`);\n    return returned;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n* Find the set of all creatures within 30 feet that can hear the caster \n*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function pickBuffies(tokenNames, xtraMsg, filteredNames, options = {}) {\n    const FUNCNAME = \"pickBuffies(tokenNames, xtraMsg, filteredNames, options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting`, 'tokenNames', tokenNames, 'xtraMsg', xtraMsg, \"filteredNames\", filteredNames,\n        \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    //\n    let queryTitle = \"Select Up to Six to Receive Buff\"\n    if (filteredNames.length <= 6) queryTitle = \"Select Creatures to Receive Buff\"\n    let queryText = `Pick creatures that should be bolsetered by this spell.<br><br>${xtraMsg}`\n    let filterMsg = \"\"\n    if (filteredNames.length > 0) {\n        if (!filterMsg) filterMsg = `Some in range creatures (${filteredNames.length}) have benefited from <b>${aItem.name}</b> since \n            last rest: `\n        for (let i = 0; i < filteredNames.length; i++) {\n            filterMsg += filteredNames[i]\n            if (i < (filteredNames.length - 1) ) filterMsg += ', '\n            else filterMsg += '<br><br>'\n        }\n        queryText += filterMsg\n    }\n    const SELECTIONS = await jez.pickCheckListArray(queryTitle, queryText, null, tokenNames);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // If cancel button was selected on the preceding dialog, null is returned ==> Terminate\n    //\n    if (SELECTIONS === null) return;\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // If nothing was selected (empty array), call again and terminate this one\n    //\n    if (SELECTIONS.length === 0) {\n        xtraMsg = `No creatures selected last try.  Please select at least one before clicking <b>Selected Only</b> button.<br><br>`\n        pickBuffies(tokenNames, xtraMsg, filteredNames, { traceLvl: TL })\t\t// itemSelected is a global that is passed to preceding func\n        return;\n    }\n    //--------------------------------------------------------------------------------------------\n    // If more than six selected (empty array), call again and terminate this one\n    //\n    if (SELECTIONS.length > 6) {\n        xtraMsg = `Pick no more than six creatures. You selected ${SELECTIONS.length}.<br><br>`\n        pickBuffies(tokenNames, xtraMsg, { traceLvl: TL })\t\t// itemSelected is a global that is passed to preceding func\n        return;\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (TL > 0) jez.trace(`${TAG} --- Finished ---`);\n    return SELECTIONS;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Replace first \" hits\" with \" Bolsters\" on chat card\n*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function replaceHitsWithBolsters() {\n    let chatmsg = game.messages.get(args[0].itemCardId);\n    let content = await duplicate(chatmsg.data.content);\n    const searchString = / hits/g;\n    const replaceString = `<p style=\"color:Green;\"> Bolsters</p>`;\n    content = await content.replace(searchString, replaceString);\n    await chatmsg.update({ content: content });\n    await ui.chat.scrollBottom();\n    return;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Play the VFX on the beneficiaries\n*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function runVFX(tokens) {\n    let vfxEffect = \"modules/jb2a_patreon/Library/Generic/Template/Circle/OutPulse/OutPulse_01_Regular_PurplePink_Burst_600x600.webm\"\n    for (let i = 0; i < tokens.length; i++) {\n        await jez.wait(Math.floor(Math.random() * 2000))\n        new Sequence()\n            .effect()\n            .file(vfxEffect)\n            .playbackRate(0.4)\n            .atLocation(tokens[i])\n            .scale(0.3)\n            .opacity(1)\n            .play();\n    }\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Play the VFX onthe caster\n*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function runVFXCaster(token) {\n    new Sequence()\n        .effect()\n        .file(aItem.img)\n        .duration(8000)\n        .atLocation(token)\n        // .fadeIn(500)\n        // .scaleIn(0.5, 1000)\n        .scaleToObject(0.5)\n        .scaleOut(16, 4000, { delay: -4000 })\n        .fadeOut(4000)\n        .opacity(1)\n        .play();\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "betterCurses": {
      "isCurse": false,
      "curseName": "",
      "formula": "",
      "mwak": false,
      "rwak": false,
      "msak": false,
      "rsak": false
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "core": {
      "sourceId": "Item.OZhMaNwZmZ5lUdxX"
    },
    "exportSource": {
      "world": "travels-in-barovia-ce",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.2"
    }
  }
}