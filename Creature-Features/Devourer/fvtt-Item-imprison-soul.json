{
  "name": "Imprison Soul",
  "type": "feat",
  "img": "systems/dnd5e/icons/skills/green_25.jpg",
  "data": {
    "description": {
      "value": "<p>%TOKENNAME% pulls the body to it and shoves it within its exposed ribcage.</p>\n<section class=\"secret\">\n<p>The %TOKENNAME% chooses a living humanoid with 0 hit points that it can see within 30 feet of it.</p>\n<p>That creature is teleported inside the %TOKENNAME%&rsquo;s ribcage and imprisoned there. A creature imprisoned in this manner has disadvantage on death saving throws.</p>\n<p>If it dies while imprisoned, the %TOKENNAME% regains 25(4d10+3) hit points, immediately recharges Soul Rend, and gains an additional action on its next turn.</p>\n<p>Additionally, at the start of its next turn, the %TOKENNAME% regurgitates the slain creature as a bonus action, and the creature becomes an undead. If the victim had 2 or fewer Hit Dice, it becomes a zombie. If it had 3 to 5 Hit Dice, it becomes a ghoul. Otherwise, it becomes a wight. A %TOKENNAME% can imprison only one creature at a time.</p>\n<p>Homebrew: If the target is a recently deceased NPC, it can be imprisoned. An imprisoned NPC can be<span style=\"font-family: var(--font-primary); font-size: var(--font-size-14);\">&nbsp;expelled with the %TOKENNAME%'s next bonus action.</span></p>\n<hr />\n<p><strong>FoundryVTT</strong>: The extra action is not automated.&nbsp; Regurgitation is triggered by using this ability while a corpse is being digested. Hit points are only gained when the corpse is regurgitated.</p>\n</section>",
      "chat": "",
      "unidentified": ""
    },
    "source": "Volo's Guide to Monsters pg 138",
    "activation": {
      "type": "bonus",
      "cost": 1,
      "condition": "Target is dieing within 30 feet"
    },
    "duration": {
      "value": null,
      "units": "inst"
    },
    "target": {
      "value": null,
      "width": null,
      "units": "",
      "type": ""
    },
    "range": {
      "value": null,
      "long": null,
      "units": ""
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "other",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": null,
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "flat"
    },
    "requirements": "",
    "recharge": {
      "value": null,
      "charged": false
    },
    "properties": {
      "amm": false,
      "fin": false,
      "fir": false,
      "foc": false,
      "hvy": false,
      "lgt": false,
      "lod": false,
      "rch": false,
      "rel": false,
      "ret": false,
      "spc": false,
      "thr": false,
      "two": false,
      "ver": false
    },
    "proficient": false
  },
  "effects": [],
  "flags": {
    "ddbimporter": {
      "dndbeyond": {}
    },
    "monsterMunch": {
      "titleHTML": "<strong>Imprison Soul.</strong>",
      "fullName": "Imprison Soul."
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Imprison Soul",
          "type": "script",
          "author": "ZjFlOWYxZjM5ZTZj",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const MACRONAME = \"Devourer_Imprison_Soul.0.1.js\"\nconst TL = 0                               // Trace Level for this macro\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Implement Devourer's Imprison Soul.  This ability is a mess!\n * \n *   The devourer chooses a living humanoid with 0 hit points that it can see within 30 feet of it.\n * \n *   That creature is teleported inside the devourer's ribcage and imprisoned there. A creature \n *   imprisoned in this manner has disadvantage on death saving throws.\n * \n *   If it dies while imprisoned, the devourer regains 25 hit points, immediately recharges Soul \n *   Rend, and gains an additional action on its next turn.\n * \n *   Additionally, at the start of its next turn, the devourer regurgitates the slain creature as a \n *   bonus action, and the creature becomes an undead. If the victim had 2 or fewer Hit Dice, it \n *   becomes a zombie. If it had 3 to 5 Hit Dice, it becomes a ghoul. Otherwise, it becomes a wight. \n *   A devourer can imprison only one creature at a time.\n * \n * Because I find it annoying that this doesn't work on an NPC, I'm adding the following homebrew:\n * \n *   If the target is a recently deceased NPC, it can be imprisoned.  An imprisoned NPC can be \n *   expelled with the Devourer's next bonus action.\n * \n * 10/02/23 0.1 Creation of Macro from Rutterkin_Crippling_Fear.0.1.js\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nconst MACRO = MACRONAME.split(\".\")[0]       // Trim off the version number and extension\nconst TAG = `${MACRO} |`\nlet msg = \"\";                               // Global message string\n//---------------------------------------------------------------------------------------------------\nif (TL > 1) jez.log(`${TAG} === Starting ===`);\nif (TL > 2) for (let i = 0; i < args.length; i++) jez.log(`  args[${i}]`, args[i]);\nconst LAST_ARG = args[args.length - 1]; // See https://gitlab.com/tposney/dae#lastarg for contents\n//---------------------------------------------------------------------------------------------------\n// Set the value for the Active Token (aToken)\nlet aToken;\nif (LAST_ARG.tokenId) aToken = canvas.tokens.get(LAST_ARG.tokenId);\nelse aToken = game.actors.get(LAST_ARG.tokenId);\nlet aActor = aToken.actor;\n//\n// Set the value for the Active Item (aItem)\nlet aItem;\nif (args[0]?.item) aItem = args[0]?.item;\nelse aItem = LAST_ARG.efData?.flags?.dae?.itemData;\n//---------------------------------------------------------------------------------------------------\n// Set Macro specific globals\n//\nconst EFFECT_NAME = \"Imprisoned Soul\"\nconst EFFECT2_NAME = 'Digesting'\nconst EFFECT_IMAGE = aItem.img\nconst EFFECT2_IMAGE = \"Icons_JGB/Misc/stomach.webp\"\nlet ceDesc = \"\"\nconst GAME_RND = game.combat ? game.combat.round : 0;\nconst MAX_RANGE = 30 // feet\n//---------------------------------------------------------------------------------------------------\n// Run the main procedures, choosing based on how the macro was invoked\n//\nif (args[0]?.tag === \"OnUse\") await doOnUse({ traceLvl: TL });     // Midi ItemMacro On Use\nif (args[0] === \"off\") await doOff({ traceLvl: TL });              // DAE removal\nif (TL > 1) jez.log(`=== Finished === ${MACRONAME} ===`);\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ****************************************************************************************************\n * Post results to the chat card\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nfunction postResults(msg) {\n    const FUNCNAME = \"postResults(msg)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL > 1) jez.log(`${TAG} --- Starting ---`);\n    if (TL > 2) jez.log(\"postResults Parameters\", \"msg\", msg)\n    //-----------------------------------------------------------------------------------------------\n    let chatMsg = game.messages.get(args[args.length - 1].itemCardId);\n    jez.addMessage(chatMsg, { color: jez.randomDarkColor(), fSize: 14, msg: msg, tag: \"saves\" });\n    if (TL > 1) jez.log(`${TAG}--- Finished ---`);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Do the things that need doing\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function doOnUse(options = {}) {\n    const FUNCNAME = \"doOnUse()\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.log(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.log(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    await jez.wait(100)\n    //-----------------------------------------------------------------------------------------------\n    // Are we already digesting a target?\n    //\n    if (jezcon.hasCE(EFFECT2_NAME, aToken.actor.uuid)) {\n        const DIGESTING_EFFECT = await aActor?.effects?.find(ef => ef?.data?.label === EFFECT2_NAME)\n        if (TL > 2) jez.log(`${TAG} Digesting Effect`, DIGESTING_EFFECT)\n        if (!DIGESTING_EFFECT) return jez.badNews(`Could not find ${DIGESTING_EFFECT}`,'e')\n        const CE_DESC = DIGESTING_EFFECT.data.flags.convenientDescription\n        if (TL > 2) jez.log(`${TAG} Description`, CE_DESC)\n        const DESC_ATOMS = CE_DESC.split(' ')\n        const TARGET_ID = DESC_ATOMS[DESC_ATOMS.length - 1]\n        if (TL > 2) jez.log(`${TAG} Target ID`, TARGET_ID)\n        const TARGET_TOKEN = canvas.tokens.placeables.find(ef => ef.id === TARGET_ID)\n        if (TL > 2) jez.log(`${TAG} Target Token`, TARGET_TOKEN)\n        // Is our target dead?  (3 failed saves, if so, drop the effect and spit out an undead)\n        if (TL > 3) jez.log(`${TAG} Consume check`, 'jez.isNPC(TARGET_TOKEN)', await jez.isNPC(TARGET_TOKEN),\n        'TARGET_TOKEN.actor.data.data.attributes.death.failure', TARGET_TOKEN.actor.data.data.attributes.death.failure)\n        if (await jez.isNPC(TARGET_TOKEN) || TARGET_TOKEN.actor.data.data.attributes.death.failure > 2) {\n            await tokenAttacher.detachElementsFromToken([TARGET_TOKEN], aToken, true);\n            const EFFECT = await aToken?.actor?.effects?.find(ef => ef?.data?.label === EFFECT2_NAME)\n            EFFECT.delete()\n            placeUndead(TARGET_TOKEN, {traceLvl: TL})\n            healSelf(aToken, {traceLvl: TL})\n            await jez.wait(500)\n            return postResults(`${TARGET_TOKEN.name} has been consumed healing ${aToken.name}. \n                Remnants are vomited forth and a undead rises `)\n        }\n        if (await jez.isPC(TARGET_TOKEN) && TARGET_TOKEN.actor.data.data.attributes.death.failure < 3)\n            return postResults(`${TARGET_TOKEN.name} is not dead, yet.`)\n        if (TL > 1) jez.log(`${TAG} ${aToken.name} is already ${EFFECT2_NAME}.`)\n        return postResults(`${aToken.name} is already ${EFFECT2_NAME} ${TARGET_TOKEN.name}`)\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Since not digesting, we need a target, make sure we have one\n    //\n    if (args[0].targets.length !== 1) return jez.badNews(`Need a target.`, 'w')\n    let tToken = canvas.tokens.get(args[0]?.targets[0]?.id); // First Targeted Token, if any\n    let tActor = tToken?.actor;\n    //-----------------------------------------------------------------------------------------------\n    // Do we have a legitimate target?  It must meet the spell criteria:\n    //  1. Within 30 feet \n    //  2. Must be a PC, NPCs are dead at 0 hp\n    //  3. Must be at 0 HP\n    //  4. Must not have three failed death saves.\n    //\n    // Above modified by my homebrew for NPC corpses\n    //\n    const TOKEN_DATA = await tActor.getTokenData()\n    if (TL > 1) jez.log(`${TAG} | TOKEN_DATA`,TOKEN_DATA)\n    // Check the distance\n    if (jez.getDistance5e(aToken, tToken) > MAX_RANGE) return postResults(`${tToken.name} is too far away.`)\n    // Is the target a PC?\n    // if (await jez.isNPC(tActor.uuid))  return postResults(`${tToken.name} is an NPC.`)\n    // Is the target at 0 HP?\n    // if (tActor.data.data.attributes.hp.value > 0) return postResults(`${tToken.name} is not dieing.`)\n    // Has the target failed three death saves?\n    // if (tActor.data.data.attributes.death.failure > 2) return postResults(`${tToken.name} is already dead.`)\n    if (tActor.data.data.attributes.hp.value > 0) return postResults(`${tToken.name} is not dieing.`)\n    if (await jez.isPC(tActor))\n        if (tActor.data.data.attributes.death.failure > 2) return postResults(`${tToken.name} is already dead.`)\n    //------------------------------------------------------------------------------------------------------------------------\n    // Use tokenAttacher to attach the tToken to the aToken\n    //\n    let newCoords = { x: tToken.x, y: tToken.y };\n    if (aToken.x + aToken.w - tToken.w < tToken.x) newCoords.x = aToken.x + aToken.w - tToken.w;\n    else if (aToken.x > tToken.x) newCoords.x = aToken.x;\n    if (aToken.y + aToken.h - tToken.h < tToken.y) newCoords.y = aToken.y + aToken.h - tToken.h;\n    else if (aToken.y > tToken.y) newCoords.y = aToken.y;\n    await tToken.document.update({ x: newCoords.x, y: newCoords.y });\n    await tokenAttacher.attachElementToToken(tToken, aToken, true);\n    await tokenAttacher.setElementsLockStatus(tToken, false, true);\n    await tokenAttacher.setElementsMoveConstrainedStatus(tToken, true, true, { type: tokenAttacher.CONSTRAINED_TYPE.TOKEN_CONSTRAINED });\n    //-----------------------------------------------------------------------------------------------\n    // Apply EFFECT_NAME to tActor which forces disadvantage on death saves.\n    //\n    await applyImprisoned(tToken, aToken)\n    //-----------------------------------------------------------------------------------------------\n    // Apply EFFECT2_NAME to aActor keeping track of id of swallowed token.\n    //\n    await applyDigesting(aToken, tToken)\n    //-----------------------------------------------------------------------------------------------\n    // Pair the effects\n    //\n    // await jez.wait(1000)\n    const EFFECT = await aToken?.actor?.effects?.find(ef => ef?.data?.label === EFFECT2_NAME)\n    if (TL > 2) jez.log(`${TAG} EFFECT applied: `, EFFECT)\n    // Find the draining effect on our active actor\n    const EFFECT2 = await tToken?.actor?.effects?.find(ef => ef?.data?.label === EFFECT_NAME)\n    if (TL > 2) jez.log(`${TAG} EFFECT2 applied: `, EFFECT2)\n    const GM_PAIR_EFFECTS = jez.getMacroRunAsGM(\"PairEffects\") \n    if (!GM_PAIR_EFFECTS) return jez.badNews(`Could not find PairEffects macro`,'e')\n    GM_PAIR_EFFECTS.execute(EFFECT.uuid, EFFECT2.uuid)\n    //-----------------------------------------------------------------------------------------------\n    // Post message\n    //\n    postResults(`${aToken.name} pulls the body of ${tToken.name} to it and shoves it within its exposed ribcage.`);\n    return\n}\n/***************************************************************************************************\n * Apply the Fear condition to a token, adding CEDesc\n ***************************************************************************************************/\nasync function applyImprisoned(token, actor) {\n    const CE_DESC = `Imprisoned within ${actor.name}`\n    let effectData = [{\n        label: EFFECT_NAME,\n        icon: EFFECT_IMAGE,\n        origin: LAST_ARG.uuid,\n        disabled: false,\n        flags: {\n            dae: { stackable: false },\n            convenientDescription: CE_DESC,\n            isConvenient: true,\n            isCustomConvenient: true,\n            core: { statusId: 'Force Display' }\n        },\n        changes: [\n            { key: `flags.midi-qol.disadvantage.deathSave`, mode: jez.CUSTOM, value: '0', priority: 20 },\n            { key: `macro.itemMacro`, mode: jez.CUSTOM, value: aToken.id, priority: 20 },\n        ]\n    }];\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: token.actor.uuid, effects: effectData });\n    // runVFX(token)\n}\n/***************************************************************************************************\n * Apply the Immunity condition to a token, adding CEDesc\n ***************************************************************************************************/\nasync function applyDigesting(token, target) {\n    const CE_DESC = `Digesting ${target.name} ${target.id}`\n    let effectData = [{\n        label: EFFECT2_NAME,\n        icon: EFFECT2_IMAGE,\n        origin: LAST_ARG.uuid,\n        disabled: false,\n        // duration: { rounds: 14400, seconds: 86400, startRound: GAME_RND, startTime: game.time.worldTime },\n        flags: {\n            dae: { stackable: false },\n            convenientDescription: CE_DESC,\n            isConvenient: true,\n            isCustomConvenient: true,\n            core: { statusId: 'Force Display' }\n        },\n    }];\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: token.actor.uuid, effects: effectData });\n}\n/***************************************************************************************************\n * Additionally, at the start of its next turn, the devourer regurgitates the slain creature as a \n * bonus action, and the creature becomes an undead. If the victim had 2 or fewer Hit Dice, it \n * becomes a zombie. If it had 3 to 5 Hit Dice, it becomes a ghoul. Otherwise, it becomes a wight. \n * A devourer can imprison only one creature at a time.\n ***************************************************************************************************/\nasync function placeUndead(tToken, options={}) {\n    const FUNCNAME = \"placeUndead(tToken, options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.log(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.log(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"tToken\", tToken, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    const HIT_DICE_CNT = await jez.isPC(tToken) ? tToken.actor.data.data.details.level : tToken.actor.data.data.details.cr\n    if (TL > 2) jez.log(`${TAG} HIT_DICE_CNT`, HIT_DICE_CNT)\n    let spawn = \"Wight\"\n    if (HIT_DICE_CNT <= 2) spawn = \"Zombie\"\n    if (HIT_DICE_CNT >= 3 && HIT_DICE_CNT <= 5) spawn = \"Ghoul\"\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Nab the data for our soon to be summoned critter so we can have the right image (img) and use it\n    // to update the img attribute or set basic image to match this item\n    //\n    let summonData = await game.actors.getName(spawn)\n    if (TL > 2) jez.log(`${TAG} summonData`, summonData)\n    if (!summonData) return jez.badNews(`Could not find ${spawn} template actor`, 'e')\n    // Build the dataObject for our summon call, all we need to do is customize the name and elevation\n    let argObj = {\n        minionName: `${aToken.name}'s ${spawn}`,\n        img: summonData?.img ?? aItem.img,\n        defaultRange: 15    // Keep the up chucked undead kinda close\n    }\n    if (TL > 2) jez.log(`${TAG} argObj`, argObj)\n    // Do the actual summon\n    summonedMinionId = await jez.spawnAt(spawn, aToken, aActor, aItem, argObj)\n    if (TL > 2) jez.log(`${TAG} summonedMinionId`, summonedMinionId)\n    // Add our summons to combat tracker after summoner if in combat\n    const ATOKEN_INIT_VALUE = aToken?.combatant?.data?.initiative\n    if (TL > 1) jez.trace(`${TAG} ${aToken.name} initiative`, ATOKEN_INIT_VALUE);\n    if (ATOKEN_INIT_VALUE) {\n        const SPAWN_INT = ATOKEN_INIT_VALUE - 1 / 1000;\n        await jez.combatAddRemove('Add', summonedMinionId[0], { traceLvl: TL })\n        await jez.wait(250)\n        await jez.combatInitiative(summonedMinionId[0], { formula: SPAWN_INT, traceLvl: 0 })\n    }\n    if (TL > 1) jez.log(`${TAG} --- Finished ---`);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Release the follow when effect goes away\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function doOff(options = {}) {\n    const FUNCNAME = \"doOff(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.log(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.log(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    //\n    const TAR_TOKEN = canvas.tokens.placeables.find(ef => ef.id === args[1])\n    if (TL > 1) jez.log(`${TAG} TAR_TOKEN`, TAR_TOKEN);\n    await tokenAttacher.detachElementsFromToken([aToken], TAR_TOKEN, true);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    if (TL > 1) jez.log(`${TAG} --- Finished ---`);\n    return;\n}\n/***************************************************************************************************\n * Devourer regains 25(4d10+3) hit points, immediately recharges Soul Rend... \n ***************************************************************************************************/\nasync function healSelf(tToken, options={}) {\n    const FUNCNAME = \"placeUndead(tToken, options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.log(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.log(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"tToken\", tToken, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    const DAM_TYPE = \"healing\";\n    const DICE_NUM = 4;\n    const DICE_TYPE = 'd10';\n    const BONUS = 3;\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Do the healing\n    //\n    let healDamage = new Roll(`${DICE_NUM}${DICE_TYPE} + ${BONUS}`).evaluate({ async: false });\n    game.dice3d?.showForRoll(healDamage);   // Show 3D die on screen\n    await new MidiQOL.DamageOnlyWorkflow(aActor, aToken, healDamage.total, DAM_TYPE, [tToken],\n        healDamage, {flavor: `(${CONFIG.DND5E.healingTypes[DAM_TYPE]})`,\n        itemCardId: args[0].itemCardId, useOther: false\n    });\n    await replaceHitsWithHeals();\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Recharge soul rend\n    //\n    // Read the data for soul rend from the actor\n    // let soulRendData = aActor.items.get('Soul Rend');\n    let soulRendData = aToken.actor.items.find(i => i.data.name === \"Soul Rend\");\n    if (TL > 2) jez.trace(`${TAG} soulRendData before recharge`,soulRendData)\n    if (!soulRendData) return jez.badNews(`Soul Rend not found on ${aToken.name}`,\"e\")\n    // Duplicate soul rend data and update fields\n    let copy_item = duplicate(soulRendData);\n    if (TL > 2) jez.trace(`${TAG} copy_item`,copy_item)\n    copy_item.data.recharge.charged = true;\n    if (TL > 2) jez.trace(`${TAG} copy_item after update`,copy_item)\n    // Update soul rend \n    await aActor.updateEmbeddedDocuments(\"Item\", [copy_item])\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    if (TL > 1) jez.log(`${TAG} --- Finished ---`);\n    return;\n}\n/***************************************************************************************\n * Replace first \" hits\" with \" heals\" on chat card\n ***************************************************************************************/\nasync function replaceHitsWithHeals() {\n    const FUNCNAME = \"replaceHitsWithHeals()\";\n    jez.log(\"- - - - Starting ${MACRONAME} ${FUNCNAME} - - - - - - - - - - - - - - - - -\");\n    let chatmsg = game.messages.get(args[0].itemCardId);\n    let content = await duplicate(chatmsg.data.content);\n    const searchString = / hits/g;\n    const replaceString = `<p style=\"color:Green;\"> Heals</p>`;\n    content = await content.replace(searchString, replaceString);\n    await chatmsg.update({ content: content });\n    await ui.chat.scrollBottom();\n    jez.log(\"- - - - Finished ${MACRONAME} ${FUNCNAME} - - - - - - - - - - - - - - - -\");\n    return;\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "magicitems": {
      "enabled": false,
      "equipped": false,
      "attuned": false,
      "charges": "0",
      "chargeType": "c1",
      "destroy": false,
      "destroyFlavorText": "reaches 0 charges: it crumbles into ashes and is destroyed.",
      "rechargeable": false,
      "recharge": "0",
      "rechargeType": "t1",
      "rechargeUnit": "r1",
      "sorting": "l"
    },
    "midi-qol": {
      "effectActivation": false,
      "onUseMacroName": "[postActiveEffects]ItemMacro"
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "core": {
      "sourceId": "Item.ad9LzctR0Z2pdL6q"
    },
    "exportSource": {
      "world": "travels-in-barovia-ce",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.2"
    }
  }
}