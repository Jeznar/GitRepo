{
  "name": "Find Familiar",
  "type": "spell",
  "img": "/systems/dnd5e/icons/spells/wild-eerie-2.jpg",
  "data": {
    "description": {
      "value": "<p>Your familiar acts independently of you, but it always obeys your commands. In combat, it rolls its own initiative and acts on its own turn. A familiar can’t attack, but it can take other actions as normal.</p>\n<p><a href=\"https://www.dndbeyond.com/spells/find-familiar\" target=\"_blank\" rel=\"noopener\">See D&amp;D Beyond for additional information.</a></p>\n<p><em>Requires: 10 gp worth of @Item[S2KAJtj3VfwaYg3w]{Incense, Charcoal and Herbs} that must be consumed by fire in a brass brazier</em></p>\n<hr />\n<p><strong>FoundryVTT: </strong>This is largely automated, including searching actor directory for allowed familiar forms.</p>\n<p>Setting the item name to be \"Find Familiar - &lt;NAME&gt;\" will short circuit the dialog that picks the type of familiar.</p>",
      "chat": "",
      "unidentified": ""
    },
    "source": "PHB pg. 240",
    "activation": {
      "type": "hour",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": null,
      "units": "inst"
    },
    "target": {
      "value": null,
      "width": null,
      "units": "any",
      "type": "space"
    },
    "range": {
      "value": 10,
      "long": 0,
      "units": "ft"
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "material",
      "target": "",
      "amount": 1
    },
    "ability": "",
    "actionType": "util",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": null
    },
    "damage": {
      "parts": [],
      "versatile": "",
      "value": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell",
      "value": ""
    },
    "level": 1,
    "school": "con",
    "components": {
      "value": "",
      "vocal": true,
      "somatic": true,
      "material": true,
      "ritual": true,
      "concentration": false
    },
    "materials": {
      "value": "10 gp worth of charcoal, incense, and herbs that must be consumed by fire in a brass brazier",
      "consumed": true,
      "cost": 10,
      "supply": 0
    },
    "preparation": {
      "mode": "pact",
      "prepared": false
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    },
    "attunement": 0
  },
  "effects": [],
  "flags": {
    "core": {
      "sourceId": "Item.YWUzNmI2OWJjZWQ3"
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Find Familiar",
          "type": "script",
          "author": "ZjFlOWYxZjM5ZTZj",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const MACRONAME = \"Find_Familiar.1.6.js\"\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Look in the sidebar for creatures that can serve as fams and provide a list of options for\n * the find fam spell. Then, execute the summon with jez.spawnAt (WarpGate)\n * \n Assumptions & Preconditions\n * Name to be used for the familiar has been set with \"Set Familiar Name\"\n * One or more familiars are stored in the folder defined by FAM_FLDR (\"Familiars\")\n * Familiars, if any, for Chain Locks stored in FAM_FLDR_CHAIN (\"Familiars Pact of the Chain\")\n * Feature named PACT_OF_THE_CHAIN (\"Pact of the Chain\") spelled exactly enables Chain Lock\n * Familiars have unique names, i.e. there is only one \"bat,\" \"raven,\" etc.\n * Feature CHAIN_MASTER_PACT, if present results in message reminding that this is not automated.\n\n * 08/18/22 1.0 Creation\n * 08/29/22 1.1 Update familiar's name to use just the caster's first name token\n *              Set size of token being summoned to match the summoned creature (lib call does not \n *                  support less than size 1)\n * 08/30/22 1.2 Add effect to caster that deletes summoned familiar when it is removed\n * 08/30/22 1.3 Added shortcut selection triggered by aItem.name containing a \"-\" character\n * 08/31/22 1.4 Teach the code to modify saving throws for CHAIN_MASTER_PACT familiar\n * 09/01/22 1.5 Genralize handling of CHAIN_MASTER_PACT familiar savingthrow change\n * 09/02/22 1.6 Add support for CHAIN_MASTER_VOICE\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nconst MACRO = MACRONAME.split(\".\")[0]       // Trim of the version number and extension\nconst TAG = `${MACRO} |`\nconst TL = 0;                               // Trace Level for this macro\nconst FAM_FLDR = \"Familiars\"\nconst FAM_FLDR_CHAIN = \"Familiars Pact of the Chain\"\nconst PACT_OF_THE_CHAIN = \"Pact of the Chain\"\nconst CHAIN_MASTER_PACT = \"Invocation: Investment of the Chain Master\"\nconst CHAIN_MASTER_VOICE = \"Invocation: Voice of the Chain Master\"\nconst SPELL_NAME = `Find Familiar`\nconst TEMPLATE_SPELL = \"%%Swap Senses (Familiar)%%\" // Name as expected in Items Directory \n\nlet msg = \"\";                               // Global message string\n//---------------------------------------------------------------------------------------------------\nif (TL > 1) jez.trace(`=== Starting === ${MACRONAME} ===`);\nif (TL > 2) for (let i = 0; i < args.length; i++) jez.trace(`  args[${i}]`, args[i]);\nconst LAST_ARG = args[args.length - 1];\n//---------------------------------------------------------------------------------------------------\n// Set the value for the Active Token (aToken)\nlet aToken;\nif (LAST_ARG.tokenId) aToken = canvas.tokens.get(LAST_ARG.tokenId);\nelse aToken = game.actors.get(LAST_ARG.tokenId);\nlet aActor = aToken.actor;\nconst FIRST_NAME_TOKEN = aToken.name.split(\" \")[0]     // Grab the first word from the selection\n//\n// Set the value for the Active Item (aItem)\nlet aItem;\nif (args[0]?.item) aItem = args[0]?.item;\nelse aItem = LAST_ARG.efData?.flags?.dae?.itemData;\n//---------------------------------------------------------------------------------------------------\n//\nlet famNames = []   // Global array to hold the list of familiar names\nconst FLAG_NAME = \"familiar_name\"\nconst FAM_NAME = DAE.getFlag(aActor, FLAG_NAME)\n//---------------------------------------------------------------------------------------------------\n// Run the main procedures, choosing based on how the macro was invoked\n//\nif (args[0] === \"off\") await doOff();                           // DAE removal\nif (args[0]?.tag === \"OnUse\") await doOnUse({ traceLvl: TL });  // Midi ItemMacro On Use\n// jez.log(`============== Finishing === ${MACRONAME} =================`);\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********\n * Post results to the chat card\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nfunction postResults(msg) {\n    const FUNCNAME = \"postResults(msg)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL > 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 2) jez.trace(\"postResults Parameters\", \"msg\", msg)\n    //-----------------------------------------------------------------------------------------------\n    let chatMsg = game.messages.get(args[args.length - 1].itemCardId);\n    jez.addMessage(chatMsg, { color: jez.randomDarkColor(), fSize: 14, msg: msg, tag: \"saves\" });\n    if (TL > 1) jez.trace(`${TAG}--- Finished ---`);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Perform the code that runs when this macro is invoked as an ItemMacro \"OnUse\"\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function doOnUse(options = {}) {\n    const FUNCNAME = \"doOnUse()\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    await jez.wait(100)\n    //----------------------------------------------------------------------------------\n    // Obtain the list of familiars that can be choosen from\n    // \n    famOpts = getFamiliarOptions({ traceLvl: TL })\n    if (!famOpts) return jez.badNews(`No familiars to choose from found`, \"e\")\n    //-----------------------------------------------------------------------------------------------\n    // Build an array of familiar names, sort it and make sure they are unique\n    //\n    for (let i = 0; i < famOpts.length; i++) famNames.push(famOpts[i].name)\n    famNames = famNames.sort()\n    for (let i = 1; i < famNames.length; i++)\n        if (famNames[i - 1] === famNames[i])\n            return jez.badNews(`Duplicate familiar option (${famNames[i]} found, not allowed)`, \"e\")\n    //-----------------------------------------------------------------------------------------------\n    // Check to see if aItem.name contains a shortcut selection for familiar to be summoned.  That is\n    // a string folling the last dash character (if any) in aItem.name\n    //\n    let shortCutFamName = \"\"\n    const NAME_TOKENS = aItem.name.split(\"-\")\n    if (NAME_TOKENS.length > 1) {\n        // Set short cut name to last token with leading & trailing white space stripped\n        shortCutFamName = NAME_TOKENS[NAME_TOKENS.length - 1].trim()\n        if (TL > 1) jez.trace(`${TAG} Shortcut familiar name specified: ${shortCutFamName}`);\n        if (!famNames.includes(shortCutFamName)) {  // Is the shortcut name an allowed choice?\n            jez.badNews(`Familiar's Actor for shortcut, \"${shortCutFamName}\" not found.`, \"w\");\n            shortCutFamName = \"\"\n        }\n    }\n    //-----------------------------------------------------------------------------------------------\n    // If we have more than one familiar choice and no shortcut, setup and run a dialog to select the \n    // familiar; otherwise skip dialog and proceed\n    //\n    if (famNames.length > 1 && !shortCutFamName) popDialog1(famNames, { traceLvl: TL })\n    else callBack1(shortCutFamName)\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Grab Familiar Options\n * \n * Returns an array of the options available\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nfunction getFamiliarOptions(options = {}) {\n    const FUNCNAME = \"getFamiliarOptions(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //--------------------------------------------------------------------------------------------\n    // Grab the folder of fams from the actor directory (sidebar)\n    //\n    let famFold = game.folders.find(item => item.data.name === FAM_FLDR)\n    if (!famFold) return jez.badNews(`Could not find a folder named ${FAM_FLDR}`, \"e\")\n    if (TL > 3) jez.trace(`${TAG} Familiar Folder`, famFold)\n    //--------------------------------------------------------------------------------------------\n    // Make sure at least one familiar exists in the folder\n    //\n    if (!famFold.content || famFold.content.length === 0)\n        return jez.badNews(`No familiars found in the ${FAM_FLDR} folder`, \"e\")\n    //--------------------------------------------------------------------------------------------\n    // Convert the folder data into an array of handy actor objects\n    //\n    let famArray = []\n    for (let i = 0; i < famFold.content.length; i++) {\n        famArray[i] = {\n            name: famFold.content[i].name,\n            id: famFold.content[i].id,\n            actor5e: famFold.content[i]\n        }\n    }\n    let famCnt = famArray.length\n    //--------------------------------------------------------------------------------------------\n    // Does the caster have the \"Pact of the Chain\" (PACT_OF_THE_CHAIN) feature, and thus \n    // more options?\n    //\n    let chainLock = false   // Boolean flag indicating caster is a chain lock (or not)\n    if (aActor.items.find(i => i.name === PACT_OF_THE_CHAIN)) chainLock = true\n    if (TL > 2)\n        if (chainLock) jez.trace(`${TAG} ${FIRST_NAME_TOKEN} is a Chain Warlock`)\n        else jez.trace(`${TAG} ${FIRST_NAME_TOKEN} is not a Chain Warlock`)\n    //--------------------------------------------------------------------------------------------\n    // If we're dealing with a Chain Lock, need to add in the additional familiar options\n    //\n    if (chainLock) {\n        let chainFamFold = game.folders.find(item => item.data.name === FAM_FLDR_CHAIN)\n        if (!chainFamFold)\n            jez.badNews(`Could not find chain lock familiar folder \"${FAM_FLDR_CHAIN}\"`, \"w\")\n        else {\n            if (TL > 3) jez.trace(`${TAG} Chain Lock Familiar Folder`, chainFamFold)\n            for (let i = famCnt; i < chainFamFold.content.length + famCnt; i++) {\n                if (TL > 4) jez.trace(`${TAG} Processing`, chainFamFold.content[i - famCnt].name)\n                famArray[i] = {\n                    name: chainFamFold.content[i - famCnt].name,\n                    id: chainFamFold.content[i - famCnt].id,\n                    actor5e: chainFamFold.content[i - famCnt]\n                }\n            }\n        }\n    }\n    //--------------------------------------------------------------------------------------------\n    // Depending on TL, spit out what we have assembled\n    //\n    for (let i = 0; i < famArray.length; i++) {\n        if (TL > 3) jez.trace(`${TAG} ${i + 1} Familiar`, famArray[i].name)\n        if (TL > 5) jez.trace(`${TAG} ${i + 1} Familiar`, famArray[i].id)\n        if (TL > 4) jez.trace(`${TAG} ${i + 1} Familiar`, famArray[i].actor5e)\n    }\n    //--------------------------------------------------------------------------------------------\n    // Return results\n    //\n    return famArray\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Create the dialog to select a familiar\n * \n **********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function popDialog1(famNames, options = {}) {\n    const FUNCNAME = \"popDialog1(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"famNames\", famNames,\n        \"options\", options);\n    //-----------------------------------------------------------------------------------------------\n    // Obtain the list of familiars that can be choosen from\n    // \n    const queryTitle = \"What form for Familiar?\"\n    const queryText = \"Select the form for the familiar from drop down list\"\n    jez.pickFromListArray(queryTitle, queryText, callBack1, famNames);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Process the selection from the dialog offering list of familiar forms.\n * \n **********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function callBack1(itemSelected) {\n    const FUNCNAME = \"callBack1(itemSelected)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"itemSelected\", itemSelected);\n    //-----------------------------------------------------------------------------------------------\n    //\n    if (TL > 1) jez.trace(`${TAG} itemCallBack: Item \"${itemSelected}\" selected in the dialog`)\n    //--------------------------------------------------------------------------------------------\n    // If cancel button was selected on the preceding dialog, null is returned ==> Terminate\n    //\n    if (itemSelected === null) return;\n    //--------------------------------------------------------------------------------------------\n    // If nothing was selected call preceding function and terminate this one\n    //\n    if (!itemSelected) {\n        if (TL > 1) jez.trace(`${TAG} No selection passed to ${FUNCNAME}, trying again.`)\n        popDialog1(famNames, { traceLvl: TL })\n        return;\n    }\n    //--------------------------------------------------------------------------------------------\n    // If an existing Find_Familiar effect exists on calling actor, delete it\n    //\n    existingEffect = aActor.effects.find(ef => ef.data.label === SPELL_NAME)\n    if (existingEffect) {\n        await existingEffect.delete();\n        // await jez.deleteItems(SPELL_NAME, \"feat\", aToken.actor);\n        msg = `<b>${aToken.name}</b> previously existing familiar has been dismissed.`\n        jez.postMessage({\n            color: jez.randomDarkColor(), fSize: 13, icon: aToken.data.img, msg: msg,\n            title: `Existing Familiar Dismissed`, token: aToken\n        })\n    }\n    //--------------------------------------------------------------------------------------------\n    // Build basic data object for the summon\n    //\n    if (TL > 1) jez.trace(`${TAG} Actually summon the familiar ${itemSelected}`)\n    let famName = FAM_NAME ?? `${FIRST_NAME_TOKEN}'s ${itemSelected}`\n    const NEW_SPELL = `Swap Senses with ${famName}`\n    if (TL > 2) jez.trace(`${TAG} Familiar name: ${famName}`)\n    let argObj = {\n        defaultRange: 10,\n        duration: 3000,                     // Duration of the intro VFX\n        introTime: 1000,                    // Amount of time to wait for Intro VFX\n        introVFX: '~Energy/SwirlingSparkles_01_Regular_${color}_400x400.webm', // default introVFX file\n        minionName: famName,\n        outroVFX: '~Fireworks/Firework*_02_Regular_${color}_600x600.webm', // default outroVFX file\n        scale: 0.4,\t\t\t\t\t\t\t// Default value but needs tuning at times\n        source: aToken,                     // Coords for source (with a center), typically aToken\n        templateName: itemSelected,         // Name of the actor in the actor directory\n        traceLvl: 0\n    }\n    //-----------------------------------------------------------------------------------------------\n    // If a temp ability to swap senses for this familiar exists, delete it\n    //\n    let itemFound = aActor.items.find(item => item.data.name === NEW_SPELL && item.type === \"spell\")\n    if (itemFound) {\n        await itemFound.delete();\n        msg = `\"${NEW_SPELL}\" has been deleted from ${aToken.name}'s spell book`\n        jez.badNews(msg, \"i\");\n    }\n    //--------------------------------------------------------------------------------------------------\n    // Nab the data for our soon to be summoned critter so we can have the right image (img) and use it\n    // to update the img and width attributes or set basic image to match this item\n    //\n    let summonData = await game.actors.getName(itemSelected)\n    argObj.img = summonData ? summonData.img : aItem.img\n    argObj.width = summonData ? summonData.data.token.width : 1\n    if (TL > 2) jez.trace(`${TAG} argObj`, argObj)\n    //--------------------------------------------------------------------------------------------------\n    // Does the caster have the CHAIN_MASTER_VOICE feature?  Set boolean appropriately\n    //\n    let chainMasterVoice = false   // Boolean flag indicating caster has CHAIN_MASTER_VOICE invocation\n    if (aActor.items.find(i => i.name === CHAIN_MASTER_VOICE)) chainMasterVoice = true\n    //--------------------------------------------------------------------------------------------------\n    // Does the caster have the CHAIN_MASTER_PACT feature, and thus needs special treatment?\n    //\n    let chainMasterPact = false   // Boolean flag indicating caster has CHAIN_MASTER_PACT invocation\n    if (aActor.items.find(i => i.name === CHAIN_MASTER_PACT)) chainMasterPact = true\n    if (chainMasterPact) {\n        jez.badNews(`Features provided by ${CHAIN_MASTER_PACT} are not automated other than save DC`, \"i\")\n        const SPELL_DC = jez.getSpellDC(aActor)\n        if (TL > 1) jez.trace(`${TAG} ${FIRST_NAME_TOKEN} has ${CHAIN_MASTER_PACT}`)\n        // ---------------------------------------------------------------------------------------------\n        // Does the familiar being summoned have weapon/spell item(s) with a flat saving throw?\n        // If so build an array containingthe names of those items.\n        //\n        let saveItems = []\n        let items = summonData.items.contents\n        for (let i = 0; i < items.length; i++) {\n            if (items[i].data.type === \"weapon\" || items[i].data.type === \"spell\") {\n                if (items[i].data.data.save.dc && items[i].data.data.save.scaling === \"flat\") {\n                    if (TL > 2) jez.trace(`${TAG} TODO: Item ${items[i].name} needs to have its flat save value adjusted`)\n                    saveItems.push(items[i].name)\n                }\n            }\n        }\n        // ---------------------------------------------------------------------------------------------       \n        // If one or more items contain flat saving throws, craft a custom update data structure\n        //\n        if (saveItems.length > 0) {\n            if (TL > 1) jez.trace(`${TAG} Building a custom update object for save items`,saveItems)\n            argObj.updates = {\n                actor: { name: famName },\n                token: { name: famName },\n                embedded: { Item: {} } // Need an empty entry here to hold one or more additions\n            }\n            // -----------------------------------------------------------------------------------------       \n            for (let i = 0; i < saveItems.length; i++) {\n                if (TL > 1) jez.trace(`${TAG} Add data to adjust save for Item: \"${saveItems[i]}\"`)\n                argObj.updates.embedded.Item[saveItems[i]] = { 'data.save.dc': SPELL_DC }\n            }\n            if (TL > 1) jez.trace(`${TAG} argObj.updates`, argObj.updates)\n        }\n    }\n    else if (TL > 2) jez.trace(`${TAG} ${FIRST_NAME_TOKEN} lacks ${CHAIN_MASTER_PACT}`)\n    //--------------------------------------------------------------------------------------------------\n    // Do the actual summon\n    //\n    let tokenId = await jez.spawnAt(itemSelected, aToken, aActor, aItem, argObj)\n    if (TL > 1) jez.trace(`${TAG} Token ID of summoned familiar`, tokenId)\n    //--------------------------------------------------------------------------------------------------\n    // Add watchdog effect to the summoning token \n    //\n    addWatchdogEffect(tokenId, famName)\n    //-------------------------------------------------------------------------------------------------\n    // Add the Swap Senses 'spell' to spell book\n    // \n    if (copyEditItem(aToken, famName, NEW_SPELL)) {\n        msg = `An At-Will Spell \"${NEW_SPELL}\" has been added to ${aToken.name}`\n        jez.badNews(msg, \"i\");\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Add some additional items to the familiar if they are not already present\n    //\n    let fToken = canvas.tokens.placeables.find(ef => ef.id === tokenId[0]) // fToken: Familiar Token\n    if (TL > 1) jez.trace(`${TAG} Familiar Token data`, fToken)\n    await copyItem(fToken, \"feat\", \"Help\", { traceLvl: TL })\n    await copyItem(fToken, \"feat\", \"Hinder\", { traceLvl: TL })\n    await copyItem(fToken, \"feat\", \"Familiar\", { traceLvl: TL })\n    if (chainMasterPact)\n        await copyItem(fToken, \"feat\", \"Familiar - Pact of the Chain Master\", { traceLvl: TL })\n    if (chainMasterPact)\n        await copyItem(fToken, \"feat\", \"Familiar - Voice of the Chain Master\", { traceLvl: TL })\n    //-----------------------------------------------------------------------------------------------\n    // Post message about the summons\n    //\n    msg = `<b>${aToken.name}</b> has summoned ${famName} as thier familiar.`\n    postResults(msg)\n    return\n}\n/***************************************************************************************************\n * Add an effect to the using actor that can perform additional actions on the summoned actor.\n * \n * Expected input is a single token id and the name of teh familiar\n ***************************************************************************************************/\nasync function addWatchdogEffect(tokenId, famName) {\n    const FUNCNAME = \"addWatchdogEffect(tokenId)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const DEL_TOKEN_MACRO = \"ActorUpdate\";\n\n    if (TL === 1) jez.trace(`${TAG} Starting --- `);\n    if (TL > 1) jez.trace(`${TAG} Starting ---`, \"tokenId\", tokenId, \"famName\", famName);\n    //------------------------------------------------------------------------------------------------\n    // Make sure DEL_TOKEN_MACRO exists and is GM execute enabled\n    //\n    const delTokenMacro = game.macros.getName(DEL_TOKEN_MACRO);\n    if (!delTokenMacro)\n        return jez.badNews(`Cannot locate ${DEL_TOKEN_MACRO} GM Macro, skipping watchdog`);\n    if (!delTokenMacro.data.flags[\"advanced-macros\"].runAsGM)\n        return jez.badNews(`${DEL_TOKEN_MACRO} \"Execute as GM\" not checked, skipping watchdog`);\n    //------------------------------------------------------------------------------------------------\n    // Proceed with adding watchdog\n    //\n    const CE_DESC = `Familiar, ${famName}, is active`\n    let effectData = {\n        label: SPELL_NAME,\n        icon: aItem.img,\n        origin: LAST_ARG.uuid,\n        disabled: false,\n        flags: {\n            dae: { macroRepeat: \"none\" },\n            convenientDescription: CE_DESC\n        },\n        changes: [\n            { key: `macro.execute`, mode: jez.ADD, value: `DeleteTokenMacro ${tokenId}`, priority: 20 },\n            { key: `macro.itemMacro`, mode: jez.CUSTOM, value: `0`, priority: 20 },\n        ]\n    };\n    if (TL > 1) jez.trace(`${FNAME} | effectData`, effectData);\n    if (TL > 3) jez.trace(`${FNAME} | MidiQOL.socket().executeAsGM(\"createEffects\"`, \"aToken.actor.uuid\",\n        aToken.actor.uuid, \"effectData\", effectData);\n    await MidiQOL.socket().executeAsGM(\"createEffects\",\n        { actorUuid: aToken.actor.uuid, effects: [effectData] });\n    if (TL > 0) jez.trace(`---  Finished --- ${MACRO} ${FNAME} ---`);\n}\n/***************************************************************************************************\n* Copy the temporary item to actor's spell book and edit it as appropriate\n***************************************************************************************************/\nasync function copyEditItem(token5e, familiarName, NEW_SPELL) {\n    const FUNCNAME = \"copyEditItem(token5e)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n\n    if (TL === 1) jez.trace(`${TAG} Starting --- `);\n    if (TL > 1) jez.trace(`${TAG} Starting ---`, \"token5e\", token5e, \"familiarName\", familiarName,\n        \"NEW_SPELL\", NEW_SPELL);\n    //----------------------------------------------------------------------------------------------\n    let oldActorItem = token5e.actor.data.items.getName(NEW_SPELL)\n    if (oldActorItem) await deleteItem(token5e.actor, oldActorItem)\n    //----------------------------------------------------------------------------------------------\n    if (TL > 1) jez.trace(`${TAG} Get the item from the Items directory add to ${aToken.name}`)\n    let itemObj = game.items.getName(TEMPLATE_SPELL)\n    if (!itemObj) {\n        msg = `Failed to find ${TEMPLATE_SPELL} in the Items Directory`\n        ui.notifications.error(msg);\n        postResults(msg)\n        return (false)\n    }\n    console.log('Item5E fetched by Name', itemObj)\n    await replaceItem(token5e.actor, itemObj)\n    //----------------------------------------------------------------------------------------------\n    if (TL > 1) jez.trace(`${TAG} Edit the item on ${aToken.name}'s actor, `)\n    let aActorItem = token5e.actor.data.items.getName(TEMPLATE_SPELL)\n    if (TL > 1) jez.trace(`${TAG} aActorItem`, aActorItem)\n    if (!aActorItem) {\n        msg = `Failed to find ${TEMPLATE_SPELL} on ${token5e.name}`\n        ui.notifications.error(msg);\n        postResults(msg)\n        return (false)\n    }\n    //-----------------------------------------------------------------------------------------------\n    if (TL > 1) jez.trace(`${TAG} Remove the don't change this message assumed to be embedded in the \n        item description.  It should be of the form: <p><strong>%%*%%</strong></p> followed by white \n        space`)\n    const searchString = `<p><strong>%%.*%%</strong></p>[\\s\\n\\r]*`;\n    const regExp = new RegExp(searchString, \"g\");\n    const replaceString = ``;\n    let content = await duplicate(aActorItem.data.data.description.value);\n    content = await content.replace(regExp, replaceString);\n    let itemUpdate = {\n        'name': NEW_SPELL,\n        'data.description.value': content,\n    }\n    if (TL > 1) jez.trace(`${TAG} Updating Item`, itemUpdate)\n    await aActorItem.update(itemUpdate)\n    if (TL > 1) jez.trace(`${TAG} --- Finished`);\n    return (true);\n}\n/*************************************************************************************\n * replaceItem\n * \n * Replace or Add targetItem to inventory of actor5e passed as parms\n *************************************************************************************/\nasync function replaceItem(actor5e, targetItem) {\n    await deleteItem(actor5e, targetItem)\n    return (actor5e.createEmbeddedDocuments(\"Item\", [targetItem.data]))\n}\n/*************************************************************************************\n * deleteItem\n * \n * Delete targetItem to inventory of actor5e passed as parms\n *************************************************************************************/\nasync function deleteItem(actor5e, targetItem) {\n    let itemFound = actor5e.items.find(item => item.data.name === targetItem.data.name && item.type === targetItem.type)\n    if (itemFound) await itemFound.delete();\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Delete any existing temp abilities for this spell\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function doOff() {\n    const FUNCNAME = \"doOff()\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL > 0) jez.trace(`${TAG} --- Starting ---`);\n    //-----------------------------------------------------------------------------------------------\n    // If a temp ability to swap senses for a familiar exists, delete it\n    //\n    deleteTempSpells({ traceLvl: TL })\n    if (TL > 3) jez.trace(`${TAG} | More Detailed Trace Info.`)\n\n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n    return;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Delete existing temporary spell items, if any.  They must be at-will spells that start with \n * NEW_SPELL_PREFIX\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function deleteTempSpells(options = {}) {\n    const FUNCNAME = \"deleteTempSpell(options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //-----------------------------------------------------------------------------------------------\n    // Delete all of the at-will spells that start with NEW_SPELL_PREFIX\n    //\n    const NEW_SPELL_PREFIX = \"Swap Senses with\"\n    let itemFound = null\n    while (itemFound = aActor.items.find(item => item.data.name.startsWith(NEW_SPELL_PREFIX) &&\n        item.type === \"spell\" && item.data.data.preparation.mode === \"atwill\")) {\n        await itemFound.delete();\n        jez.badNews(`At-Will Spell \"${itemFound.name}\" has been deleted from ${aToken.name}'s spell book`, 'i')\n        await jez.wait(50)\n    }\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Copy a feature (e.g. Help Action) from the item directory to the specified actor's sheet.  Check\n * for various error conditions. \n * \n * This is similar to copyEditItem(token5e, familiarName, NEW_SPELL) with less editing\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\n async function copyItem(token5e, TYPE, NAME, options = {}) {\n    const FUNCNAME = \"copyItem(token5e, TYPE, NAME, options = {}))\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"token5e\",token5e, \"TYPE\", TYPE, \n    \"NAME\", NAME, \"options\", options);\n    //-----------------------------------------------------------------------------------------------\n    // Does the target token's actor currently have an item called NAME of type TYPE?  If so, return\n    //\n    if (token5e.actor.items.find(i => i.name === NAME && i.type === TYPE)) {\n        if (TL > 1) jez.trace(`${TAG} ${TYPE} named \"${NAME}\" already exists on ${token5e.name}`)\n        return\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Does an item called NAME of type TYPE exist in the item directory?  If not complain & return\n    // If it does, keep the data around for subsequent usage.\n    //\n    const ITEM_DATA = game.items.find(i => i.data.name === NAME && i.type === TYPE)\n    if (TL > 1) jez.trace(`${TAG} Retreived from item directory`,ITEM_DATA)\n    if (!ITEM_DATA) return jez.badNews(`Could not find ${TYPE} named \"${NAME}\"`,\"w\")\n    //-----------------------------------------------------------------------------------------------\n    // Copy the item to our token5e's actor\n    //\n    await replaceItem(token5e.actor, ITEM_DATA)\n    //-----------------------------------------------------------------------------------------------\n    // Chill for a moment and return\n    //\n    await jez.wait(50)\n     if (TL > 1) jez.trace(`${TAG} --- Finished`);\n     return (true);\n }",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "midi-qol": {
      "onUseMacroName": "[postActiveEffects]ItemMacro",
      "effectActivation": false
    },
    "betterCurses": {
      "isCurse": false,
      "curseName": "",
      "formula": "",
      "mwak": false,
      "rwak": false,
      "msak": false,
      "rsak": false
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "exportSource": {
      "world": "travels-in-barovia-ce",
      "system": "dnd5e",
      "coreVersion": "9.269",
      "systemVersion": "1.6.2"
    }
  }
}