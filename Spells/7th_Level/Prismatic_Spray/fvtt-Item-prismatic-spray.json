{
  "name": "Prismatic Spray",
  "type": "spell",
  "img": "icons/magic/light/projectile-beams-salvo-yellow.webp",
  "data": {
    "description": {
      "value": "<p>Eight multicolored rays of light flash from your hand. Each ray is a different color and has a different power and purpose. Each creature in a 60-foot cone must make a Dexterity saving throw. For each target, roll a d8 to determine which color ray affects it.</p>\n<ol>\n<li><strong>Red</strong>. The target takes 10d6 fire damage on a failed save, or half as much damage on a successful one.</li>\n<li><strong>Orange</strong>. The target takes 10d6 acid damage on a failed save, or half as much damage on a successful one.</li>\n<li><strong>Yellow</strong>. The target takes 10d6 lightning damage on a failed save, or half as much damage on a successful one.</li>\n<li><strong>Green</strong>. The target takes 10d6 poison damage on a failed save, or half as much damage on a successful one.</li>\n<li><strong>Blue</strong>. The target takes 10d6 cold damage on a failed save, or half as much damage on a successful one.</li>\n<li><strong>Indigo</strong>. On a failed save, the target is Restrained. It must then make a Constitution saving throw at the end of each of its turns. If it successfully saves three times, the spell ends. If it fails its save three times, it permanently turns to stone and is subjected to the Petrified condition. The successes and failures don&rsquo;t need to be consecutive; keep track of both until the target collects three of a kind.</li>\n<li><strong>Violet</strong>. On a failed save, the target is Blinded. It must then make a Wisdom saving throw at the start of your next turn. A successful save ends the blindness. If it fails that save, the creature is transported to another plane of existence of the DM&rsquo;s choosing and is no longer Blinded. (Typically, a creature that is on a plane that isn&rsquo;t its home plane is banished home, while other creatures are usually cast into the Astral or Ethereal planes.)</li>\n<li><strong>Special</strong>. The target is struck by two rays. Roll twice more, rerolling any 8.</li>\n</ol>\n<hr />\n<p><strong>FoundryVTT:&nbsp;</strong>Very much automated.</p>",
      "chat": "",
      "unidentified": ""
    },
    "source": "",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": null,
      "units": ""
    },
    "target": {
      "value": 60,
      "width": null,
      "units": "ft",
      "type": "cone"
    },
    "range": {
      "value": null,
      "long": null,
      "units": ""
    },
    "uses": {
      "value": null,
      "max": "",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "save",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": ""
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "dex",
      "dc": null,
      "scaling": "spell"
    },
    "level": 7,
    "school": "evo",
    "components": {
      "value": "",
      "vocal": true,
      "somatic": true,
      "material": false,
      "ritual": false,
      "concentration": false
    },
    "materials": {
      "value": "",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "prepared",
      "prepared": true
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    },
    "attunement": null
  },
  "effects": [],
  "flags": {
    "midi-qol": {
      "effectActivation": false,
      "onUseMacroName": "[postActiveEffects]ItemMacro"
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Prismatic Spray",
          "type": "script",
          "author": "ZjFlOWYxZjM5ZTZj",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const MACRONAME = \"Prismatic_Spray.0.2.js\"\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * This macro implements Prismatic Spray.\n *\n *   Eight multicolored rays of light flash from your hand. Each ray is a different color and has a\n *   different power and purpose. Each creature in a 60-foot cone must make a Dexterity saving throw.\n *   For each target, roll a d8 to determine which color ray affects it.\n *   1. Red. The target takes 10d6 fire damage on a failed save, or half as much damage on success.\n *   2. Orange. The target takes 10d6 acid damage on a failed save, or half as much damage on success.\n *   3. Yellow. The target takes 10d6 lightning damage on a failed save, or half as much damage on a\n *      successful one.\n *   4. Green. The target takes 10d6 poison damage on a failed save, or half as much damage on a\n *      successful one.\n *   5. Blue. The target takes 10d6 cold damage on a failed save, or half as much damage on a\n *      successful one.\n *   6. Indigo. On a failed save, the target is Restrained. It must then make a Constitution saving\n *      throw at the end of each of its turns. If it successfully saves three times, the spell ends.\n *      If it fails its save three times, it permanently turns to stone and is subjected to the\n *      Petrified condition. The successes and failures don't need to be consecutive; keep track of\n *      both until the target collects three of a kind.\n *   7. Violet. On a failed save, the target is Blinded. It must then make a Wisdom saving throw at\n *      the start of your next turn. A successful save ends the blindness. If it fails that save,\n *      the creature is transported to another plane of existence of the DM's choosing and is no\n *      longer Blinded. (Typically, a creature that is on a plane that isn't its home plane is\n *      banished home, while other creatures are usually cast into the Astral or Ethereal planes.)\n *   8. Special. The target is struck by two rays. Roll twice more, rerolling any 8.\n *\n * 11/24/22 0.1 Creation of Macro from Gauth_Eye_Rays.0.2.js\n * 11/29/22 0.2 Add tracking of savng throws vs beam 6 & 7\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nconst MACRO = MACRONAME.split(\".\")[0]       // Trim off the version number and extension\nconst TAG = `${MACRO} |`\nconst TL = 0;                               // Trace Level for this macro\nlet msg = \"\";                               // Global message string\n//---------------------------------------------------------------------------------------------------\nif (TL > 1) jez.trace(`${TAG} === Starting ===`);\nif (TL > 2) for (let i = 0; i < args.length; i++) jez.trace(`  args[${i}]`, args[i]);\nconst LAST_ARG = args[args.length - 1]; // See https://gitlab.com/tposney/dae#lastarg for contents\n//---------------------------------------------------------------------------------------------------\n// Set the value for the Active Token (aToken)\nlet aToken;\nif (LAST_ARG.tokenId) aToken = canvas.tokens.get(LAST_ARG.tokenId);\nelse aToken = game.actors.get(LAST_ARG.tokenId);\nlet aActor = aToken.actor;\n//\n// Set the value for the Active Item (aItem)\nlet aItem;\nif (args[0]?.item) aItem = args[0]?.item;\nelse aItem = LAST_ARG.efData?.flags?.dae?.itemData;\n//---------------------------------------------------------------------------------------------------\n// Set Macro specific globals\n//\nconst BEAM_CNT = 8     // Number of beams defined\nlet rayArray = []\nconst DELAY = 1500  // Time between ray attacks\nconst SAVE_DC = aActor.data.data.attributes.spelldc;\nconst GAME_RND = game.combat ? game.combat.round : 0;\nconst DICE_DELAY = 400\nconst BEAM_NAME_ARRAY = [\"Red\", \"Orange\", \"Yellow\", \"Green\", \"Blue\", \"Indigo\", \"Violet\", \"Special\"]\nconst BEAM_TYPE_COUNT = BEAM_NAME_ARRAY.length\nconst VFX_PATH = 'modules/jb2a_patreon/Library/2nd_Level/Scorching_Ray'\nconst VFX_DURATION = 12  // Duration of VFX effects in seconds\nconst BEAM_VFX = [\n    `${VFX_PATH}/ScorchingRay_01_Regular_Red_30ft_1600x400.webm`,\n    `${VFX_PATH}/ScorchingRay_01_Regular_Orange_30ft_1600x400.webm`,\n    `${VFX_PATH}/ScorchingRay_01_Regular_Yellow_30ft_1600x400.webm`,\n    `${VFX_PATH}/ScorchingRay_01_Regular_Green_30ft_1600x400.webm`,\n    `${VFX_PATH}/ScorchingRay_01_Regular_Blue_30ft_1600x400.webm`,\n    `modules/jb2a_patreon/Library/Generic/Energy/EnergyBeam_02_Dark_PurpleRed_30ft_1600x400.webm`,\n    `${VFX_PATH}/ScorchingRay_02_Regular_Blue_30ft_02_1600x400.webm`\n]\nconst JRNL_BLINDED = `@JournalEntry[${game.journal.getName(\"Blinded\").id}]{Blinded}`\nconst JRNL_RESTRAINED = `@JournalEntry[${game.journal.getName(\"Restrained\").id}]{Restrained}`\nconst JRNL_PETRIFIED = `@JournalEntry[${game.journal.getName(\"Restrained\").id}]{Restrained}`\n//---------------------------------------------------------------------------------------------------\n// Run the main procedures, choosing based on how the macro was invoked\n//\nif (args[0]?.tag === \"OnUse\") await doOnUse({ traceLvl: TL });          // Midi ItemMacro On Use\nif (args[0] === \"off\") await doOff({traceLvl:5});                   // DAE removal\nif (TL > 1) jez.trace(`=== Finished === ${MACRONAME} ===`);\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ****************************************************************************************************\n * Post results to the chat card\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function postResults(msg) {\n    const FUNCNAME = \"postResults(msg)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL > 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 2) jez.trace(\"postResults Parameters\", \"msg\", msg)\n    //-----------------------------------------------------------------------------------------------\n    let chatMsg = game.messages.get(args[args.length - 1].itemCardId);\n    await jez.addMessage(chatMsg, { color: jez.randomDarkColor(), fSize: 14, msg: msg, tag: \"saves\" });\n    if (TL > 1) jez.trace(`${TAG}--- Finished ---`);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Post a new chat message\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function postBeamResult(beam, msg) {\n   const FUNCNAME = \"postResults(msg)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL > 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 2) jez.trace(`${TAG} Parameters`, \"beam\", beam, \"msg\", msg)\n    //-----------------------------------------------------------------------------------------------\n    // map beam colors to HTML color\n    //\n    let textColor = \"\"\n    switch(beam) {\n        case \"Red\":\n        case \"Orange\":\n        case \"Green\":\n        case \"Blue\":\n        case \"Violet\": textColor = `Dark${beam}`; break;\n        case \"Yellow\": textColor = `GoldenRod`; break;\n        case \"Indigo\": textColor = beam; break;\n        default: textColor = jez.randomDarkColor();\n      }\n    //-----------------------------------------------------------------------------------------------\n    //\n    jez.postMessage({\n        color: textColor, fSize: 14, icon: aItem.img, msg: msg,\n        title: `${aItem.name}: ${beam} Beam`, token: aToken })\n    if (TL > 1) jez.trace(`${TAG}--- Finished ---`);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Perform the code that runs when this macro is invoked as an ItemMacro \"OnUse\"\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function doOnUse(options = {}) {\n    const FUNCNAME = \"doOnUse()\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //----------------------------------------------------------------------------------\n    // Define values for this function\n    //\n    const TEMPLATE_ID = args[0].templateId\n    //----------------------------------------------------------------------------------\n    // Delete the targeting template\n    //\n    canvas.templates.get(TEMPLATE_ID).document.delete()\n    //-----------------------------------------------------------------------------------------------\n    // Set some handy constant arrays and verufy at least one token targeted\n    //\n    const FSD = args[0].failedSaves\n    const FSU = args[0].failedSaveUuids\n    const MSD = args[0].saves\n    const MSU = args[0].saveUuids\n    if (TL > 2) jez.trace(`${TAG} Those who failed saves`,\n        `Made Save UUID Array       ==>`, MSU,\n        `Made Save Document Array   ==>`, MSD,\n        `Failed Save UUID Array     ==>`, FSU,\n        `Failed Save Document Array ==>`, FSD)\n    if (FSU.length + MSU.length === 0) {\n        postResults(`No targets in area of effect.  No effects.`)\n        return\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Step through failured saves, firing at each\n    //\n    for (let i = 0; i < FSD.length; i++) {\n        if (FSD[i]._object.id === aToken.id) continue;  // Skip self, if accidentally targeted\n        if (TL > 2) jez.trace(`${TAG} ${FSD[i]._object.name} Failed save.`, FSD[i]._object)\n        let beamRollObj = new Roll(`1d8`).evaluate({ async: false });\n        game.dice3d?.showForRoll(beamRollObj);\n        await fireBeam(aToken, FSD[i]._object, beamRollObj.total, { saved: false, traceLvl: TL })\n        await jez.wait(DICE_DELAY) // Let the dice clear\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Step through successful saves, firing at each\n    //\n    for (let i = 0; i < MSD.length; i++) {\n        if (MSD[i]._object.id === aToken.id) continue;  // Skip self, if accidentally targeted\n        if (TL > 2) jez.trace(`${TAG} ${MSD[i]._object.name} Failed save.`, MSD[i]._object)\n        let beamRollObj = new Roll(`1d8`).evaluate({ async: false });\n        game.dice3d?.showForRoll(beamRollObj);\n        await fireBeam(aToken, MSD[i]._object, beamRollObj.total, { saved: true, traceLvl: TL })\n        await jez.wait(DICE_DELAY) // Let the dice clear\n    }\n    return\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Pick a Beam and fire it at target\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function fireBeam(aToken, tToken, beamIdx, options = {}) {\n    const FUNCNAME = \"fireBeam(aToken, tToken, beamIdx, options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL > 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 2) jez.trace(`${TAG} Parameters`, \"aToken \", aToken, \"tToken \", tToken,\n        \"beamIdx\", beamIdx, \"options\", options)\n    await jez.wait(DICE_DELAY)\n    //-----------------------------------------------------------------------------------------------\n    // Set Function Variables\n    //\n    const SAVED = options.saved ?? false\n    // const FIRST = options.saved ?? true\n    //-----------------------------------------------------------------------------------------------\n    // If beam 8 was selected, call this function twice, with only beams 1-7 as choices\n    //\n    if (beamIdx === 8) {\n        if (TL > 1) jez.trace(`${TAG} Rolling two beams to handle Special (8) on first pass`);\n        let newBeamIdx = Math.floor(Math.random() * 8) + 1; // Random 1 to 7\n        fireBeam(aToken, tToken, newBeamIdx, { saved: SAVED, traceLvl: TL })\n        newBeamIdx = Math.floor(Math.random() * 8) + 1; // Random 1 to 7\n        await jez.wait(DICE_DELAY) // Let the saving throw dice clear\n        fireBeam(aToken, tToken, newBeamIdx, { saved: SAVED, traceLvl: TL })\n        return\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Initiate the VFX at our poor sap\n    //\n    runVFX(aToken, tToken, BEAM_VFX[beamIdx - 1], { traceLvl: TL })\n    //-----------------------------------------------------------------------------------------------\n    // Perform actual beam effects\n    //\n    let tl = TL\n    switch (beamIdx) {\n        case 1: // Red. The target takes 10d6 fire damage\n            await zapTarget(aToken, tToken, SAVED, \"fire\", beamIdx, { traceLvl: tl })\n            break;\n        case 2: // Orange. The target takes 10d6 acid damage\n            await zapTarget(aToken, tToken, SAVED, \"acid\", beamIdx, { traceLvl: tl })\n            break;\n        case 3: // Yellow. The target takes 10d6 lightning damage\n            await zapTarget(aToken, tToken, SAVED, \"lightning\", beamIdx, { traceLvl: tl })\n            break;\n        case 4: // Green. The target takes 10d6 poison damage\n            await zapTarget(aToken, tToken, SAVED, \"poison\", beamIdx, { traceLvl: tl })\n            break;\n        case 5: // Blue. The target takes 10d6 cold damage\n            await zapTarget(aToken, tToken, SAVED, \"cold\", beamIdx, { traceLvl: tl })\n            break;\n        case 6: // Indigo. On a failed save, the target is restrained...\n            await zapTargetIndigo(aToken, tToken, SAVED, { traceLvl: tl })\n            break;\n        case 7: // Violet. On a failed save, the target is blinded...\n            await zapTargetViolet(aToken, tToken, SAVED, { traceLvl: tl })\n            break;\n        default:\n            return jez.badNews(`${TAG} Illegal beam index, shouldn't happen...`)\n    }\n\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n *\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function zapTarget(ACTIVE_TOKEN, TARGET_TOKEN, SAVED, DAMAGE_TYPE, BEAM_IDX, options = {}) {\n    const FUNCNAME = \"zapTarget(tToken, SAVED, DAMAGE_TYPE, options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `jez.lib ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    const DAMAGE_ROLL = \"10d6\"\n    let description = \"\"\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Start ${FNAME}`,\n        \"ACTIVE_TOKEN\", ACTIVE_TOKEN,\n        \"TARGET_TOKEN\", TARGET_TOKEN,\n        \"SAVED       \", SAVED,\n        \"DAMAGE_TYPE \", DAMAGE_TYPE,\n        \"BEAM_IDX    \", BEAM_IDX,\n        \"options     \", options);\n    //-----------------------------------------------------------------------------------------------\n    if (TL > 1) jez.trace(`${TAG} Apply ${DAMAGE_ROLL} ${DAMAGE_TYPE} damage to ${TARGET_TOKEN.name}`);\n    let damageRoll = new Roll(`${DAMAGE_ROLL}`).evaluate({ async: false });\n    if (TL > 2) jez.trace(`${TAG} Damage Rolled ${damageRoll.total}`, damageRoll)\n    // game.dice3d?.showForRoll(damageRoll);\n    // Apply full damage to target, if it failed its save, otherwise half\n    if (!SAVED) {\n        new MidiQOL.DamageOnlyWorkflow(ACTIVE_TOKEN.actor, TARGET_TOKEN, damageRoll, DAMAGE_TYPE, [], damageRoll,\n            { flavor: \"Prismatic Spray\", itemCardId: args[0].itemCardId });\n        MidiQOL.applyTokenDamage([{ damage: damageRoll.total, type: DAMAGE_TYPE }], damageRoll.total,\n            new Set([TARGET_TOKEN]), aItem, new Set());\n        description = `It took ${damageRoll.total} ${DAMAGE_TYPE} damage.`\n    }\n    else {\n        let halfdam = Math.floor(damageRoll.total / 2)\n        new MidiQOL.DamageOnlyWorkflow(ACTIVE_TOKEN.actor, TARGET_TOKEN, damageRoll, DAMAGE_TYPE, [], damageRoll,\n            { flavor: \"Prismatic Spray\", itemCardId: args[0].itemCardId });\n        MidiQOL.applyTokenDamage([{ damage: halfdam, type: DAMAGE_TYPE }], halfdam,\n            new Set([TARGET_TOKEN]), aItem, new Set());\n        description = `It took ${halfdam} ${DAMAGE_TYPE} damage.`\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Add an appropriate message\n    //\n    if (SAVED) msg = `<b>${TARGET_TOKEN.name}</b> saved versus <b>${BEAM_NAME_ARRAY[BEAM_IDX-1]}</b>\n        beam. ${description}`\n    else msg = `<b>${TARGET_TOKEN.name}</b> failed to save versus <b>${BEAM_NAME_ARRAY[BEAM_IDX-1]}\n        </b>beam. ${description}.`\n    if (TL > 1) jez.trace(`${TAG} Add Message`, msg)\n    await postBeamResult(BEAM_NAME_ARRAY[BEAM_IDX-1], msg)\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n *\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\n async function zapTargetIndigo(ACTIVE_TOKEN, TARGET_TOKEN, SAVED, options = {}) {\n    const FUNCNAME = \"zapTargetIndigo(ACTIVE_TOKEN, TARGET_TOKEN, SAVED, options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `jez.lib ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Start ${FNAME}`,\n        \"ACTIVE_TOKEN\", ACTIVE_TOKEN,\n        \"TARGET_TOKEN\", TARGET_TOKEN,\n        \"SAVED       \", SAVED,\n        \"options     \", options);\n    //-----------------------------------------------------------------------------------------------\n    // Actually do something, to tokens that failed.\n    //\n    if (!SAVED) {\n        const LABEL = `Indigo Beam from ${aToken.id} ${GAME_RND}`\n        // let overTimeValue = `turn=end,label=Indigo Paralysis,saveDC=${SAVE_DC},saveAbility=con,macro=Prismatic_Spray_Helper`\n        let overTimeValue = `turn=end,label=${LABEL},saveDC=${SAVE_DC},saveAbility=con,saveRemove=false,macro=Prismatic_Spray_Helper`\n        let effectData = {\n            label: LABEL,\n            icon: aItem.img,\n            origin: LAST_ARG.uuid,\n            disabled: false,\n            duration: { rounds: 6, startRound: GAME_RND },\n            flags: {\n                isConvenient: true,\n                isCustomConvenient: true,\n                convenientDescription: `Make DC${SAVE_DC} CON Save 3 times, before 3 failures (once end of each turn) or be Petrified`\n            },\n            changes: [\n                { key: `macro.CE`, mode: jez.ADD, value: \"Paralyzed\", priority: 20 },\n                { key: `flags.midi-qol.OverTime`, mode: jez.OVERRIDE, value: overTimeValue, priority: 20 },\n                { key: \"macro.itemMacro\", mode: jez.CUSTOM, value: LABEL, priority: 20 }\n            ]\n        };\n        await jez.wait(DICE_DELAY)\n        await MidiQOL.socket().executeAsGM(\"createEffects\",{actorUuid:TARGET_TOKEN.actor.uuid, effects: [effectData] });\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Post an appropriate message\n    //\n    if (SAVED) msg = `<b>${TARGET_TOKEN.name}</b> saved versus <b>Indigo</b> beam.`\n    else msg = `<b>${TARGET_TOKEN.name}</b> failed to save versus <b>Indigo</b> beam. \n    ${TARGET_TOKEN.name} is now ${JRNL_RESTRAINED} and will need to make a DC${SAVE_DC} CON save at \n    the end of each of its turns, needing 3 successes before 3 failures or become ${JRNL_PETRIFIED}.`\n    if (TL > 1) jez.trace(`${TAG} Post Message`, msg)\n    await postBeamResult(\"Indigo\", msg)\n }\n /*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * const  = `@JournalEntry[${game.journal.getName(\"Blinded\").id}]{Blinded}`\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\n  async function zapTargetViolet(ACTIVE_TOKEN, TARGET_TOKEN, SAVED, options = {}) {\n    const FUNCNAME = \"zapTargetViolet(ACTIVE_TOKEN, TARGET_TOKEN, SAVED, options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `jez.lib ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Start ${FNAME}`,\n        \"ACTIVE_TOKEN\", ACTIVE_TOKEN,\n        \"TARGET_TOKEN\", TARGET_TOKEN,\n        \"SAVED       \", SAVED,\n        \"options     \", options);\n    //-----------------------------------------------------------------------------------------------\n    // Actually do something, to tokens that failed.\n    //\n    if (!SAVED) {\n        const LABEL = `Violet Beam from ${aToken.id} ${GAME_RND}`\n        // let overTimeValue = `turn=end,label=Violet Blinded,saveDC=${SAVE_DC},saveAbility=wis,macro=Prismatic_Spray_Helper` \n        let overTimeValue = `turn=end,label=${LABEL},saveDC=${SAVE_DC},saveAbility=wis,saveRemove=false,macro=Prismatic_Spray_Helper` \n        let effectData = {\n            // label: `Affected by Violet Beam`,\n            label: LABEL,\n            icon: aItem.img,\n            origin: LAST_ARG.uuid,\n            disabled: false,\n            duration: { rounds: 6, startRound: GAME_RND },\n            flags: {\n                isConvenient: true,\n                isCustomConvenient: true,\n                convenientDescription: `Make DC${SAVE_DC} WIS Save 3 times, before 3 failures (once end of each turn) or be Banished`\n            },\n            changes: [\n                { key: `macro.CE`, mode: jez.ADD, value: \"Blinded\", priority: 20 },\n                { key: `flags.midi-qol.OverTime`, mode: jez.OVERRIDE, value: overTimeValue, priority: 20 },\n                { key: \"macro.itemMacro\", mode: jez.CUSTOM, value: LABEL, priority: 20 }\n            ]\n        };\n        await jez.wait(DICE_DELAY)\n        await MidiQOL.socket().executeAsGM(\"createEffects\",{actorUuid:TARGET_TOKEN.actor.uuid, effects: [effectData] });\n\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Post an appropriate message\n    //\n    if (SAVED) msg = `<b>${TARGET_TOKEN.name}</b> saved versus <b>Violet</b> beam.`\n    else msg = `<b>${TARGET_TOKEN.name}</b> failed to save versus <b>Violet</b> beam.\n    ${TARGET_TOKEN.name} is now ${JRNL_BLINDED} and will need to make a DC${SAVE_DC} CON save at \n    the end of each of its turns, needing 3 successes before 3 failures or be transported to another \n    plane of existence of the GM's choosing, no longer blinded.`\n    if (TL > 1) jez.trace(`${TAG} Post Message`, msg)\n    await postBeamResult(\"Violet\", msg)\n }\n\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Run VFX from the aToken to the provded tToken, using the provided color.\n *\n * Cool-Thing: Uses template to adjust the animation to better attach to tokens. Also uses\n *             .playbackRate to slow down the animation.\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function runVFX(aToken, tToken, VFX_FILENAME, options = {}) {\n    const FUNCNAME = \"runVFX(tToken, VFX_FILENAME, options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `jez.lib ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Start ${FNAME}`, \"aToken\", aToken, \"tToken\", tToken,\n        \"VFX_FILENAME\", VFX_FILENAME, \"options\", options);\n    //-----------------------------------------------------------------------------------------------\n    // Set playback rate based on VFX provided's duration\n    //\n    const TEXTURE = await loadTexture(VFX_FILENAME);\n    const DURATION = TEXTURE.baseTexture.resource.source.duration;\n    if (TL > 2) jez.trace(`${DURATION} second duration for ${VFX_FILENAME}`)\n    const PLAY_BACK_RATE = DURATION / VFX_DURATION // Find rate needed for desired VFX_DURATION\n    if (TL > 1) jez.trace(`${TAG} DURATION ${DURATION} / VFX_DURATION ${VFX_DURATION} = \n        PLAY_BACK_RATE ${PLAY_BACK_RATE}`)\n    //-----------------------------------------------------------------------------------------------\n    // Launch the VFX\n    new Sequence()\n        .effect()\n        .file(VFX_FILENAME)\n        .template({ startPoint: 100, endPoint: 100 }) // Adjusts the start/end points just a bit\n        .playbackRate(PLAY_BACK_RATE)\n        .atLocation(aToken)\n        .stretchTo(tToken)\n        .play()\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Clean up the flag used to store information for beam indigo (6) & violet (7)\n * \n * Args should contain data like:\n *   args[0] : off                  // Has to be \"off\" for this function to be called\n *   args[1] : Violet               // Color of beam, either Indigo or Violet\n *   args[2] : Beam                 // Always the word \"Beam\"\n *   args[3] : from                 // Always the word \"from\"\n *   args[4] : TCma6bPCS0YnA6Kc     // Token ID of origin actor's token\n *   args[5] : 16                   // Gane Round spell effect started\n *   args[6] : {diff: true, render: true, action: 'delete', embedded: {...}}, combat-utility-belt: {...},...}\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/ \n async function doOff(options={}) {\n    const FUNCNAME = \"doOff(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0] \n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL===1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL>1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`,\"options\",options);\n    //-----------------------------------------------------------------------------------------------\n    // Build the name of flag\n    //\n    const FLAG_NAME = `${args[1]}.${args[4]}.${args[5]}` // Indigo.TCma6bPCS0YnA6Kc.9\n    if (TL>2) jez.trace(`${TAG} | FLAG_NAME`, FLAG_NAME)\n    //-----------------------------------------------------------------------------------------------\n    // Attempt to unset the flag\n    //\n    if (TL>2) jez.trace(`${TAG} | aActor`, aActor)\n    await DAE.unsetFlag(aActor, FLAG_NAME)\n    //-----------------------------------------------------------------------------------------------\n    // \n    //\n    if (TL>1) jez.trace(`${TAG} --- Finished ---`);\n    return;\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "core": {
      "sourceId": "Item.Rmgs0dNHBEWEuYh6"
    },
    "exportSource": {
      "world": "travels-in-barovia-ce",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.2"
    }
  }
}