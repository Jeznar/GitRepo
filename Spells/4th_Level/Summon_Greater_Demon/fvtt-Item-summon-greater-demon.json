{
  "name": "Summon Greater Demon",
  "type": "spell",
  "img": "systems/dnd5e/icons/spells/horror-acid-3.jpg",
  "data": {
    "description": {
      "value": "<p class=\"Core-Styles_Core-Body\">You utter foul words, summoning one demon from the chaos of the Abyss. You choose the demon’s type, which must be one of challenge rating 5 or lower, such as a <strong>shadow demon</strong> or a <strong>barlgura</strong>. The demon appears in an unoccupied space you can see within range, and the demon disappears when it drops to 0 hit points or when the spell ends.</p>\n<p class=\"Core-Styles_Core-Body\">See <a href=\"https://www.dndbeyond.com/spells/summon-greater-demon\" target=\"_blank\" rel=\"noopener\">D&amp;D Beyond </a>for more details.</p>\n<p class=\"Core-Styles_Core-Body\"><strong><span class=\"Serif-Character-Style_Inline-Subhead-Serif\">At Higher Levels.</span></strong> When you cast this spell using a spell slot of 5th level or higher, the challenge rating increases by 1 for each slot level above 4th.</p>\n<hr />\n<p class=\"Core-Styles_Core-Body\"><strong>FoundryVTT:</strong> </p>",
      "chat": "<p class=\"Core-Styles_Core-Body\">You utter foul words, summoning one demon from the chaos of the Abyss. You choose the demon’s type, which must be one of challenge rating 5 or lower, such as a shadow demon or a barlgura. The demon appears in an unoccupied space you can see within range, and the demon disappears when it drops to 0 hit points or when the spell ends.</p>\n<p class=\"Core-Styles_Core-Body\">Roll initiative for the demon, which has its own turns. When you summon it and on each of your turns thereafter, you can issue a verbal command to it (requiring no action on your part), telling it what it must do on its next turn. If you issue no command, it spends its turn attacking any creature within reach that has attacked it.</p>\n<p class=\"Core-Styles_Core-Body\">At the end of each of the demon’s turns, it makes a Charisma saving throw. The demon has disadvantage on this saving throw if you say its true name. On a failed save, the demon continues to obey you. On a successful save, your control of the demon ends for the rest of the duration, and the demon spends its turns pursuing and attacking the nearest non-demons to the best of its ability. If you stop concentrating on the spell before it reaches its full duration, an uncontrolled demon doesn’t disappear for 1d6 rounds if it still has hit points.</p>\n<p class=\"Core-Styles_Core-Body\">As part of casting the spell, you can form a circle on the ground with the blood used as a material component. The circle is large enough to encompass your space. While the spell lasts, the summoned demon can’t cross the circle or harm it, and it can’t target anyone within it. Using the material component in this manner consumes it when the spell ends.</p>\n<p class=\"Core-Styles_Core-Body\"><strong><span class=\"Serif-Character-Style_Inline-Subhead-Serif\">At Higher Levels.</span></strong> When you cast this spell using a spell slot of 5th level or higher, the challenge rating increases by 1 for each slot level above 4th.</p>",
      "unidentified": ""
    },
    "source": "Xanathar's Guide to Everything pg 166",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": 1,
      "units": "hour"
    },
    "target": {
      "value": null,
      "width": null,
      "units": "",
      "type": ""
    },
    "range": {
      "value": 60,
      "long": null,
      "units": "ft"
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "other",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": null,
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "level": 4,
    "school": "con",
    "components": {
      "value": "a vial of blood from a humanoid killed within the past 24 hours",
      "vocal": true,
      "somatic": true,
      "material": true,
      "ritual": false,
      "concentration": true
    },
    "materials": {
      "value": "a vial of blood from a humanoid killed within the past 24 hours",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "prepared",
      "prepared": true
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    },
    "attunement": 0
  },
  "effects": [],
  "flags": {
    "ddbimporter": {
      "id": 138252,
      "definitionId": 14603,
      "entityTypeId": 435869154,
      "dndbeyond": {
        "lookup": "generic",
        "lookupName": "generic",
        "level": null,
        "castAtLevel": null
      },
      "sources": [
        {
          "sourceId": 27,
          "pageNumber": 166,
          "sourceType": 1
        }
      ],
      "tags": [
        "Summoning"
      ]
    },
    "betterRolls5e": {
      "quickVersatile": {
        "altValue": true
      },
      "quickCharges": {
        "value": {
          "use": true,
          "resource": true
        },
        "altValue": {
          "use": true,
          "resource": true
        }
      }
    },
    "cf": {
      "id": "temp_5bhigw4ca0a"
    },
    "core": {
      "sourceId": "Compendium.My-Shared-DDB.spells.00kaukuruyyPc2Uy"
    },
    "midi-qol": {
      "effectActivation": false,
      "onUseMacroName": "[postActiveEffects]ItemMacro,[preActiveEffects]Run_RuneVFX_onSelf"
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Summon Greater Demon",
          "type": "script",
          "author": "ZjFlOWYxZjM5ZTZj",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const MACRONAME = \"Summon_Greater_Demon.0.1.js\"\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Automate Summon Greater Demon, based directly on Conjure_Elemental.0.1.js\n * \n * - Build list of available summons, verifying existence of each template creature\n * - Dialog to select creature to summon\n * - Place summoned creature, including making creature \"friendly\" (same disposition as caster)\n * - Mod concentration to flip creature to opposite attitude on concentration break\n * - Place timer effect on summoned demon to delete itself at end of spell duration. Dismiss_Token perhaps?\n * \n * 07/21/22 0.1 Creation of Macro\n * 11/16/22 0.2 Fix dialog text and add summoned demon to the combat tracker\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nconst MACRO = MACRONAME.split(\".\")[0]       // Trim of the version number and extension\nconst TL = 0;                               // Trace Level for this macro\nlet msg = \"\";                               // Global message string\n//---------------------------------------------------------------------------------------------------\nif (TL > 1) jez.trace(`=== Starting === ${MACRONAME} ===`);\nif (TL > 2) for (let i = 0; i < args.length; i++) jez.trace(`  args[${i}]`, args[i]);\nconst LAST_ARG = args[args.length - 1];\n//---------------------------------------------------------------------------------------------------\n// Set the value for the Active Token (aToken)\nlet aToken;\nif (LAST_ARG.tokenId) aToken = canvas.tokens.get(LAST_ARG.tokenId);\nelse aToken = game.actors.get(LAST_ARG.tokenId);\nlet aActor = aToken.actor;\n//\n// Set the value for the Active Item (aItem)\nlet aItem;\nif (args[0]?.item) aItem = args[0]?.item;\nelse aItem = LAST_ARG.efData?.flags?.dae?.itemData;\n//---------------------------------------------------------------------------------------------------\n// Set Macro specific globals\n//\nconst SPELL_LVL = args[0]?.spellLevel || 4\nconst MAX_CR = SPELL_LVL + 1\nif (TL > 2) jez.trace(\"MAX_CR\", MAX_CR)\nlet fractialCRs = [0.5, 0.25, 0.125]\nlet demonList                                               // Summon candidates list array\nlet trueNameObj                                             // Object containing demon:trueName pairs\nconst FLAG_BASE = \"Demon_True_Name\"\nconst VFX_FILE = \"Icons_JGB/Misc/Angry.gif\"\nconst CLOCK_IMG = \"Icons_JGB/Misc/alarm_clock.png\"\n//---------------------------------------------------------------------------------------------------\n// Run the main procedures, choosing based on how the macro was invoked\n//\nif (args[0] === \"off\") await doOff();                   // DAE removal\nif (args[0]?.tag === \"OnUse\") await doOnUse();          // Midi ItemMacro On Use\nif (args[0] === \"each\") doEach();\t\t\t\t\t    // DAE everyround\nif (TL > 1) jez.trace(`=== Starting === ${MACRONAME} ===`);\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ****************************************************************************************************\n * Post results to the chat card\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nfunction postResults(msg) {\n    const FUNCNAME = \"postResults(msg)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n\n    if (TL > 1) jez.trace(`--- Starting --- ${MACRONAME} ${FNAME} ---`);\n    if (TL > 2) jez.trace(\"postResults Parameters\", \"msg\", msg)\n    let chatMsg = game.messages.get(args[args.length - 1].itemCardId);\n    jez.addMessage(chatMsg, { color: jez.randomDarkColor(), fSize: 14, msg: msg, tag: \"saves\" });\n    if (TL > 1) jez.trace(`--- Finished --- ${MACRONAME} ${FNAME} ---`);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Perform the code that runs when this macro is invoked as an ItemMacro \"OnUse\"\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function doOnUse() {\n    const FUNCNAME = \"doOnUse()\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    await jez.wait(100)\n    if (TL === 1) jez.trace(`${TAG} --- Starting --- ${MACRO} ${FNAME} ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${MACRO} ${FUNCNAME} ---`);\n    await jez.wait(100)\n    //----------------------------------------------------------------------------------------------\n    // Items searched for are coded below\n    //\n    demonList = buildDemonList([\"Spiritual Weapon\"])\n    if (TL > 1) jez.trace(`${TAG} demonList`,demonList);\n    const DEMONS = Object.keys(demonList);\n    if (TL > 1) jez.trace(`${TAG} DEMONS`,DEMONS);\n    let demonArray = []\n    //------------------------------------------------------------------------------------------------\n    // Step down in integer CRs looking for matches at each value\n    //\n    for (let i = MAX_CR; i > 0; i--)\n        for (let demon of DEMONS)\n            if (i === demonList[demon].cr)\n                demonArray.push(`${demon}`)\n    //------------------------------------------------------------------------------------------------\n    // Step through fractional CRs looking for matches at each value\n    //\n    for (let i of fractialCRs)\n        for (let demon of DEMONS)\n            if (i === demonList[demon].cr)\n                demonArray.push(`${demon}`)\n    if (TL > 1) jez.trace(`${TAG} demonArray`,demonArray);\n    //------------------------------------------------------------------------------------------------\n    // Build and pop selection dialog\n    //\n    let title = `Select Desired Demon to Summon`\n    msg = `See: </span><a style=\"box-sizing: border-box; user-select: text; font-size: 13px;\" \n    href=\"https://www.dndbeyond.com/spells/summon-greater-demon\" target=\"_blank\" rel=\"noopener\">\n    D&amp;D Beyond Description</a> for spell details.<br><br>\n    Options listed below are all unlinked NPC Demons in the Actor Directory.  Others are available\n    at the GM's discretion.`\n    jez.pickRadioListArray(title, msg, pickDemonCallBack, demonArray);\n    //-----------------------------------------------------------------------------------------------\n    // That's all folks\n    //\n    if (TL > 1) jez.trace(`${TAG} --- Finished --- ${MACRONAME} ${FNAME} ---`);\n    return true;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Call back function called after demon is selected and then proceeds with execution.  \n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function pickDemonCallBack(selection) {\n    const FUNCNAME = \"pickDemonCallBack(selection)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL === 1) jez.trace(`${TAG} --- Starting --- ${MACRO} ${FNAME} ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${MACRO} ${FUNCNAME} ---`, \"selection\", selection);\n    //----------------------------------------------------------------------------------------------\n    if (!selection) return false;\n    const SEL_DEMON = selection.split(\" \")[0]\n    if (TL > 2) jez.trace(`${SEL_DEMON}: ${demonList[SEL_DEMON].name} SubType ${demonList[SEL_DEMON].st}  \n        CR ${demonList[SEL_DEMON].cr}`, demonList[SEL_DEMON].data)\n    //--------------------------------------------------------------------------------------------------\n    // Obtain the true name of demons object \n    //\n    let trueName = await DAE.getFlag(aToken.actor, `${FLAG_BASE}_${selection}`);\n    let demonType = selection.replace(/ /g, \"_\");   // Replace spaces in selection with underscores\n    if (TL > 3) jez.trace(`${TAG} demonType`, demonType)\n    if (!trueName) trueName= \"\"                         // Swap any falsey value to empty string\n    if (TL > 2) jez.trace(`${TAG} trueName \"${trueName}\"`)\n    //--------------------------------------------------------------------------------------------------\n    // Pop a dialog to solicit new name input or to confirm name provided earlier and call next callback\n    //\n    let template = `<div><label>Do you know the true name of the ${selection}? If so enter the name in \n                    the box below, then press the \"Known\" button; otherwise, click \"Unknown\"</label>\n                <div class=\"form-group\" style=\"font-size: 14px; padding: 5px; \n                    border: 2px solid silver; margin: 5px;\">\n                    <input name=\"TEXT_SUPPLIED\" style=\"width:350px\" value=${trueName}></div>`\n    let d = await new Dialog({\n        title: `Set ${aToken.name}'s Familiar's Name`,\n        content: template,\n        buttons: {\n            done: {\n                label: \"Known\",\n                callback: (html) => {\n                    summonDemon(html, \"Known\", SEL_DEMON, demonType);\n                }\n            },\n            cancel: {\n                label: \"Unknown\",\n                callback: (html) => {\n                    summonDemon(html, \"Unknown\", SEL_DEMON, demonType);\n                }\n            }\n        },\n        default: \"done\"\n    })\n    d.render(true)\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Call back function called after demon name (if any) selected and then proceeds with execution.  \n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function summonDemon(html, mode, SEL_DEMON, demonType) {\n    const FUNCNAME = \"summonDemon(html, name)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting ---`, \"html\", html, \"mode\", mode,\n        \"SEL_DEMON\", SEL_DEMON, \"demonType\", demonType);\n    console.log(\"demonType\", demonType)\n    //-----------------------------------------------------------------------------------------------\n    // Set handy variables\n    //\n    const SAVE_DC = aActor.data.data.attributes.spelldc;\n    let summons = demonList[SEL_DEMON].name\n    let width = demonList[SEL_DEMON].data.data.token.width\n    let summonData = demonList[SEL_DEMON].data\n    if (TL > 3) jez.trace(`${TAG} Variable values`,\"summons\",summons,\"width\",width,\n        \"summonData\",summonData)\n    //----------------------------------------------------------------------------------------------\n    // Grab the RunAsGM Macros\n    //\n    const GM_TOGGLE_COMBAT = jez.getMacroRunAsGM(\"ToggleCombatAsGM\")\n    if (!GM_TOGGLE_COMBAT) { return false }\n    const GM_ROLL_INITIATIVE = jez.getMacroRunAsGM(\"RollInitiativeAsGM\")\n    if (!GM_ROLL_INITIATIVE) { return false }\n    //-----------------------------------------------------------------------------------------------\n    const TEXT_SUPPLIED = html.find(\"[name=TEXT_SUPPLIED]\")[0].value;\n    if (TL > 1) jez.trace(`${TAG} Name supplied: \"${TEXT_SUPPLIED}\"`)\n    let demonName = `${aToken.name}'s ${summons}`\n    if (TEXT_SUPPLIED) demonName = TEXT_SUPPLIED\n    //-----------------------------------------------------------------------------------------------\n    // If we have a Known demon, stash the value as a flag for future useage \n    //\n    if (mode === \"Known\") await DAE.setFlag(aActor, `${FLAG_BASE}_${SEL_DEMON}`, demonName);\n    //----------------------------------------------------------------------------------------------\n    // Build the dataObject for our summon call\n    //\n    let argObj = {\n        defaultRange: 90,                   // Defaults to 30, but this varies per spell\n        duration: 1000,                     // Duration of the intro VFX\n        introTime: 1000,                     // Amount of time to wait for Intro VFX\n        introVFX: '~Explosion/Explosion_01_${color}_400x400.webm', // default introVFX file\n        minionName: demonName,\n        name: aItem.name,                   // Name of action (message only), typically aItem.name\n        outroVFX: '~Smoke/SmokePuff01_01_Regular_${color}_400x400.webm', // default outroVFX file\n        scale: 0.7,\t\t\t\t\t\t\t\t// Default value but needs tuning at times\n        source: aToken,                     // Coords for source (with a center), typically aToken\n        templateName: summons,\n        width: width,                       // Width of token to be summoned, 1 is the default\n        traceLvl: TL                        // Trace level, matching calling function decent choice\n    }\n    //----------------------------------------------------------------------------------------------\n    // Nab the data for our soon to be summoned critter so we can have the right image (img) and use\n    // it to update the img attribute or set basic image to match this item\n    //\n    argObj.img = summonData ? summonData.img : aItem.img\n    //--------------------------------------------------------------------------------------------------\n    // Do the actual summon\n    //\n    let demonId = await jez.spawnAt(summons, aToken, aActor, aItem, argObj)\n    if (TL > 2) jez.trace(`${TAG} demon Id ==>`,demonId)\n    //--------------------------------------------------------------------------------------------------\n    // Build a UUID that will be slapped on the concentrating effect for doOff call.  Should look like:\n    //   Scene.MzEyYTVkOTQ4NmZk.Token.cBMsqVwfwf1MxRxV\n    let demonUuid = `Scene.${game.scenes.viewed.id}.Token.${demonId}`\n    if (TL > 2) jez.trace(`${TAG} demonUuid ==>`,demonUuid)\n    modConcentratingEffect(aToken, demonUuid)\n    //--------------------------------------------------------------------------------------------------\n    // Convert Item Card's duration into seconds, if supported units, otherwise go with 3600\n    //\n    let duration = 3600\n    if (aItem.data.duration.units === \"turn\") duration = aItem.data.duration.value * 6\n    if (aItem.data.duration.units === \"round\") duration = aItem.data.duration.value * 6\n    if (aItem.data.duration.units === \"minute\") duration = aItem.data.duration.value * 60\n    if (aItem.data.duration.units === \"hour\") duration = aItem.data.duration.value * 3600\n    //--------------------------------------------------------------------------------------------------\n    // Add an effect to our recently summoned demon to delete itself at the end of the spell duration\n    //\n    console.log(`TODO: Do something to leverage the true name being known, or not known`)\n    const CE_DESC = `Summoned ${summons} will remain for up to an hour`\n    const EXPIRE = [\"newDay\", \"longRest\", \"shortRest\"];\n    const VALUE = `\"${aToken.name}\" ${SAVE_DC} ${mode}`\n    const GAME_RND = game.combat ? game.combat.round : 0;\n    let effectData = {\n        label: aItem.name,\n        icon: CLOCK_IMG,\n        origin: LAST_ARG.uuid,\n        disabled: false,\n        duration: {\n            rounds: duration / 6, startRound: GAME_RND,\n            seconds: duration, startTime: game.time.worldTime,\n            token: aToken.uuid, stackable: false\n        },\n        flags: { \n            dae: { macroRepeat: \"endEveryTurn\", specialDuration: EXPIRE }, \n            convenientDescription: CE_DESC \n        },\n        changes: [\n            { key: `macro.execute`, mode: jez.CUSTOM, value: `Dismiss_Tokens ${demonUuid}`, priority: 20 },\n            { key: `macro.itemMacro`, mode: jez.OVERRIDE, value: VALUE, priority: 20 }\n        ]\n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: demonUuid, effects: [effectData] });\n    //--------------------------------------------------------------------------------------------------\n    // Add the newly summoned demon to the combat tracker and roll initiative\n    //\n    if (TL > 1) jez.trace(`${TAG} Id of the summoned elemental token`, demonId)\n    let dToken = await canvas.tokens.placeables.find(ef => ef.id === demonId[0])\n    if (TL > 2) jez.trace(`${TAG} demon Info`,\n        `demonId    ==>`, demonId,\n        `dToken ==>`, dToken)\n    // await dToken.toggleCombat();    \n    await GM_TOGGLE_COMBAT.execute(dToken.document.uuid)\n    await jez.wait(100)\n    /**\n     * Roll initiative for one or multiple Combatants within the Combat document\n     * @param {string|string[]} ids     A Combatant id or Array of ids for which to roll\n     * @param {object} [options={}]     Additional options which modify how initiative rolls are created or presented.\n     * @param {string|null} [options.formula]         A non-default initiative formula to roll. Otherwise the system default is used.\n     * @param {boolean} [options.updateTurn=true]     Update the Combat turn after adding new initiative scores to keep the turn on the same Combatant.\n     * @param {object} [options.messageOptions={}]    Additional options with which to customize created Chat Messages\n     * @return {Promise<Combat>}        A promise which resolves to the updated Combat document once updates are complete.\n     * \n     * async rollInitiative(ids, {formula=null, updateTurn=true, messageOptions={}}={})\n     **/\n    //  let combatDoc = await game.combat.rollInitiative(dToken.combatant.id, {formula: null, updateTurn: true, \n    //     messageOptions: { rollMode: CONST.DICE_ROLL_MODES.PRIVATE }})\n    // if (TL > 2) jez.trace(`${TAG} combatDoc ==>`,combatDoc)\n    await GM_ROLL_INITIATIVE.execute(dToken.combatant.id)\n    //--------------------------------------------------------------------------------------------------\n    // Post completion message to item card\n    //\n    msg = `${aToken.name} has summoned a ${summons} which will serve for the spell duration.`\n    postResults(msg)\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Build Object of demons that are NPCs whose name doesn't start with a % and isn't excluded\n * \n * Returned Object will have a property for each demon that met the criteria, it will contain\n * \n * key: String - Name of the actor with underscrores in place of spaces\n * cr: Real - Challenge Rating\n * ty: String - Must be fiend\n * st: String - Must be demon (case insensitive)\n * name: String - Name of the actor\n * data: Object - Actor's data object\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nfunction buildDemonList(exclusions) {\n    const FUNCNAME = \"buildDemonList(exclusions)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL === 1) jez.trace(`--- Starting --- ${MACRO} ${FNAME} ---`);\n    if (TL > 1) jez.trace(`--- Starting --- ${MACRO} ${FNAME} ---`, \"exclusions\", exclusions);\n    //-----------------------------------------------------------------------------------------------\n    let demonObj = {}\n    for (const demon of game.actors.contents) {\n        let ed = demon.data\n        if (ed.type !== \"npc\") continue;\n        let type = ed.data.details.type.value\n        if (type !== \"fiend\") continue;\n        let name = demon.name\n        if (name[0] === \"%\") continue;\n        if (exclusions.includes(name)) continue;\n        let subtype = ed.data.details.type.subtype.toLowerCase()\n        if (subtype !== \"demon\") continue;\n        //-------------------------------------------------------------------------------------------\n        if (TL > 3) jez.trace(`${TAG} ${demon.name}`, demon);\n        if (!ed.token.actorLink) {\n            const CR = jez.getCharLevel(demon)                          // Challenge Rating\n            let st = ed.data.details.type.subtype/*.toLowerCase()*/     // Sub Type\n            // if (!allowedSubTypes.includes(st)) st = \"unknown\"\n            if (!st) st = \"Unknown\"\n            const ST = st\n            if (TL > 1) jez.trace(`${TAG} Demon ${name} is CR ${CR} of subtype ${ST}`)\n            const KEY = name.replace(/ /g, \"_\");\n            demonObj[KEY] = { cr: CR, st: ST, name: name, data: demon }\n        }\n    }\n    return (demonObj)\n}\n/***************************************************************************************************\n * Modify existing concentration effect to call this macro as an ItemMacro that can use doOff\n * function can be used to clean accumulated effects.  \n ***************************************************************************************************/\nasync function modConcentratingEffect(token5e, arg) {\n    const EFFECT = \"Concentrating\"\n    //----------------------------------------------------------------------------------------------\n    // Seach the token to find the just added concentrating effect\n    //\n    await jez.wait(100)\n    let effect = await token5e.actor.effects.find(i => i.data.label === EFFECT);\n    //----------------------------------------------------------------------------------------------\n    // Define the desired modification to existing effect. \n    //    \n    effect.data.changes.push({\n        key: `macro.itemMacro`, mode: jez.CUSTOM, value:`${arg} \"${aToken.name}\"`, priority: 20\n    })\n    //----------------------------------------------------------------------------------------------\n    // Apply the modification to existing effect\n    //\n    const result = await effect.update({ 'changes': effect.data.changes });\n    if (result && TL > 1) jez.trace(`${MACRO} | Active Effect ${EFFECT} updated!`, result);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Perform the code that runs when this macro is removed by DAE, set Off\n * \n * Typical Parms: Scene.MzEyYTVkOTQ4NmZk.Token.RjB0uStEVMzKDwUE \"Lizzie McWizardress\"\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function doOff() {\n    const FUNCNAME = \"doOff()\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    if (TL > 1) jez.trace(`--- Starting --- ${MACRONAME} ${FNAME} ---`);\n    let uuid = args[1]\n    let summoner = args[2]\n    let aTokenDocument5e = await fromUuid(uuid)     // Retrieves document for the UUID\n    if (!aTokenDocument5e) return\n    let aToken = aTokenDocument5e._object           // Nabs the Token5e out of a aTokenDocument5e\n    //-----------------------------------------------------------------------------------------------\n    // Build New Name\n    //\n    let uncontrolledName = aToken.name.replace(`${summoner}'s`, 'Uncontrolled')\n    //-----------------------------------------------------------------------------------------------\n    // Display the permissions set in the game for this token.\n    //\n    // if (TL > 1) for (let property in aToken.actor.data.permission) \n    //     if (property !== \"default\") jez.trace(`${FNAME} | Permission for ${property}`, \n    //         aToken.actor.data.permission[property])\n    //-----------------------------------------------------------------------------------------------\n    // Define the updates to be defined, rename, default to 0 (no access), flip disposition \n    //\n    let updates = {\n        actor: {\n            permission: {\n                default: 0,\n            }\n        },\n        token: {\n            name: uncontrolledName,\n            disposition: aToken.data.disposition * -1,\n        },\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Force any player access defined for the token to 0.  This should find only the one match \n    // created earlier by warpgate.\n    //\n    for (let pId in aToken.actor.data.permission) {\n        if (pId === \"default\") continue         // don't mess with the permissions for default\n        let playerData = game.users.get(pId)    // Stash player data object\n        if (TL > 0) jez.trace(`${FNAME} | playerData for ${pId}`,playerData)\n        if (playerData.isGM) continue           // don't mess with the permissions for GM\n        msg = `Set permission for ${playerData.name} to 0 from ${aToken.actor.data.permission[pId]}`\n        if (TL > 0) jez.trace(`${FNAME} | ${msg}`)\n        updates.actor.permission[pId] = 0       // Set player to no permissions\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Display the permissions set in the game for this token.\n    //\n    await warpgate.mutate(aToken.document, updates);\n    //-----------------------------------------------------------------------------------------------\n    // Run simple video on the token with the attitude change\n    //\n    new Sequence()\n        .effect()\n        .file(VFX_FILE)\n        .atLocation(aToken)\n        .center()\n        .scale(.2)\n        .opacity(1)\n        .fadeIn(1500)\n        .duration(5000)\n        .fadeOut(1500)\n        .play()\n    //-----------------------------------------------------------------------------------------------\n    // Display message about released token\n    //\n    game.users.current.name\n    jez.postMessage({\n        color: \"dodgerblue\",\n        fSize: 14,\n        icon: aToken.data.img,\n        msg: `${aToken.name} may well want vengence upon ${summoner}.<br><br>\n        <b>${game.users.current.name}</b> has lost control of demon.`,\n        title: `Control of Demon Lost`,\n        token: aToken\n    })\n    //-----------------------------------------------------------------------------------------------\n    // Comments, perhaps\n    //\n    if (TL > 1) jez.trace(`${FNAME} | --- Finished --- ${MACRONAME} ---`);\n    return;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Perform the code that runs when this macro is invoked each round by DAE\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/ \n async function doEach() {\n    const FUNCNAME = \"doEach()\";\n    const FNAME = FUNCNAME.split(\"(\")[0] \n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL>0) jez.trace(`${TAG} --- Starting ---`);\n    //-----------------------------------------------------------------------------------------------\n    // Stash the Arguments into reasonably named constants\n    //\n    const ORIGIN_NAME = args[1]\n    const SAVE_DC = args[2]\n    const MODE = args[3]\n    if (!ORIGIN_NAME || !SAVE_DC || !MODE) return jez.badNews(`${TAG} Unhappy Args received`,\"e\")\n    //-----------------------------------------------------------------------------------------------\n    // We need to roll a save\n    //\n    if (TL>1) jez.trace(`${TAG} Save vs spell from ${ORIGIN_NAME} DC${SAVE_DC}DC ${MODE} true name`)\n    //-----------------------------------------------------------------------------------------------\n    // Comments, perhaps\n    //\n    if (TL>3) jez.trace(`${TAG} More Detailed Trace Info.`)\n\n    if (TL>1) jez.trace(`${TAG} --- Finished ---`);\n    return true;\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "exportSource": {
      "world": "travels-in-barovia-ce",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.2"
    }
  }
}