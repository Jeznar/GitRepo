{
  "name": "Summon Lesser Demons",
  "type": "spell",
  "img": "icons/environment/creatures/gargoyle-grey-stone.webp",
  "data": {
    "description": {
      "value": "<p class=\"Core-Styles_Core-Body ParaOverride-1\">You utter foul words, summoning demons from the chaos of the Abyss. Roll on the following table to determine what appears.</p>\n<p class=\"Core-Styles_Core-Body ParaOverride-1\">See <a href=\"https://www.dndbeyond.com/spells/summon-lesser-demons\" target=\"_blank\" rel=\"noopener\">D&amp;D Beyond</a> for details.</p>\n<p class=\"Core-Styles_Core-Body\"><strong><span class=\"Serif-Character-Style_Inline-Subhead-Serif\">At Higher Levels.</span></strong> When you cast this spell using a spell slot of 6th or 7th level, you summon twice as many demons. If you cast it using a spell slot of 8th or 9th level, you summon three times as many demons.</p>",
      "chat": "<p class=\"Core-Styles_Core-Body ParaOverride-1\">You utter foul words, summoning demons from the chaos of the Abyss. Roll on the following table to determine what appears.</p>\n<div class=\"table-overflow-wrapper\">\n<table class=\"compendium-left-aligned-table\">\n<thead>\n<tr>\n<th>d6</th>\n<th>Demons Summoned</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1–2</td>\n<td>Two demons of challenge rating 1 or lower</td>\n</tr>\n<tr>\n<td>3–4</td>\n<td>Four demons of challenge rating 1/2 or lower</td>\n</tr>\n<tr>\n<td>5–6</td>\n<td>Eight demons of challenge rating 1/4 or lower</td>\n</tr>\n</tbody>\n</table><div id=\"table-link\">@Compendium[My-Shared-DDB.rolltable.Summon Lesser Demons: Demons Summoned]{Open RollTable Summon Lesser Demons: Demons Summoned}</div>\n</div>\n<p class=\"Core-Styles_Core-Body\">The DM chooses the demons, such as manes or dretches, and you choose the unoccupied spaces you can see within range where they appear. A summoned demon disappears when it drops to 0 hit points or when the spell ends.</p>\n<p class=\"Core-Styles_Core-Body\">The demons are hostile to all creatures, including you. Roll initiative for the summoned demons as a group, which has its own turns. The demons pursue and attack the nearest non-demons to the best of their ability.</p>\n<p class=\"Core-Styles_Core-Body\">As part of casting the spell, you can form a circle on the ground with the blood used as a material component. The circle is large enough to encompass your space. While the spell lasts, the summoned demons can’t cross the circle or harm it, and they can’t target anyone within it. Using the material component in this manner consumes it when the spell ends.</p>\n<p class=\"Core-Styles_Core-Body\"><strong><span class=\"Serif-Character-Style_Inline-Subhead-Serif\">At Higher Levels.</span></strong> When you cast this spell using a spell slot of 6th or 7th level, you summon twice as many demons. If you cast it using a spell slot of 8th or 9th level, you summon three times as many demons.</p>",
      "unidentified": ""
    },
    "source": "Xanathar's Guide to Everything pg 167",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": 1,
      "units": "hour"
    },
    "target": {
      "value": null,
      "width": null,
      "units": "",
      "type": ""
    },
    "range": {
      "value": 60,
      "long": null,
      "units": "ft"
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "other",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": null,
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "level": 3,
    "school": "con",
    "components": {
      "value": "a vial of blood from a humanoid killed within the past 24 hours",
      "vocal": true,
      "somatic": true,
      "material": true,
      "ritual": false,
      "concentration": true
    },
    "materials": {
      "value": "a vial of blood from a humanoid killed within the past 24 hours",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "prepared",
      "prepared": true
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    },
    "attunement": null
  },
  "effects": [],
  "flags": {
    "ddbimporter": {
      "id": 138254,
      "definitionId": 14604,
      "entityTypeId": 435869154,
      "dndbeyond": {
        "lookup": "generic",
        "lookupName": "generic",
        "level": null,
        "castAtLevel": null
      },
      "sources": [
        {
          "sourceId": 27,
          "pageNumber": 167,
          "sourceType": 1
        }
      ],
      "tags": [
        "Summoning"
      ]
    },
    "betterRolls5e": {
      "quickVersatile": {
        "altValue": true
      },
      "quickCharges": {
        "value": {
          "use": true,
          "resource": true
        },
        "altValue": {
          "use": true,
          "resource": true
        }
      }
    },
    "cf": {
      "id": "temp_edz3xuutj1n"
    },
    "core": {
      "sourceId": "Compendium.My-Shared-DDB.spells.OBAZ77cwCEvhi6QL"
    },
    "midi-qol": {
      "effectActivation": false,
      "onUseMacroName": "[postActiveEffects]ItemMacro"
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Summon Lesser Demons",
          "type": "script",
          "author": "ZjFlOWYxZjM5ZTZj",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const MACRONAME = \"Summon_Lesser_Demon.0.2.js\"\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Automate Summon Lesser Demon, based directly on Summon_Greater_Demon.0.1.js. Key things that this\n * macro accomplishes:\n *\n * 1. Roll a d6 to determine the CR & Qty of demon to summon\n * 2. Build list of available summons (scan sidebar), verifying existence of each\n * 3. Dialog to select a specific creature to summon\n * 4. Place summoned creatures, including making creature \"hostile\" (use warpgate)\n * 5. Mod concentration to run ItemMacro doEach with a list of summoned tokens.\n *   5a. doEach: loop through summons, despawn any defeated, drop conc if none remain active\n *   5b. doOff: despawn any remaining demons\n *\n * 11/17/22 0.1 Creation of Macro from Summon_Greater_Demon.0.1.js\n * 11/19/22 0.2 Replace direct calls with jez.lib calls: jez.combatAddRemove & jez.combatInitiative\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nconst MACRO = MACRONAME.split(\".\")[0]       // Trim of the version number and extension\nconst TAG = `${MACRO} |`\nconst TL = 0;                               // Trace Level for this macro\nlet msg = \"\";                               // Global message string\n//---------------------------------------------------------------------------------------------------\nif (TL > 1) jez.trace(`=== Starting === ${MACRONAME} ===`);\nif (TL > 2) for (let i = 0; i < args.length; i++) jez.trace(`  args[${i}]`, args[i]);\nconst LAST_ARG = args[args.length - 1];\n//---------------------------------------------------------------------------------------------------\n// Set the value for the Active Token (aToken)\nlet aToken;\nif (LAST_ARG.tokenId) aToken = canvas.tokens.get(LAST_ARG.tokenId);\nelse aToken = game.actors.get(LAST_ARG.tokenId);\nlet aActor = aToken.actor;\n//\n// Set the value for the Active Item (aItem)\nlet aItem;\nif (args[0]?.item) aItem = args[0]?.item;\nelse aItem = LAST_ARG.efData?.flags?.dae?.itemData;\n//---------------------------------------------------------------------------------------------------\n// Set Macro specific globals\n//\nconst SPELL_LVL = args[0]?.spellLevel || 3\nlet fractialCRs = [0.5, 0.25, 0.125]\nlet demonList                                               // Summon candidates list array\nlet trueNameObj                                             // Object containing demon:trueName pairs\nlet demonArray = []                                         // Global array of demons\nlet demonCnt, demonCR\nconst TILE_FLAG = `${MACRONAME}-TileId`\n//---------------------------------------------------------------------------------------------------\n// Run the main procedures, choosing based on how the macro was invoked\n//\nif (args[0] === \"off\") await doOff({ traceLvl: TL });                   // DAE removal\nif (args[0]?.tag === \"OnUse\") await doOnUse({ traceLvl: TL });          // Midi ItemMacro On Use\nif (args[0] === \"each\") doEach({ traceLvl: 0 });\t\t\t\t\t    // DAE everyround\nif (TL > 1) jez.trace(`=== Starting === ${MACRONAME} ===`);\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ****************************************************************************************************\n * Post results to the chat card\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nfunction postResults(msg) {\n    let chatMsg = game.messages.get(args[args.length - 1].itemCardId);\n    jez.addMessage(chatMsg, { color: jez.randomDarkColor(), fSize: 14, msg: msg, tag: \"saves\" });\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Perform the code that runs when this macro is invoked as an ItemMacro \"OnUse\"\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function doOnUse(options = {}) {\n    const FUNCNAME = \"doOnUse()\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    await jez.wait(100)\n    if (TL === 1) jez.trace(`${TAG} --- Starting --- ${MACRO} ${FNAME} ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${MACRO} ${FUNCNAME} ---`);\n    //--------------------------------------------------------------------------------------------//\n    // 0. Ask player if they want to drop a protective tile with a simple dialog                  //\n    //--------------------------------------------------------------------------------------------//\n    const Q_TITLE = `Create Protective Circle`\n    const Q_TEXT = `Does ${aToken.name} want to create a warding circle from the blood component?  \n    While the spell lasts, the summoned demons can't cross the circle or harm it, and they can't \n    target anyone within it. Using the material component in this manner consumes it when the \n    spell ends.<br><br>\n    Select Yes, to create the protective circle.<br><br>`\n    const MAKE_CICRLE = await Dialog.confirm({ title: Q_TITLE, content: Q_TEXT, });\n    if (TL > 1) jez.trace(`${TAG} Does ${aToken.name} wish to make a circle?`, MAKE_CICRLE)\n    //----------------------------------------------------------------------------------------------\n    // If a tile is desired, render it.\n    // First, build the data object for the tile to be created\n    //\n    if (MAKE_CICRLE) {\n        const GRID_SIZE = canvas.scene.data.grid;   // Stash the grid size\n        const SCALER = 1.5\n        const X = aToken.center.x - GRID_SIZE * 3 / 4\n        const Y = aToken.center.y - GRID_SIZE * 3 / 4\n        const COLOR_ARRAY = [\"Green\", \"Blue\", \"Red\"]\n        const COLOR_INDEX = Math.floor(Math.random() * 3);\n        if (TL > 2) jez.trace(`${TAG} Setting up to place tile`,\n            \"GRID_SIZE      ==>\", GRID_SIZE,\n            \"SCALER         ==>\", SCALER,\n            \"aToken.center.x==>\", aToken.center.x,\n            \"X              ==>\", X,\n            \"aToken.center.y==>\", aToken.center.y,\n            \"Y              ==>\", Y,\n            \"COLOR_ARRAY    ==>\", COLOR_ARRAY,\n            \"COLOR_INDEX    ==>\", COLOR_INDEX)\n        let tileProps = {\n            x: X,                           // X coordinate is center of the template\n            y: Y,                           // Y coordinate is center of the template\n            img: `modules/jb2a_patreon/Library/Generic/Magic_Signs/Abjuration_01_${COLOR_ARRAY[COLOR_INDEX]}_Circle_800x800.webm`,\n            width: GRID_SIZE * SCALER,      // VFX should occupy 1.2 or so tiles\n            height: GRID_SIZE * SCALER,     // ditto\n            alpha: 0.9                      // Opacity of our placed tile 0 to 1.0  \n        };\n        //-----------------------------------------------------------------------------------------------\n        // Call library function to create the new tile, catching the id returned.  This replaces a bunch \n        // of code including jez.createEmbeddedDocs(\"Tile\", [tileProps])\n        //\n        let tileId = await jez.tileCreate(tileProps)\n        if (TL > 2) jez.trace(`${TAG} Tile Data`,\n            \"tileId    ==>\", tileId,\n            \"tileProps ==>\", tileProps)\n        //-----------------------------------------------------------------------------------------------\n        // Stash that tileId as a DAE flag for later use to delete the tile on concentation drop\n        //\n        // await DAE.unsetFlag(aToken.actor, TILE_FLAG);\n        await DAE.setFlag(aToken.actor, TILE_FLAG, tileId);\n    }\n    //--------------------------------------------------------------------------------------------//\n    // 1. Roll a d6 to determine the CR & Qty of demon to summon                                  //\n    //--------------------------------------------------------------------------------------------//\n    let rollObj = new Roll(`1d6`).evaluate({ async: false });\n    await game.dice3d?.showForRoll(rollObj);\n    if (TL > 1) jez.trace(`${TAG} d6 Roll to pick category of demon`, rollObj.total);\n    switch (rollObj.total) {\n        // switch (1) {\n        case 1:\n        case 2: demonCnt = 2; demonCR = 1; break\n        case 3:\n        case 4: demonCnt = 4; demonCR = 0.5; break\n        case 5:\n        case 6: demonCnt = 8; demonCR = 0.25; fractialCRs = [0.25, 0.125]; break\n        default: return jez.badNews(`The d6 seems to have rolled an illegal result`, rollObj)\n    }\n    const MAX_CR = demonCR  // Setting variable used in Greater Demon for compatibility\n    //----------------------------------------------------------------------------------------------\n    // If spell was upcast to level 6 or 7, 2x the count, 7 or 8 3x the count\n    //\n    if (SPELL_LVL === 6 || SPELL_LVL === 7) demonCnt *= 2\n    if (SPELL_LVL === 8 || SPELL_LVL === 9) demonCnt *= 3\n    //----------------------------------------------------------------------------------------------\n    // Maybe print out values so far\n    //\n    if (TL > 2) jez.trace(`${TAG} Demon Quantity Determined!`,\n        \"SPELL_LVL ==>\", SPELL_LVL,\n        \"d6 Rolled ==>\", rollObj.total,\n        \"demonCnt  ==>\", demonCnt,\n        \"demonCR   ==>\", demonCR,\n        \"MAX_CR    ==>\", MAX_CR,\n        \"fractialCRs=>\", fractialCRs)\n    //--------------------------------------------------------------------------------------------//\n    // 2. Build list of available summons (scan sidebar), verifying existence of each             //\n    //--------------------------------------------------------------------------------------------//\n    demonList = buildDemonList([\"Spiritual Weapon\"], { traceLvl: 0 }) // Arg array is exclusions\n    if (TL > 2) jez.trace(`${TAG} demonList`, demonList);\n    const DEMONS = Object.keys(demonList);\n    if (TL > 2) jez.trace(`${TAG} DEMONS`, DEMONS);\n    //------------------------------------------------------------------------------------------------\n    // Step down in integer CRs looking for matches at each value\n    //\n    for (let i = MAX_CR; i >= 1; i--) {\n        for (let demon of DEMONS)\n            if (i === demonList[demon].cr)\n                demonArray.push(`${demon}`)\n        if (TL > 3) jez.trace(`${TAG} Found ${demonArray.length} Demons, checking integer CR ${i}!`,\n            \"demonArray ==>\", demonArray);\n    }\n    //------------------------------------------------------------------------------------------------\n    // Step through fractional CRs looking for matches at each value\n    //\n    for (let i of fractialCRs) {\n        for (let demon of DEMONS)\n            if (i === demonList[demon].cr) {\n                demonArray.push(`${demon}`)\n                if (TL > 3) jez.trace(`${TAG} Found ${demonArray.length} Demons, checking CR ${i}!`,\n                    \"demonArray ==>\", demonArray);\n            }\n    }\n    if (TL > 2) jez.trace(`${TAG} Found ${demonArray.length} Demons!`,\n        \"demonArray ==>\", demonArray);\n    //--------------------------------------------------------------------------------------------//\n    // 3. Dialog to select a specific creature to summon                                          //\n    //--------------------------------------------------------------------------------------------//\n    await callRadioDialog(demonArray)\n    //---------------------------------------------------------------------------------------------\n    // That's all folks\n    //\n    if (TL > 1) jez.trace(`${TAG} --- Finished --- ${MACRONAME} ${FNAME} ---`);\n    return true;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Call Radio list array dialog (seperate function so it can be called by callback)\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function callRadioDialog(demonArray) {\n    const ALLOWED_UNITS = [\"\", \"ft\", \"any\"];\n    let maxRange = jez.getRange(aItem, ALLOWED_UNITS) ?? 60\n    let title = `Select Desired Demon to Summon`\n    msg = `Up to ${demonCnt} Demons of up to CR ${demonCR} may be summoned within ${maxRange} feet\n    of ${aToken.name}.<br><br>\n    See: </span><a style=\"box-sizing: border-box; user-select: text; font-size: 13px;\"\n    href=\"https://www.dndbeyond.com/spells/summon-lesser-demon\" target=\"_blank\" rel=\"noopener\">\n    D&amp;D Beyond Description</a> for spell details.<br><br>\n    Options listed below are all unlinked NPC Demons in the Actor Directory.  Others are available\n    at the GM's discretion.`\n    jez.pickRadioListArray(title, msg, pickDemonCallBack, demonArray);\n}\n\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Call back function called after demon is selected and then proceeds with execution.\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function pickDemonCallBack(selection) {\n    const FUNCNAME = \"pickDemonCallBack(selection)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL === 1) jez.trace(`${TAG} --- Starting --- ${MACRO} ${FNAME} ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${MACRO} ${FUNCNAME} ---`, \"selection\", selection);\n    let combatantIds = []\n    //----------------------------------------------------------------------------------------------\n    if (selection === undefined) {  // If nothing was selected, spin the dialog again\n        callRadioDialog(demonArray)\n        return\n    }\n    if (!selection) return false;\n    const SEL_DEMON = selection.split(\" \")[0]\n    if (TL > 2) jez.trace(`${TAG} Selected Demon ${SEL_DEMON}`,\n        \"Demon Type ==>\", demonList[SEL_DEMON].name,\n        \"SubType    ==>\", demonList[SEL_DEMON].st,\n        \"CR         ==>\", demonList[SEL_DEMON].cr,\n        \"DataObj    ==>\", demonList[SEL_DEMON].data)\n    //-----------------------------------------------------------------------------------------------\n    // Fire off the summons, collecting the returned synthetic token UUIDs\n    //\n    let demonUuids = \"\"\n    for (let i = 1; i <= demonCnt; i++) {\n        let dUuid = await summonCritter(demonList[SEL_DEMON].data, i, { traceLvl: TL })\n        await jez.combatAddRemove('Add', dUuid, { traceLvl: TL })           // Add new demon to combat\n        await jez.wait(100)\n        await jez.combatInitiative([ dUuid ], { formula: null, traceLvl: 0 })  // Roll demon initiative\n        if (TL > 2) jez.trace(`${TAG} Demon UUID ${i}`, dUuid)\n        if (demonUuids) demonUuids += ' ' + dUuid; else demonUuids += dUuid\n    }\n    if (TL > 2) jez.trace(`${TAG} Demon UUIDs`, demonUuids)\n    //-----------------------------------------------------------------------------------------------\n    // Modify the concentration effect\n    //\n    modConcentratingEffect(aToken, demonUuids, { traceLvl: 0 })\n    //-----------------------------------------------------------------------------------------------\n    // Scoop up Token5e data objects for the summoned demons\n    //\n    const DEMON_UUIDS = demonUuids.split(\" \")\n    if (TL > 2) jez.trace(`${TAG} DEMON UUIDS`, DEMON_UUIDS)\n    //-----------------------------------------------------------------------------------------------\n    // Force any player access defined for the token to 0.  This should find only the one match\n    // created earlier by warpgate. Interesting thing here is ownership of a warpgate token is\n    // removed from the player that created it.\n    //\n    let updates = {\n        actor: {\n            permission: {\n                default: 0,\n            }\n        }\n    }\n    for (let i = 0; i < DEMON_UUIDS.length; i++) {\n        let dToken = canvas.tokens.placeables.find(ef => ef.id === DEMON_UUIDS[i].split(\".\")[3])\n        if (TL > 2) jez.trace(`${TAG} ${i} dToken `, dToken)\n        for (let pId in dToken.actor.data.permission) {\n            if (pId === \"default\") continue         // don't mess with the permissions for default\n            let playerData = game.users.get(pId)    // Stash player data object\n            if (TL > 2) jez.trace(`${TAG} | playerData for ${pId}`, playerData)\n            if (playerData.isGM) continue           // don't mess with the permissions for GM\n            msg = `Set permission for ${playerData.name} to 0 from ${aToken.actor.data.permission[pId]}`\n            if (TL > 2) jez.trace(`${TAG} | ${msg}`)\n            updates.actor.permission[pId] = 0       // Set player to no permissions\n        }\n        await warpgate.mutate(dToken.document, updates);\n    }\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Call back function called after demon is selected and then proceeds with execution.\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function summonCritter(SUMMON_DATA, number, options = {}) {\n    const FUNCNAME = \"pickDemonCallBack(selection)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting --- ${MACRO} ${FNAME} ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${MACRO} ${FUNCNAME} ---`,\n        \"SUMMON_DATA\", SUMMON_DATA, \"Number\", number);\n    //----------------------------------------------------------------------------------------------\n    // Set handy variables\n    //\n    const TEMPLATE = SUMMON_DATA.name\n    const NAME = `${SUMMON_DATA.name} ${number}`\n    const WIDTH = SUMMON_DATA.data.token.width\n    //----------------------------------------------------------------------------------------------\n    // Build the dataObject for subsequent summon call\n    //\n    let argObj = {\n        defaultRange: 60,                   // Defaults to 30, but this varies per spell\n        duration: 1000,                     // Duration of the intro VFX\n        introTime: 1000,                     // Amount of time to wait for Intro VFX\n        introVFX: '~Explosion/Explosion_01_${color}_400x400.webm', // default introVFX file\n        minionName: NAME,\n        name: aItem.name,                   // Name of action (message only), typically aItem.name\n        outroVFX: '~Smoke/SmokePuff01_01_Regular_${color}_400x400.webm', // default outroVFX file\n        scale: 0.5,\t\t\t\t\t\t\t\t// Default value but needs tuning at times\n        source: aToken,                     // Coords for source (with a center), typically aToken\n        templateName: TEMPLATE,\n        width: WIDTH,                       // Width of token to be summoned, 1 is the default\n        traceLvl: TL                        // Trace level, matching calling function decent choice\n    }\n    //----------------------------------------------------------------------------------------------\n    // Define some updates for the spawned demon\n    //\n    argObj.updates = {\n        actor: { // This seemingly does nothing useful\n            permission: { default: 0 }\n        },\n        token: {\n            name: NAME,\n            disposition: -1,\n        }\n    }\n    //----------------------------------------------------------------------------------------------\n    // Nab the data for our soon to be summoned critter so we can have the right image (img) and use\n    // it to update the img attribute or set basic image to match this item\n    //\n    argObj.img = SUMMON_DATA ? SUMMON_DATA.img : aItem.img\n    //--------------------------------------------------------------------------------------------------\n    // Do the actual summon\n    //\n    let demonId = await jez.spawnAt(TEMPLATE, aToken, aActor, aItem, argObj)\n    //--------------------------------------------------------------------------------------------------\n    // Build a UUID that will be slapped on the concentrating effect for doOff call.  Should look like:\n    //   Scene.MzEyYTVkOTQ4NmZk.Token.cBMsqVwfwf1MxRxV\n    let demonUuid = `Scene.${game.scenes.viewed.id}.Token.${demonId}`\n    return demonUuid\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Build Object of demons that are NPCs whose name doesn't start with a % and isn't excluded\n *\n * Returned Object will have a property for each demon that met the criteria, it will contain\n *\n * key: String - Name of the actor with underscrores in place of spaces\n * cr: Real - Challenge Rating\n * ty: String - Must be fiend\n * st: String - Must be demon (case insensitive)\n * name: String - Name of the actor\n * data: Object - Actor's data object\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nfunction buildDemonList(exclusions, options = {}) {\n    const FUNCNAME = \"buildDemonList(exclusions)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`--- Starting --- ${MACRO} ${FNAME} ---`);\n    if (TL > 1) jez.trace(`--- Starting --- ${MACRO} ${FNAME} ---`, \"exclusions\", exclusions);\n    //-----------------------------------------------------------------------------------------------\n    let demonObj = {}\n    for (const demon of game.actors.contents) {\n        if (demon.data.type !== \"npc\") continue;\n        if (demon.data.data.details.type.value !== \"fiend\") continue;\n        if (demon.name[0] === \"%\") continue;\n        if (exclusions.includes(demon.name)) continue;\n        if (demon.data.data.details.type.subtype.toLowerCase() !== \"demon\") continue;\n        //-------------------------------------------------------------------------------------------\n        if (TL > 3) jez.trace(`${TAG} ${demon.name}`, demon);\n        if (!demon.data.token.actorLink) {\n            const CR = jez.getCharLevel(demon)                          // Challenge Rating\n            let st = demon.data.data.details.type.subtype/*.toLowerCase()*/     // Sub Type\n            if (!st) st = \"Unknown\"\n            const ST = st\n            if (TL > 1) jez.trace(`${TAG} ${demon.name} is CR ${CR} of subtype ${ST}`)\n            const KEY = demon.name.replace(/ /g, \"_\");\n            demonObj[KEY] = { cr: CR, st: ST, name: demon.name, data: demon }\n        }\n    }\n    return (demonObj)\n}\n/***************************************************************************************************\n * Modify existing concentration effect to call this macro as an ItemMacro that can use doOff\n * function can be used to clean accumulated effects and fire this macro at turnStart for aToken\n ***************************************************************************************************/\nasync function modConcentratingEffect(token5e, arg, options = {}) {\n    const FUNCNAME = \"modConcentratingEffect(token5e, arg, options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    await jez.wait(100)\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`,\n        \"token5e ==>\", token5e, \"arg     ==>\", arg, \"options ==>\", options)\n    //----------------------------------------------------------------------------------------------\n    // Define local variables\n    //\n    const EFFECT = \"Concentrating\"\n    //----------------------------------------------------------------------------------------------\n    // Seach the token to find the just added concentrating effect\n    //\n    await jez.wait(100)\n    let effect = await token5e.actor.effects.find(i => i.data.label === EFFECT);\n    if (TL > 2) jez.trace(`${TAG} Concentrating Effect Object`, effect)\n    //----------------------------------------------------------------------------------------------\n    // Define the desired modification to existing effect.\n    //\n    effect.data.changes.push({\n        key: `macro.itemMacro`, mode: jez.CUSTOM, value: `${arg}`, priority: 20\n    })\n    effect.data.flags.dae.macroRepeat = \"startEveryTurn\"\n    if (TL > 2) jez.trace(`${TAG} effect.data`, effect.data)\n    //----------------------------------------------------------------------------------------------\n    // Apply the modification to existing concentration effect so it will run at startEveryTurn\n    //\n    const result1 = await effect.update({\n        'changes': effect.data.changes,\n        'flags.dae.macroRepeat': effect.data.flags.dae.macroRepeat\n    });\n    if (TL > 2) jez.trace(`${TAG} result1`, result1)\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Perform the code that runs when this macro is removed by DAE, set Off\n *\n * Typical Parms for two summoned demons\n *  args[0] : off\n *  args[1] : Scene.MzEyYTVkOTQ4NmZk.Token.g0uajGSB37fNRfnL\n *  args[2] : Scene.MzEyYTVkOTQ4NmZk.Token.XoCuvsT6bVc5lzl5\n *  args[3] : LAST_ARG Object from DAE\n *\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function doOff(options = {}) {\n    const FUNCNAME = \"doOff(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`,\"options ==>\",options);\n    //-----------------------------------------------------------------------------------------------\n    // Build Array of Token ids received, discarding first and last argument\n    //\n    for (let i = 1; i < args.length - 1; i++) {\n        if (TL > 2) jez.trace(`${TAG} ${i} Demon Info`, args[i])\n        let sceneId = args[i].split(\".\")[1]\n        let demonId = args[i].split(\".\")[3]\n        let dToken = canvas.tokens.placeables.find(ef => ef.id === demonId)\n        if (TL > 2) jez.trace(`${TAG} ${i} Demon Info`,\n            \"sceneId ==>\", sceneId,\n            \"demonId ==>\", demonId,\n            \"dToken  ==>\", dToken)\n        if (dToken) {\n            if (TL > 2) jez.trace(`${TAG} ${i} Dismissing ${dToken.name}`,dToken)\n            runVFXSmoke(dToken.center)\n            warpgate.dismiss(demonId, sceneId)\n            await jez.wait(750)\n        }\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Delete the circle of protection tile\n    //\n    let tileId = await DAE.getFlag(aToken.actor, TILE_FLAG);\n    jez.tileDelete(tileId)\n    await DAE.unsetFlag(aToken.actor, TILE_FLAG);\n    //-----------------------------------------------------------------------------------------------\n    // Thats all folks\n    //\n    if (TL > 1) jez.trace(`${FNAME} | --- Finished --- ${MACRONAME} ---`);\n    return;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Run a simple smoke VFX on specified location\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function runVFXSmoke(coords) {\n    const VFX_SMOKE = `modules/jb2a_patreon/Library/Generic/Smoke/SmokePuff01_*_Regular_Grey_400x400.webm`\n    new Sequence()\n        .effect()\n        .file(VFX_SMOKE)\n        .atLocation(coords)\n        .scale(.5)\n        .opacity(.5)\n        .play()\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Each turn need to check health of ur summoned demons, if they are dead, dismiss them.\n * If they are all dead, drop concentration and post message.\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function doEach(options = {}) {\n    const FUNCNAME = \"doEach(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    let demonAlive = false      // Trackes if a Demon is alive, if none are, concetration removed\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options ==>\", options);\n    //-----------------------------------------------------------------------------------------------\n    // Build Array of Token ids received, discarding first and last argument\n    //\n    for (let i = 1; i < args.length - 1; i++) {\n        if (TL > 2) jez.trace(`${TAG} ${i} Demon Info`, args[i])\n        let sceneId = args[i].split(\".\")[1]\n        let demonId = args[i].split(\".\")[3]\n        let dToken = canvas.tokens.placeables.find(ef => ef.id === demonId)\n        if (TL > 2) jez.trace(`${TAG} ${i} Demon Info`,\n            \"sceneId ==>\", sceneId,\n            \"demonId ==>\", demonId,\n            \"dToken  ==>\", dToken)\n        if (dToken) {\n            if (dToken?.actor?.data?.data?.attributes?.hp?.value <= 0) {\n                if (TL > 0) jez.trace(`${TAG} ${dToken.name} appears to be dead, dismiss it`,dToken)\n                runVFXSmoke(dToken.center)\n                warpgate.dismiss(demonId, sceneId)\n                await jez.wait(750)\n            }\n            else {\n                if (TL > 0) jez.trace(`${TAG} ${dToken.name} appears to be alive`)\n                demonAlive = true\n            }\n        }\n    }\n    //----------------------------------------------------------------------------------------------\n    // If no demons remain alive, remove concentrating from originating token\n    //\n    if (!demonAlive) {\n        let concentratingEffect = aToken.actor.effects.find(ef => ef.data.label === \"Concentrating\");\n        if (concentratingEffect) await concentratingEffect.delete();\n        jez.postMessage({color: jez.randomDarkColor(), fSize: 14, icon: aToken.data.img, \n                title: \"Summoned Demons Dead\", \n                msg: `${aToken.name} has noticed that all of the summoned demons are dead and \n                voluntarily drops concentration`, \n                token: aToken})\n    }\n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n    return true;\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "exportSource": {
      "world": "travels-in-barovia-ce",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.2"
    }
  }
}