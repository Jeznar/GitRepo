{
  "name": "Cruel_Puppetry",
  "type": "script",
  "author": "ZjFlOWYxZjM5ZTZj",
  "img": "Icons_JGB/Spells/3rd_Level/Cruel_Puppetry/Puppet.png",
  "scope": "global",
  "command": "const MACRONAME = \"Cruel_Puppetry.0.3.js\"\n/*****************************************************************************************\n * Create a temporary attack item to use against the victim of Cruel Puppetry\n *\n * 01/15/22 0.1 Creation of Macro\n * 01/16/22 0.2 Finishing up.  Still has issue with multiple targets\n * 05/17/22 0.3 FoundryVTT 9.x compatibility\n *****************************************************************************************/\nconst MACRO = MACRONAME.split(\".\")[0]     // Trim of the version number and extension\njez.log(\"\")\njez.log(`============== Starting === ${MACRONAME} =================`);\nfor (let i = 0; i < args.length; i++) jez.log(`  args[${i}]`, args[i]);\nconst lastArg = args[args.length - 1];\nlet aActor;         // Acting actor, creature that invoked the macro\nlet aToken;         // Acting token, token for creature that invoked the macro\nlet aItem;          // Active Item information, item invoking this macro\nif (lastArg.tokenId) aActor = canvas.tokens.get(lastArg.tokenId).actor; else aActor = game.actors.get(lastArg.actorId);\nif (lastArg.tokenId) aToken = canvas.tokens.get(lastArg.tokenId); else aToken = game.actors.get(lastArg.tokenId);\nif (args[0]?.item) aItem = args[0]?.item; else aItem = lastArg.efData?.flags?.dae?.itemData;\nconst CUSTOM = 0, MULTIPLY = 1, ADD = 2, DOWNGRADE = 3, UPGRADE = 4, OVERRIDE = 5;\njez.log(\"------- Global Values Set -------\",\n    `Active Token (aToken) ${aToken?.name}`, aToken,\n    `Active Actor (aActor) ${aActor?.name}`, aActor,\n    `Active Item (aItem) ${aItem?.name}`, aItem)\nlet msg, errorMsg, msgTitle = \"\";\nlet gameRound = game.combat ? game.combat.round : 0;\nconst SMASH_IMG = \"Icons_JGB/Spells/3rd_Level/Cruel_Puppetry/Puppet.png\"\nconst RIP_IMG   = \"Icons_JGB/Spells/3rd_Level/Cruel_Puppetry/Puppet_Broken.png\"\nconst FORCE_IMG = \"Icons_JGB/Spells/3rd_Level/Cruel_Puppetry/Puppet_Moved.png\"\nconst HOLD_IMG  = \"Icons_JGB/Spells/3rd_Level/Cruel_Puppetry/Puppet_Restrained.png\"\nconst FAIL_ICON = \"Icons_JGB/Misc/Failure.png\"\nconst RESTRAINED_JOURNAL = \"<b>@JournalEntry[CZWEqV2uG9aDWJnD]{restrained}</b>\"\nconst RESTRAINED_ICON    = \"modules/combat-utility-belt/icons/restrained.svg\"\nconst RESTRAINED_NAME    = \"Restrained\" // aItem.name || \"Nature's Wraith\";\nconst ERROR_ICON         = \"Icons_JGB/Misc/Error.png\"\nconst ATTACK_ITEM = \"Cruel Puppetry Repeat Effect\";\nlet distance = 15\nlet numDice = 3\nlet repeatExe = false\nif (args[0]?.item?.name.toLowerCase().includes(\"repeat\")) repeatExe = true // e.g. \"Cruel Puppetry Repeat Effect\"\njez.log(\"Repeat execution\",repeatExe)\n//----------------------------------------------------------------------------------\n// Run the preCheck function to make sure things are setup as best I can check them\n//\nif ( (args[0]?.tag === \"OnUse\") && (!repeatExe) ) { // Only check on first doOnUse run\n    if (!(await preCheck())) {\n        jez.log(errorMsg)\n        return;\n    }\n}\n//----------------------------------------------------------------------------------\n// Run the main procedures, choosing based on how the macro was invoked\n//\nif (args[0] === \"off\")  doOff();                   // DAE removal\n//if (args[0] === \"on\") await doOn();                     // DAE Application\nif (args[0]?.tag === \"OnUse\") doOnUse();          // Midi ItemMacro On Use\nif (args[0] === \"each\") doEach();\t\t\t\t\t    // DAE removal\nif (args[0]?.tag === \"DamageBonus\") doBonusDamage();    // DAE Damage Bonus\n\njez.log(`============== Finishing === ${MACRONAME} =================`);\n/***************************************************************************************************\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ***************************************************************************************************/\n\n/***************************************************************************************************\n * Check the setup of things.  Setting the global errorMsg and returning true for ok!\n ***************************************************************************************************/\nasync function preCheck() {\n    // Check anything important...\n    if (!oneTarget()) {\n        jez.log(errorMsg)\n        ui.notifications.error(errorMsg)\n\n        msg = `No, no, NO!.<br><br><b>Cruel Puppetry</b> requires exactly one target! <br><br>${errorMsg}`\n        msgTitle = \"Suspected PEBCAK Error\"\n        await jezPostMessage({ color: \"Crimson\", fSize: 14, msg: msg, title: msgTitle, icon: ERROR_ICON })\n        // await jezDeleteItem(ATTACK_ITEM, aActor); // Broken at FoundryVTT 9.x\n        await jez.deleteItems(ATTACK_ITEM, \"spell\", aActor);\n        await DAE.unsetFlag(aActor, `${MACRO}.spellData`); \n        jez.log(\"aActor\", aActor)\n        let concentrating = await aActor.effects.find(ef => ef.data.label === \"Concentrating\");\n        jez.log(\"concentrating\", concentrating)\n        if (concentrating) await concentrating.delete();\n\n        return(false);\n    }\n    jez.log('All looks good, to quote Jean-Luc, \"MAKE IT SO!\"')\n    return (true)\n}\n\n/***************************************************************************************************\n * Perform the code that runs when this macro is removed by DAE, set Off\n *\n * https://github.com/fantasycalendar/FoundryVTT-Sequencer/wiki/Sequencer-Effect-Manager#end-effects\n ***************************************************************************************************/\n async function doOff() {\n    const FUNCNAME = \"doOff()\";\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    let originID = lastArg.origin.split(\".\")[1] // aqNN90V6BjFcJpI5 (Origin  ID)\n    jez.log(\"originID\", originID);\n    let oToken = canvas.tokens.objects.children.find(e => e.data.actorId === originID)\n    jez.log(\"oToken\", oToken)\n    let oActor = oToken.actor\n    jez.log(\"oActor\", oActor)\n    jez.log(`doOff ---> Delete ${ATTACK_ITEM} from ${oToken.data.name} if it exists`)\n    //await jezDeleteItem(ATTACK_ITEM, oActor);\n    await jez.deleteItems(ATTACK_ITEM, \"spell\", oActor);\n    await DAE.unsetFlag(oActor, `${MACRO}.spellData`); \n    jez.log(\"Actor to remove concentration from\", oActor)\n    let concentrating = await oActor.effects.find(ef => ef.data.label === \"Concentrating\");\n    jez.log(\"Concentration effect\", concentrating)\n    if (concentrating) await concentrating.delete();\n    // await deleteItem(ATTACK_ITEM, oActor);\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    return;\n  }\n\n/***************************************************************************************************\n * Perform the code that runs when this macro is removed by DAE, set On\n ***************************************************************************************************/\nasync function doOn() {\n    const FUNCNAME = \"doOn()\";\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    jez.log(\"A place for things to be done\");\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    return;\n}\n/***************************************************************************************************\n * Perform the code that runs when this macro is invoked as an ItemMacro \"OnUse\"\n ***************************************************************************************************/\nasync function doOnUse() {\n    const FUNCNAME = \"doOnUse()\";\n    let tToken, tActor, spellData;\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n\n    if (repeatExe) { // On repeat execution, get target and level info from data flag\n        spellData = await DAE.getFlag(aActor, `${MACRO}.spellData`);\n        jez.log(\"___Flag Data___\",\n            \"targetID\", spellData.targetID,\n            \"spellLevel\", spellData.spellLevel);\n        tToken = canvas.tokens.objects.children.find(e => e.data.actorId === spellData.targetID);\n        tActor = tToken?.actor;\n        // set spell effects based on flag data\n        distance = Math.min(tActor.data.data.attributes.movement.walk, 5 * spellData.spellLevel)\n        numDice = spellData.spellLevel;\n        jez.log(\"Have Target Roll Save Again\")\n        let saveDC = aActor.data.data.attributes.spelldc;\n        const SAVE_TYPE = \"cha\"\n        const FLAVOR = `${CONFIG.DND5E.abilities[SAVE_TYPE]} <b>DC${saveDC}</b> to end <b>Cruel Puppetry</b>`;\n        let save = (await tActor.rollAbilitySave(SAVE_TYPE,\n            { FLAVOR, chatMessage: true, fastforward: true, disadvantage: true }));\n        jez.log(\"save\", save);\n        msgTitle = \"Cruel Puppetry - \"\n        if (save.total > saveDC) {\n            jez.log(`save was made with a ${save.total}`);\n            let concentrating = await aActor.effects.find(ef => ef.data.label === \"Concentrating\");\n            if (concentrating) await concentrating.delete();\n            msg = `${tToken.name} has broken the Cruel Pupptry spell, with a CHA save of ${save.total}\n            against a DC${saveDC}.  The doll used to cast the spell has been destroyed.`\n            msgTitle += \"Spell Broken\"\n            jezPostMessage({ color: \"BlueViolet\", fSize: 14, msg: msg, title: msgTitle, icon: FAIL_ICON })\n            return;\n        } else {\n            jez.log(`save failed with a ${save.total}`);\n\n            // Post results to game chat\n            msg = `${tToken.name} failed to save against the Cruel Pupptry spell, with a CHA save of \n            ${save.total} against a DC${saveDC}.  ${aToken.name} may choose an effect.`\n            msgTitle += \"Save Failed\"\n            jezPostMessage({ color: \"DarkGreen\", fSize: 14, msg: msg, title: msgTitle, icon: FAIL_ICON })\n        }\n    } else { // First time execution\n        tToken = canvas.tokens.get(args[0]?.targets[0]?.id); // First Targeted Token, if any\n        tActor = tToken?.actor;\n        await createItem()\n        // calculate spell effects based on level and target\n        distance = Math.min(tActor.data.data.attributes.movement.walk, 5 * args[0].spellLevel)\n        numDice = args[0].spellLevel;\n        // Store info in a DAE flag on the caster\n        spellData = {\n            targetID: tActor?.id,\n            spellLevel: args[0].spellLevel,\n        }\n        await DAE.unsetFlag(aActor, `${MACRO}.spellData`); \n        await DAE.setFlag(aActor, `${MACRO}.spellData`, spellData);\n    }\n\n    await pickFlavor()\n \n    // https://www.w3schools.com/tags/ref_colornames.asp\n    msg = `<p style=\"color:blue;font-size:14px;\">\n    Maybe say something useful...</p>`\n    //postResults(msg);\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    return (true);\n    //----------------------------------------------------------------------------------\n    //\n    async function createItem() {\n        let descValue = `As an action, this innate spell may be used to repeat one of the \n        effects of <b>Cruel Puppetry<b> to <b>${tToken.name}</b>.  \n       <br><br>\n       <b>FoundryVTT</b>: The target does not need to be targeted to use this ability.`;\n        let itemData = [{\n            \"name\": ATTACK_ITEM,\n            \"type\": \"spell\",\n            \"flags\": {\n                \"midi-qol\": {\n                    \"onUseMacroName\": \"Cruel_Puppetry\"\n                }\n            },\n            \"data\": {\n                \"ability\": \"\",\n                \"actionType\": \"other\",\n                \"activation\": {\n                    \"cost\": 1,\n                    \"type\": \"action\"\n                },\n                \"description\": { \"value\": descValue },\n                \"formula\": \"\",\n                \"level\": args[0].spellLevel,\n                \"preparation\": {\n                    \"mode\": \"innate\",\n                    \"prepared\": false\n                },\n                \"source\": `${tToken.name}'s Cruel Puppetry`,\n                \"school\": \"nec\",\n\n            },\n            \"img\": SMASH_IMG,\n            \"effects\": []\n        }];\n        await aActor.createEmbeddedDocuments(\"Item\", itemData);\n    }\n}\n\n/***************************************************************************************************\n * Select Flavor of Spell this Round and Initiate Callback\n ***************************************************************************************************/\n async function pickFlavor() {\n    const FUNCNAME = \"pickFlavor()\";\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    const queryTitle = \"Select How to Use Doll\"\n    const queryText = \"Pick one from drop down list\"\n    const flavors = [\n        \"Hold the doll still: Restrains the victim.\",\n        `Force the doll to move: Victim moves ${distance} feet as you like.`,\n        `Smash the doll: causing it take ${numDice}d6 bludgeoning damage.`,\n        `Rip the doll in half: ends spell and does ${numDice}d12 necrotic damage.`\n    ]\n    pickFromListArray(queryTitle, queryText, pickFlavorCallBack, flavors);\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    return (true);\n}\n/****************************************************************************************\n * Create and process selection dialog, passing it onto specified callback function\n ***************************************************************************************/\n function pickFromListArray(queryTitle, queryText, pickCallBack, queryOptions) {\n    const FUNCNAME = \"pickFromList(queryTitle, queryText, ...queryOptions)\";\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    if (typeof(pickCallBack)!=\"function\" ) {\n        let msg = `pickFromList given invalid pickCallBack, it is a ${typeof(pickCallBack)}`\n        ui.notifications.error(msg);\n        jez.log(msg);\n        return\n    }\n    if (!queryTitle || !queryText || !queryOptions) {\n        let msg = `pickFromList arguments should be (queryTitle, queryText, pickCallBack, [queryOptions]),\n                   but yours are: ${queryTitle}, ${queryText}, ${pickCallBack}, ${queryOptions}`;\n        ui.notifications.error(msg);\n        jez.log(msg);\n        return\n    }\n    let template = `\n    <div>\n    <div class=\"form-group\">\n        <label>${queryText}</label>\n        <select id=\"selectedOption\">`\n    for (let option of queryOptions) {\n        template += `<option value=\"${option}\">${option}</option>`\n    }\n    template += `</select>\n    </div></div>`\n    new Dialog({\n        title: queryTitle,\n        content: template,\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: 'OK',\n                callback: async (html) => {\n                    const selectedOption = html.find('#selectedOption')[0].value\n                    jez.log('selected option', selectedOption)\n                    pickCallBack(selectedOption)\n                },\n            },\n            cancel: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: 'Cancel',\n                callback: async (html) => {\n                    jez.log('canceled')\n                    pickCallBack(null)\n                },\n            },\n        },\n        default: 'cancel',\n    }).render(true)\n\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} -----------------`);\n        return;\n}\n/***************************************************************************************************\n * Callback function to handle menu choice.\n ***************************************************************************************************/\nasync function pickFlavorCallBack(selection) {\n    const FUNCNAME = \"pickFlavorCallBack(selection)\"\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    if (!selection) {\n        jez.log(\"No selection\", selection)\n        return;\n    }\n    let choice = selection.split(\" \")[0];     // Obtain first token from the selection\n    jez.log(`Choice made: ${choice}!`)\n\n    let tToken = canvas.tokens.get(args[0]?.targets[0]?.id); // First Targeted Token, if any\n    let tActor = tToken?.actor;\n    msgTitle = \"Cruel Puppetry - \"\n\n    switch (choice) {\n        case \"Hold\":\n            jez.log(`Hold Case: ${selection}`)\n            applyRestrained(tActor.uuid)\n            msg = `${tToken.name} is affected by the ${RESTRAINED_JOURNAL} condition until\n                    ${aToken.name}'s next turn`\n            msgTitle += \"Hold Still\"\n            jezPostMessage({ color: \"purple\", fSize: 14, msg: msg, title: msgTitle, icon: HOLD_IMG })\n            break;\n        case \"Force\":\n            jez.log(`Force Case: ${selection}`)\n            msg = `<b>${tToken.name}</b> is forced to move up to ${distance} feet.\n                   <b>${aToken.name}</b> chooses path and destination.`\n            msgTitle += \"Forced Move\"\n            jez.log(\"msg\", msg)\n            jezPostMessage({ color: \"purple\", fSize: 14, msg: msg, title: msgTitle, icon: FORCE_IMG })\n            break;\n        case \"Smash\":\n            jez.log(`Smash Case: ${selection}`)\n            applySmash()\n            break;\n        case \"Rip\":\n            jez.log(`Rip Case: ${selection}`)\n            await applyRip()\n            jez.log(`Force Case: ${selection}`)\n            break;\n        default:\n            jez.log(`Default Case: ${selection}`)\n            errorMsg = `Disturbingly, reached end of switch without a match for ==>${choice}<==`\n            ui.notifications.error(msg);\n            jez.log(errorMsg)\n            return (choice)\n    }\n    return (choice)\n\n    //----------------------------------------------------------------------------------\n    // Apply Restrained Condition to specified UUID\n    //\n    function applyRestrained(actorUUID) {\n        let effectData = [{\n            label: RESTRAINED_NAME,\n            icon: RESTRAINED_ICON,\n            origin: aActor.uuid,\n            disabled: false,\n            duration: { rounds: 1, startRound: gameRound },\n            changes: [\n                { key: `flags.VariantEncumbrance.speed`, mode: OVERRIDE, value: 1, priority: 20 },\n                { key: `data.attributes.movement.walk`, mode: OVERRIDE, value: 1, priority: 20 },\n                { key: `data.attributes.movement.swim`, mode: OVERRIDE, value: 1, priority: 20 },\n                { key: `data.attributes.movement.fly`, mode: OVERRIDE, value: 1, priority: 20 },\n                { key: `data.attributes.movement.climb`, mode: OVERRIDE, value: 1, priority: 20 },\n                { key: `data.attributes.movement.burrow`, mode: OVERRIDE, value: 1, priority: 20 },\n                { key: `flags.midi-qol.disadvantage.attack.all`, mode: OVERRIDE, value: 1, priority: 20 },\n                { key: `flags.midi-qol.grants.advantage.attack.all`, mode: OVERRIDE, value: 1, priority: 20 },\n                { key: `flags.midi-qol.disadvantage.ability.save.dex`, mode: OVERRIDE, value: 1, priority: 20 },\n            ]\n        }]\n        MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: actorUUID, effects: effectData });\n    }\n    //----------------------------------------------------------------------------------\n    // Apply Smash Damage\n    //\n    function applySmash() {\n        let DAMAGETYPE = \"bludgeoning\";\n        let damageDice = `${numDice}d6`;\n        let damageRoll = new Roll(`${damageDice}`).evaluate({ async: false });\n        new MidiQOL.DamageOnlyWorkflow(aActor, aToken, damageRoll.total, DAMAGETYPE, [tToken], damageRoll,\n            { flavor: `${tToken.name} suffers from ${aItem.name} <b>Smash</b>`, itemCardId: args[0].itemCardId });\n\n        msg = `<b>${aToken.name}</b> smashes the focused doll, inflicting ${damageRoll.total} ${DAMAGETYPE} \n               damage on <b>${tToken.name}</b>.`\n        msgTitle += \"Smash Doll\"\n        jez.log(\"msg\", msg)\n        jezPostMessage({ color: \"Maroon\", fSize: 14, msg: msg, title: msgTitle, icon: SMASH_IMG })\n\n    }\n    //----------------------------------------------------------------------------------\n    // Apply Rip Damage & End Spell\n    //\n    async function applyRip() {\n        let DAMAGETYPE = \"necrotic\";\n        let damageDice = `${numDice}d12`;\n        let damageRoll = new Roll(`${damageDice}`).evaluate({ async: false });\n        new MidiQOL.DamageOnlyWorkflow(aActor, aToken, damageRoll.total, DAMAGETYPE, [tToken], damageRoll,\n            { flavor: `${tToken.name} suffers from ${aItem.name} <b>Rip</b>`, itemCardId: args[0].itemCardId });\n\n        msg = `<b>${aToken.name}</b> rips the focused doll in twain, inflicting ${damageRoll.total} ${DAMAGETYPE} \n               damage on <b>${tToken.name}</b> and ending the spell effect.`\n        msgTitle += \"Rip Doll\"\n        jez.log(\"msg\", msg)\n        jezPostMessage({ color: \"FireBrick\", fSize: 14, msg: msg, title: msgTitle, icon: RIP_IMG })\n\n        let concentrating = await aActor.effects.find(ef => ef.data.label === \"Concentrating\");\n        if (concentrating) await concentrating.delete();\n    }\n}\n\n/************************************************************************\n * Verify exactly one target selected, boolean return\n*************************************************************************/\nfunction oneTarget() {\n    if (!game.user.targets) {\n        errorMsg = `Targeted nothing, must target single token to be acted upon`;\n        jez.log(errorMsg);\n        return (false);\n    }\n    if (game.user.targets.ids.length != 1) {\n        errorMsg = `Please target a single token not ${game.user.targets.ids.length} tokens.`;\n        jez.log(errorMsg);\n        return (false);\n    }\n    jez.log(`Targeting one target, a good thing`);\n    return (true);\n}\n/***************************************************************************************\n * Function to delete an item from actor\n *\n * Parameters\n *  - itemName: A string naming the item to be found in actor's inventory\n *  - actor: Optional actor to be searched, defaults to actor launching this macro\n ***************************************************************************************/\n /*async function jezDeleteItem(itemName, actor) {\n    const FUNCNAME = \"deleteItem(itemName, actor)\";\n    let defActor = null;\n    if (lastArg.tokenId) defActor = canvas.tokens.get(lastArg.tokenId).actor; \n    else defActor = game.actors.get(lastArg.actorId);\n    actor = actor ? actor : defActor; // Set actor if not supplied\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`,\n        \"itemName\", itemName, `actor ${actor?.name}`, actor);\n\n    if (!jezIsActor5e(actor)) {\n        errorMsg = `Obtained actor argument is not of type Actor5E (${actor?.constructor.name})`\n        jez.log(errorMsg)\n        jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} ==> FALSE --------------`);\n        return (false);\n    }\n    let item = actor.items.find(item => item.data.name === itemName && item.type === \"spell\")\n    if (item == null || item == undefined) {\n        errorMsg = `${actor.name} does not have ${itemName}`\n        jez.log(errorMsg);\n        jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} ==> FALSE --------------`);\n        return (false);\n    }\n\n    jez.log(\"item.id\", item.id)\n    jez.log(await actor.deleteOwnedItem(item.id));\n    //jez.log(await aActor.deleteEmbeddedDocuments(item.id));\n    // await item.uuid.delete()\n    jez.log(`${actor.name} had (past tense) ${item.name}`, item);\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} ==> TRUE -----------------`);\n    return (true);\n}*/\n/***************************************************************************************************\n * Return true if passed argument is of object type \"Token5e\"\n ***************************************************************************************************/\n function jezIsActor5e(obj) {\n    if (obj?.constructor.name === \"Actor5e\") return(true)\n    return(false)\n}\n/***************************************************************************************************\n * Post the results to chat card\n ***************************************************************************************************/\n async function postResults(resultsString) {\n    const lastArg = args[args.length - 1];\n\n    let chatMessage = game.messages.get(lastArg.itemCardId);\n    let content = await duplicate(chatMessage.data.content);\n    jez.log(`chatMessage: `,chatMessage);\n    //const searchString = /<div class=\"midi-qol-other-roll\">[\\s\\S]*<div class=\"end-midi-qol-other-roll\">/g;\n    //const replaceString = `<div class=\"midi-qol-other-roll\"><div class=\"end-midi-qol-other-roll\">${resultsString}`;\n    const searchString = /<div class=\"end-midi-qol-saves-display\">/g;\n    const replaceString = `<div class=\"end-midi-qol-saves-display\">${resultsString}`;\n    content = await content.replace(searchString, replaceString);\n    await chatMessage.update({ content: content });\n    await ui.chat.scrollBottom();\n    return;\n}\n\n/***************************************************************************************************\n * Post a new chat message -- msgParm should be a string for a simple message or an object with\n * some or all of these fields set below for the chat object.\n *\n * Example Calls:\n *  jezPostMessage(\"Hi there!\")\n *  jezPostMessage({color:\"purple\", fSize:18, msg:\"Bazinga\", title:\"Sheldon says...\" })\n *\n ***************************************************************************************************/\n async function jezPostMessage(msgParm) {\n    const FUNCNAME = \"postChatMessage(msgParm)\";\n    jez.log(`--------------${FUNCNAME}-----------`, \"Starting\", `${MACRONAME} ${FUNCNAME}`,\n        \"msgParm\", msgParm);\n    let typeOfParm = typeof (msgParm)\n    switch (typeOfParm) {\n        case \"string\":\n            await ChatMessage.create({ content: msgParm });\n            break;\n        case \"object\":\n            let chat = {}\n            chat.title = msgParm?.title || \"Generic Chat Message\"\n            chat.fSize = msgParm?.fSize || 12\n            chat.color = msgParm?.color || \"black\"\n            chat.icon  = msgParm?.icon  || \"icons/vtt-512.png\"\n            chat.msg   = msgParm?.msg   || \"Maybe say something useful...\"\n            let chatCard = `\n            <div class=\"dnd5e chat-card item-card midi-qol-item-card\">\n                <header class=\"card-header flexrow\">\n                    <img src=\"${chat.icon}\" title=\"${chat.title}\" width=\"36\" height=\"36\">\n                    <h3 class=\"item-name\">${chat.title}</h3>\n                </header>\n                <div class=\"card-buttons\">\n                    <p style=\"color:${chat.color};font-size:${chat.fSize}px\">\n                        ${chat.msg}</p>\n                </div>\n            </div>`\n            await ChatMessage.create({ content: chatCard });\n            break;\n        default:\n            errorMsg`Icky Poo Poo!  Parameter passed was neither a string nor object (${typeOfParm})`\n            jez.log(errorMsg, msgParm)\n            ui.notifications.error(errorMsg)\n    }\n    await jez.wait(100);\n    await ui.chat.scrollBottom();\n    jez.log(`--------------${FUNCNAME}-----------`, \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n    return;\n}",
  "flags": {
    "combat-utility-belt": {
      "macroTrigger": ""
    },
    "advanced-macros": {
      "runAsGM": false
    },
    "exportSource": {
      "world": "travels-in-barovia",
      "system": "dnd5e",
      "coreVersion": "9.269",
      "systemVersion": "1.6.0"
    }
  }
}