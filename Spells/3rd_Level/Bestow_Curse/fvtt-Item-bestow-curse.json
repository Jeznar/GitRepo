{
  "name": "Bestow Curse",
  "type": "spell",
  "img": "Icons_JGB/Misc/curse.png",
  "data": {
    "description": {
      "value": "<p>You touch a creature, and that creature must succeed on a Wisdom saving throw or become cursed for the duration of the spell. When you cast this spell, choose the nature of the curse from the following options:</p>\n<ul>\n<li><strong>Ineptitude: </strong>Choose one ability score. While cursed, the target has disadvantage on ability checks and saving throws made with that ability score.</li>\n<li><strong>Aversion: </strong>While cursed, the target has disadvantage on attack rolls against you.</li>\n<li><strong>Lethergy:</strong> While cursed, the target must make a Wisdom saving throw at the start of each of its turns. If it fails, it wastes its action that turn doing nothing.</li>\n<li><strong>Vulnerability: </strong>While the target is cursed, your attacks and spells deal an extra 1d8 necrotic damage to the target.&nbsp;<strong>Foundry VTT: @Item[p2uPVOtv8QXdKbl5]{Bestow Curse Damage}</strong></li>\n</ul>\n<p>A remove curse&nbsp;spell ends this effect. At the DM's option, you may choose an alternative curse effect, but it should be no more powerful than those described above. The DM has final say on such a curse's effect.</p>\n<p><em><strong>At Higher Levels.</strong></em> If you cast this spell using a spell slot of 4th level or higher, the duration is concentration, up to 10 minutes. If you use a spell slot of 5th level or higher, the duration is 8 hours. If you use a spell slot of 7th level or higher, the duration is 24 hours. If you use a 9th level spell slot, the spell lasts until it is dispelled. Using a spell slot of 5th level or higher grants a duration that doesn't require concentration.</p>\n<hr />\n<p><strong>FoundryVTT:</strong> This is automated.</p>",
      "chat": "<p>You touch a creature, and that creature must succeed on a Wisdom saving throw or become cursed for the duration of the spell. When you cast this spell, choose the nature of the curse from the following options:</p>\n<ul>\n<li>Choose one ability score. While cursed, the target has disadvantage on ability checks and saving throws made with that ability score.</li>\n<li>While cursed, the target has disadvantage on attack rolls against you.</li>\n<li>While cursed, the target must make a Wisdom saving throw at the start of each of its turns. If it fails, it wastes its action that turn doing nothing.</li>\n<li>While the target is cursed, your attacks and spells deal an extra 1d8 necrotic damage to the target.</li>\n</ul>\n<p>A remove curseÂ spell ends this effect. At the DM's option, you may choose an alternative curse effect, but it should be no more powerful than those described above. The DM has final say on such a curse's effect.</p>\n<p><em><strong>At Higher Levels.</strong></em> If you cast this spell using a spell slot of 4th level or higher, the duration is concentration, up to 10 minutes. If you use a spell slot of 5th level or higher, the duration is 8 hours. If you use a spell slot of 7th level or higher, the duration is 24 hours. If you use a 9th level spell slot, the spell lasts until it is dispelled. Using a spell slot of 5th level or higher grants a duration that doesn't require concentration.</p>",
      "unidentified": ""
    },
    "source": "Basic Rules, Player's Handbook pg 218",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": "Concentration"
    },
    "duration": {
      "value": 1,
      "units": "minute"
    },
    "target": {
      "value": null,
      "width": null,
      "units": "touch",
      "type": "creature"
    },
    "range": {
      "value": null,
      "long": null,
      "units": "touch"
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "save",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": null
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "wis",
      "dc": null,
      "scaling": "spell"
    },
    "level": 3,
    "school": "nec",
    "components": {
      "value": "",
      "vocal": true,
      "somatic": true,
      "material": false,
      "ritual": false,
      "concentration": true
    },
    "materials": {
      "value": "",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "prepared",
      "prepared": true
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    },
    "attunement": null
  },
  "effects": [
    {
      "_id": "vADZd5uo4Zi3puAy",
      "changes": [
        {
          "key": "macro.itemMacro",
          "mode": 0,
          "value": "0",
          "priority": "20"
        }
      ],
      "disabled": false,
      "duration": {
        "startTime": null
      },
      "icon": "Icons_JGB/Misc/curse.png",
      "label": "Cursed",
      "transfer": false,
      "flags": {
        "dae": {
          "stackable": "none",
          "macroRepeat": "startEveryTurn",
          "specialDuration": [],
          "transfer": false
        },
        "dnd5e-helpers": {
          "rest-effect": "Ignore"
        },
        "ActiveAuras": {
          "isAura": false,
          "aura": "None",
          "radius": null,
          "alignment": "",
          "type": "",
          "ignoreSelf": false,
          "height": false,
          "hidden": false,
          "hostile": false,
          "onlyOnce": false
        }
      },
      "tint": null,
      "selectedKey": "macro.itemMacro"
    }
  ],
  "flags": {
    "ddbimporter": {
      "id": 136112,
      "definitionId": 2013,
      "entityTypeId": 435869154,
      "dndbeyond": {
        "lookup": "generic",
        "lookupName": "generic",
        "level": null,
        "castAtLevel": null
      },
      "sources": [
        {
          "sourceId": 1,
          "pageNumber": null,
          "sourceType": 2
        },
        {
          "sourceId": 2,
          "pageNumber": 218,
          "sourceType": 1
        }
      ],
      "tags": [
        "Debuff"
      ]
    },
    "betterRolls5e": {
      "quickVersatile": {
        "altValue": true
      },
      "quickCharges": {
        "value": {
          "use": true,
          "resource": true
        },
        "altValue": {
          "use": true,
          "resource": true
        }
      }
    },
    "cf": {
      "id": "temp_edz3xuutj1n"
    },
    "core": {
      "sourceId": "Compendium.My-Shared-DDB.spells.lw5YXzdErYC2Y7t4"
    },
    "enhancedcombathud": {
      "set1p": false,
      "set2p": false,
      "set3p": false
    },
    "midi-qol": {
      "onUseMacroName": "[postActiveEffects]ItemMacro",
      "effectActivation": false
    },
    "betterCurses": {
      "isCurse": true,
      "curseName": "BestowCurse",
      "formula": "1d8",
      "mwak": true,
      "rwak": true,
      "msak": true,
      "rsak": true
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Bestow Curse",
          "type": "script",
          "author": "ZjFlOWYxZjM5ZTZj",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const MACRONAME = \"Bestow_Curse.1.6.js\";\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Implemention of Bestow Curse.\n * \n * Description: long....go read it elsewhere.  The suggested afllictions, and importantly \n * the name I am giving each are:\n * \n * Ineptitude    - The afflicted has disadvantage on ability checks and saving throws made \n *                 with a caster selected ability score.\n * Aversion      - The afflicted has disadvantage on attack rolls against caster.\n * Lethergy      - The afflicted must make a Wisdom saving throw at the start of each of its \n *                 turns. If it fails, it wastes its action that turn, doing nothing.\n * Vulnerability - Caster's attacks deal an extra 1d8 necrotic damage to the target.\n * Other         - Some other effect agreed on by player and GM\n * \n * This is my attempt to implement this with a DAE itemm macro.\n * \n * 12/16/21 0.1 Creation and basic application of curse\n * 12/16/21 0.2 Addition of curse selection menu to the doOn function and Ineptitude \n *              automation\n * 12/16/21 0.3 Work with AE Flag setting to manage removal of bonus buff\n * 12/16/21 0.4 Add doEach to implment the saving through at the start of each round.\n * 12/17/21 0.6 Jon Replaced if statements with ternary statements and created the if (TL > 1) jez.trace(`${TAG} ) function.\n * 12/17/21 0.7 Jon Adding Vulnerability logic.\n * 12/18/21 0.8 JGB Replaced all the if(DEBUG) console.log calls with log function \n * 12/18/21 0.9 JGB Work on a damageonlyworkflow for curse of vulnerability\n * 12/19/21 1.0 JGB Cleanups\n * 12/21/21 1.1 JGB Reshuffling looking for aItem not defined error\n * 12/21/21 1.2 JGB Combine nearly redundent selection functions\n * 05/02/22 1.3 JGB Update for Foundry 9.x\n * 05/05/22 1.4 JGB change createEmbeddedEntity to createEmbeddedDocuments for 9.x\n * 07/29/22 1.5 JGB Added Convenient Description and fixed logic error in Vulnerabilty \n * 12/17/22 1.6 JGB Update logging and general style\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nconst MACRO = MACRONAME.split(\".\")[0]       // Trim off the version number and extension\nconst TAG = `${MACRO} |`\nconst TL = 0;                               // Trace Level for this macro\nlet msg = \"\";                               // Global message string\n//-----------------------------------------------------------------------------------------------------------------------------------\nif (TL > 0) jez.trace(`${TAG} === Starting ===`);\nif (TL > 1) for (let i = 0; i < args.length; i++) jez.trace(`  args[${i}]`, args[i]);\n//-----------------------------------------------------------------------------------------------------------------------------------\n// Set standard variables\n//\nconst L_ARG = args[args.length - 1]; // See https://gitlab.com/tposney/dae#lastarg for contents\nlet aToken = (L_ARG.tokenId) ? canvas.tokens.get(L_ARG.tokenId) : game.actors.get(L_ARG.tokenId)\nlet aActor = aToken.actor;\nlet tactor = aActor\nlet aItem = (args[0]?.item) ? args[0]?.item : L_ARG.efData?.flags?.dae?.itemData\n// let tactor = (L_ARG.tokenId) ? canvas.tokens.get(LAST_ARG.tokenId).actor : game.actors.get(LAST_ARG.actorId);\nconst VERSION = Math.floor(game.VERSION);\nconst GAME_RND = game.combat ? game.combat.round : 0;\n//-----------------------------------------------------------------------------------------------------------------------------------\n// Set Macro specific globals\n//\nconst CURSENAME = \"BestowCurse\";\nconst CONDITION = \"Cursed\";\nconst ICON = \"Icons_JGB/Misc/curse.png\";\nconst NOACTIONSICON = \"Icons_JGB/Misc/Stop_Sign.png\";\nconst SAVE_DC = args[0]?.item?.data?.save?.dc\nconst CurseofLethergy = \"Curse of Lethergy\";\nconst CurseofIneptitude = \"Curse of Ineptitude\"\n//-----------------------------------------------------------------------------------------------------------------------------------\n// Run the main procedures, choosing based on how the macro was invoked\n//\nif (args[0]?.tag === \"OnUse\") await doOnUse({ traceLvl: TL });          // Midi ItemMacro On Use\nif (args[0] === \"each\") doEach({ traceLvl: TL });\t\t\t\t\t     // DAE everyround\nif (args[0] === \"off\") await doOff({ traceLvl: TL });                   // DAE removal\n// DamageBonus must return a function to the caller\nif (args[0]?.tag === \"DamageBonus\") return (doBonusDamage({ traceLvl: TL }));\nif (TL > 1) jez.trace(`${TAG} === Finished ===`);\nreturn;\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ***********************************************************************************************************************************\n * Check the setup of things.  Post bad message and return false fr bad, true for ok!\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function preCheck() {\n    if (args[0].targets.length !== 1)\n        return jez.badNews(`Must target exactly one target.  ${args[0]?.targets?.length} were targeted.`, 'w')\n    return true\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Post results to the chat card\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nfunction postResults(msg) {\n    const FUNCNAME = \"postResults(msg)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL > 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 2) jez.trace(\"postResults Parameters\", \"msg\", msg)\n    //-------------------------------------------------------------------------------------------------------------------------------\n    let chatMsg = game.messages.get(args[args.length - 1].itemCardId);\n    jez.addMessage(chatMsg, { color: jez.randomDarkColor(), fSize: 14, msg: msg, tag: \"saves\" });\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Perform the code that runs when this macro is invoked as an ItemMacro \"OnUse\"\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function doOnUse(options = {}) {\n    const FUNCNAME = \"doOnUse(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    await jez.wait(100)\n    //-------------------------------------------------------------------------------------------------------------------------------\n    if (!await preCheck()) return (false);\n    let tToken = canvas.tokens.get(args[0]?.targets[0]?.id); // First Targeted Token, if any\n    let tActor = tToken?.actor;\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Make sure target failed its saving throw\n    //\n    if (args[0].failedSaves.length !== 1) {\n        msg = `${tToken.name} made save, spell has no effect`;\n        postResults(msg);\n        return;\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Select the curse to apply\n    //\n    const queryTitle = \"Select Specific Curse to be Applied\"\n    const queryText = \"Pick one from drop down list\"\n    //pickCurse(queryTitle, queryText, pickCurseCallBack,\n    pickFromList(queryTitle, queryText, pickCurseCallBack,\n        \"Ineptitude - Disadvantage on one stat's ability checks and saves\",\n        \"Aversion - Disadvantage on attack rolls against caster.\",\n        \"Lethergy - Wisdom save or waste each turn.\",\n        \"Vulnerability - Caster's attacks deal an extra damage\",\n        \"Other - Other effect agreed on by player and GM\");\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Set a flag with the saveDC for later use\n    //\n    if (TL > 1) jez.trace(`${TAG} aItem`, aItem);\n    const saveDC = aItem.data.save.dc\n    if (TL > 1) jez.trace(`${TAG} saveDC`, saveDC);\n\n    await DAE.setFlag(tToken.actor, `${MACRO}.saveDC`, saveDC);\n    await DAE.setFlag(tToken.actor, `${MACRO}.curseItemD`, aItem);\n    if (TL > 1) jez.trace(`${TAG} Set DAE flags on ${tToken.actor.name}`,\n        `${MACRO}.saveDC`, saveDC,\n        `${MACRO}.curseItemD`, aItem);\n\n    if (TL > 1) jez.trace(`${TAG} ---------------------------------------------------------------------------`,\n        `Finished`, `${MACRONAME} ${FUNCNAME}`);\n    return;\n}\n/****************************************************************************************\n * Execute code for a DAE Macro removal (off)\n ***************************************************************************************/\nasync function doOff(options = {}) {\n    const FUNCNAME = \"doOff(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    //\n    let afflictedToken = canvas.tokens.get(args[1]);\n    if (TL > 1) jez.trace(`${TAG} ---------------------------------------------------------------------------`,\n        \"Starting\", `${MACRONAME} ${FUNCNAME}`,\n        \"afflictedToken\", afflictedToken,\n        \"tactor\", tactor);\n    for (let i = 0; i < args.length; i++) if (TL > 1) jez.trace(`${TAG}   args[${i}]`, args[i]);\n\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Check for existance of flags, log the values, and delete them.\n    //\n    let secondDebuff = DAE.getFlag(tactor, `${MACRO}.SecondDebuff`);\n    let saveDC = DAE.getFlag(tactor, `${MACRO}.SecondDebuff`);\n    let curseItemD = DAE.getFlag(tactor, `${MACRO}.SecondDebuff`);\n    if (TL > 1) jez.trace(`${TAG} #### Flags Set and Values ####`,\n        \"secondDebuff\", secondDebuff,\n        \"saveDC\", saveDC,\n        \"curseItemD\", curseItemD);\n    await DAE.unsetFlag(tactor, `${MACRO}.SecondDebuff`);\n    await DAE.unsetFlag(tactor, `${MACRO}.saveDC`);\n    await DAE.unsetFlag(tactor, `${MACRO}.curseItemD`);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Check for debuff matching the flag.  If it exists, remove it.\n    //\n    let secondDebuffEffect = tactor.effects\n        .find(ef => ef.data.label === secondDebuff) ?? null; // Added a null case.\n    if (secondDebuffEffect) {\n        let message = `${tactor.name} has ${secondDebuff} effect: `;\n        if (TL > 1) jez.trace(`${TAG} ${message}`, secondDebuffEffect);\n        await secondDebuffEffect.delete();\n    } else {\n        let message = `${tactor.name} lacks ${secondDebuff} effect.`;\n        if (TL > 1) jez.trace(`${TAG} ${message}`);\n    }\n\n    if (TL > 1) jez.trace(`${TAG} ---------------------------------------------------------------------------`,\n        `Finished`, `${MACRONAME} ${FUNCNAME}`);\n    return;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Perform the code that runs when this macro is invoked each round by DAE\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function doEach(options = {}) {\n    const FUNCNAME = \"doEach(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Comments, perhaps\n    //\n    let secondDebuff = DAE.getFlag(tactor, `${MACRO}.SecondDebuff`);\n    if (TL > 1) jez.trace(`${TAG} ### secondDebuff: `, secondDebuff);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    if (secondDebuff === CurseofLethergy) {\n        let abilitySave = \"wis\";     // Set appropriate stat for save\n        let saveDC = DAE.getFlag(tactor, `${MACRO}.saveDC`);\n        if (TL > 1) jez.trace(`${TAG} ### saveDC = ${saveDC}`);\n        //---------------------------------------------------------------------------------------------------------------------------\n        let save = await tactor.rollAbilitySave(abilitySave, {\n            // Does not return item card. TODO: Look into Crymic Macros for Midi Save.\n            chatMessage: true,\n            fastForward: true,\n            flavor: `Wisdom save vs <b>DC${saveDC}</b>.<br>\n            On failure, ${tactor.name} takes no actions this round.`\n        });\n        if (TL > 1) jez.trace(`${TAG} Result of save`, save);\n        //---------------------------------------------------------------------------------------------------------------------------\n        save.flavor = \"new message\"\n        if (save.total >= saveDC) { // TODO Update flavor text, based on result of save\n            msg = `${tactor.name} made its save.  Rolling ${save.total} vs ${saveDC} DC.`;\n        }\n        else {\n            msg = `${tactor.name} failed its save.  Rolling ${save.total} vs ${saveDC} DC.`;\n            //-----------------------------------------------------------------------------------------------------------------------\n            // Slap a 1 turn duration \"No Actions\" condition on the token -- \n            // TODO: Does not stick, flashes and vanishes\n            //\n            let GAME_RND = game.combat ? game.combat.round : 0;\n            let effectData = {\n                label: \"No_Actions\",\n                icon: NOACTIONSICON,\n                origin: tactor.uuid,\n                disabled: false,\n                duration: { rounds: 2, turns: 2, startRound: GAME_RND, seconds: 12, startTime: game.time.worldTime },\n                flags: {\n                    dae: { macroRepeat: \"none\", specialDuration: [\"turnStart\"] },\n                    convenientDescription: `No Actions or Bonus Actions (Reactions allowed)`\n                },\n            };\n            //-----------------------------------------------------------------------------------------------------------------------\n            // Apply the debuff\n            //\n            await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: tactor.uuid, effects: [effectData] });\n            if (TL > 1) jez.trace(`${TAG} applied \"No Actions\" Debuff: `, effectData);\n            msg = `Curses! No actions this turn!`\n            bubbleForAll(aToken.id, msg, true, true)\n            await jez.wait(10);\n        }\n\n        if (TL > 1) jez.trace(`${TAG} ${msg}; save roll`, save);\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    if (secondDebuff === 'Curse of Aversion') {\n        msg = `Curses! I have disadvantage on attack against my tormentor. (not automated)`\n        bubbleForAll(aToken.id, msg, true, true)\n        await jez.wait(10);\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    if (secondDebuff === 'Curse of Vulnerability') {\n        msg = `Curses! That witch knows just how to hurt me.`\n        bubbleForAll(aToken.id, msg, true, true)\n        await jez.wait(10);\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    if (secondDebuff.includes(\"Curse of Ineptitude\")) {\n        const STAT = secondDebuff.split(\"(\")[1].slice(0, -1)\n        msg = `Curses! I feel inept when I try to use my ${STAT}!`\n        bubbleForAll(aToken.id, msg, true, true)\n        await jez.wait(10);\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n    return;\n}\n\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Create and process selection dialog, passing it onto specified callback function\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nfunction pickFromList(queryTitle, queryText, pickCallBack, ...queryOptions) {\n    const FUNCNAME = \"doOff(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, `queryTitle  `, queryTitle, `queryText   `, queryText,\n        `pickCallBack`, pickCallBack, `queryOptions`, queryOptions);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (typeof (pickCallBack) != \"function\") {\n        let msg = `pickFromList given invalid pickCallBack, it is a ${typeof (pickCallBack)}`\n        ui.notifications.error(msg);\n        if (TL > 1) jez.trace(`${TAG} ${msg}`);\n        return\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (!queryTitle || !queryText || !queryOptions) {\n        let msg = `pickFromList arguments should be (queryTitle, queryText, pickCallBack, ...queryOptions),\n                   but yours are: ${queryTitle}, ${queryText}, ${pickCallBack}, ${queryOptions}`;\n        ui.notifications.error(msg);\n        if (TL > 1) jez.trace(`${TAG} ${msg}`);\n        return\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    let template = `\n    <div>\n    <div class=\"form-group\">\n        <label>${queryText}</label>\n        <select id=\"selectedOption\">`\n    for (let option of queryOptions) {\n        template += `<option value=\"${option}\">${option}</option>`\n    }\n    template += `</select>\n    </div></div>`\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    new Dialog({\n        title: queryTitle,\n        content: template,\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: 'OK',\n                callback: async (html) => {\n                    const selectedOption = html.find('#selectedOption')[0].value\n                    if (TL > 1) jez.trace(`${TAG} selected option`, selectedOption)\n                    pickCallBack(selectedOption)\n                },\n            },\n            cancel: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: 'Cancel',\n                callback: async (html) => {\n                    if (TL > 1) jez.trace(`${TAG} canceled`)\n                    pickCallBack(null)\n                },\n            },\n        },\n        default: 'cancel',\n    }).render(true)\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n    return;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Receive selected Curse and continue main steps\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function pickCurseCallBack(selection) {\n    const FUNCNAME = \"pickCurseCallBack(selection)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, `selection`, selection);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    // let aItem = args[0]?.item;\n    let curseName = selection?.split(\" \")[0]     // Grab first word of the selection\n    let curseDiscription = \"\";\n    let level = args[0].spellLevel;\n    const rounds = level === 3 ? 10 : level === 4 ? 100 : level === 5 ? 800 : level === 6 ? 800 : 9999999;\n    const seconds = rounds * 6;\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    switch (curseName) {\n        case \"Ineptitude\":\n            curseDiscription = `<b>Curse of ${curseName}</b>: The afflicted has disadvantage on \n                ability checks and saving throws made with a caster selected ability score.`;\n            postResults(curseDiscription);\n            const queryTitle = \"Select Stat to be Afflicted\"\n            const queryText = \"Pick one from drop down list\"\n            //pickStat(queryTitle, queryText, \n            pickFromList(queryTitle, queryText, pickStatCallBack,\n                \"Strength\", \"Dexterity\", \"Constitution\", \"Intelligence\", \"Wisdom\", \"Charisma\");\n            break;\n        case \"Aversion\":\n            curseDiscription = `<b>Curse of ${curseName}</b>: The afflicted has disadvantage on \n            attack rolls against caster.\n            <br><br><b>FoundryVTT</b>: This should be handled manually.`\n            postResults(curseDiscription);\n            applyCurseStub(curseName);\n            break;\n        case \"Lethergy\":\n            curseDiscription = `<b>Curse of ${curseName}</b>: The afflicted must make a \n                <b>Wisdom save</b> against <b>DC${aItem.data.save.dc}</b> at the start of each \n                of its turns. If it fails, it wastes its action that turn, doing nothing.`\n            postResults(curseDiscription);\n            applyCurseStub(curseName);\n            break;\n        case \"Vulnerability\":\n            curseDiscription = `<b>Curse of ${curseName}</b>: Caster's attacks deal an extra \n                1d8 necrotic damage to the target.`\n            postResults(curseDiscription);\n            applyCurseStub(curseName);\n            bonusDamage(canvas.tokens.get(args[0].targets[0].id), aItem, args[0].uuid,\n                canvas.tokens.get(args[0].tokenId), game.actors.get(args[0].actor._id),\n                rounds, seconds, GAME_RND)\n            break;\n        case \"Other\":\n            curseDiscription = `<b>Curse of ${curseName}</b>: Some other effect agreed on \n            by player and GM. <br><br><b>FoundryVTT</b>: This should be handled manually.`\n            postResults(curseDiscription);\n            applyCurseStub(curseName);\n            break;\n        default:\n            curseDiscription = `Unfortunately, this is an undefined condition.`\n            postResults(curseDiscription);\n            break;\n    }\n    if (TL > 1) jez.trace(`${TAG} ${curseName} description: ${curseDiscription}`);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n    return;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Receive selected stat and continue main steps.  This is only used by Curse of Lethergy\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function pickStatCallBack(selection) {\n    const FUNCNAME = \"pickCurseCallBack(selection)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, `selection`, selection);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    let player = canvas.tokens.get(args[0]?.tokenId);\n    let tToken = canvas.tokens.get(args[0]?.targets[0]?.id);\n    let stat = \"\";\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Add cursed condition to target\n    //\n    switch (selection) {\n        case \"Strength\": stat = \"str\"; break;\n        case \"Dexterity\": stat = \"dex\"; break;\n        case \"Constitution\": stat = \"con\"; break;\n        case \"Intelligence\": stat = \"int\"; break;\n        case \"Wisdom\": stat = \"wis\"; break;\n        case \"Charisma\": stat = \"cha\"; break;\n        default: stat = \"XYZ\"; break;\n    }\n    if (TL > 1) jez.trace(`${TAG} Short Stat Name`, stat);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    const secondDebuff = `${CurseofIneptitude} (${selection})`\n    let effectData = {\n        label: secondDebuff,\n        icon: ICON,\n        origin: player.actor.uuid,\n        disabled: false,\n        duration: { rounds: 99, startRound: GAME_RND },\n        flags: { convenientDescription: `${selection} ability checks and saves at disadvantage` },\n        changes: [\n            { key: `flags.midi-qol.disadvantage.ability.check.${stat}`, mode: jez.ADD, value: 1, priority: 20 },\n            { key: `flags.midi-qol.disadvantage.ability.save.${stat}`, mode: jez.ADD, value: 1, priority: 20 },\n        ]\n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: tToken.actor.uuid, effects: [effectData] });\n    await DAE.setFlag(tToken.actor, `${MACRO}.SecondDebuff`, secondDebuff);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n    return;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Apply a stub effect with just the name of the effect for curse that are not automated\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function applyCurseStub(curseName) {\n    const FUNCNAME = \"applyCurseStub(curseName)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, `curseName`, curseName);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    let player = canvas.tokens.get(args[0]?.tokenId);\n    let tToken = canvas.tokens.get(args[0]?.targets[0]?.id);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Set the convenientDescription value based on curseName\n    //\n    let ceDesc = \"\"\n    switch (curseName) {\n        case \"Aversion\": ceDesc = `Disadvantage on attack rolls against ${aToken.name} (not automated)`; break;\n        case \"Lethergy\": ceDesc = `DC${SAVE_DC} WIS Save or No Actions each turn`; break;\n        case \"Vulnerability\": ceDesc = `${aToken.name}'s attacks deal an extra 1d8 necrotic damage`; break;\n        default: ceDesc = `Some other effect agreed on by player and GM`; break;\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Add cursed condition to target\n    //\n    const secondDebuff = `Curse of ${curseName}`\n    let effectData = {\n        label: secondDebuff,\n        icon: ICON,\n        origin: player.actor.uuid,\n        disabled: false,\n        duration: { rounds: 999999, startRound: GAME_RND },\n        flags: { convenientDescription: ceDesc },\n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: tToken.actor.uuid, effects: [effectData] });\n    await DAE.setFlag(tToken.actor, `${MACRO}.SecondDebuff`, secondDebuff);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Post the results to chat card\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function postResults(resultsString) {\n    const FUNCNAME = \"postResults(resultsString)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, `resultsString`, resultsString);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    // let chatmsg = await game.messages.get(itemCard.id)\n    let chatmsg = game.messages.get(L_ARG.itemCardId);\n    let content = await duplicate(chatmsg.data.content);\n    if (TL > 1) jez.trace(`${TAG} chatmsg: `, chatmsg);\n    const searchString = /<div class=\"end-midi-qol-saves-display\">/g;\n    const replaceString = `<div class=\"end-midi-qol-saves-display\">${resultsString}`;\n    content = await content.replace(searchString, replaceString);\n    await chatmsg.update({ content: content });\n    await ui.chat.scrollBottom();\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n    return;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * BonusDamage: When a target gets the curse of vulnerability, create this effect. \n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function bonusDamage(target, aItem, uuid, tokenD, actorD, rounds, seconds, GAME_RND) {\n    const FUNCNAME = \"bonusDamage(target, aItem, uuid, tokenD, actorD, rounds, seconds, GAME_RND)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"target  \", target, \"aItem   \", aItem, \"uuid    \", uuid,\n        \"tokenD  \", tokenD, \"actorD  \", actorD, \"rounds  \", rounds, \"seconds \", seconds, \"GAME_RND\", GAME_RND);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Define and add the curse effect to caster\n    //        \n    let effectData = {\n        label: aItem.name,\n        icon: ICON,\n        origin: uuid,\n        disabled: false,\n        duration: { rounds: rounds, seconds: seconds, startRound: GAME_RND, startTime: game.time.worldTime },\n        flags: { dae: { itemData: aItem } },\n        changes: [\n            { key: \"flags.midi-qol.hexMark\", mode: jez.OVERRIDE, value: target.id, priority: 20 },\n            { key: \"flags.dnd5e.DamageBonusMacro\", mode: jez.CUSTOM, value: `ItemMacro.${aItem.name}`, priority: 20 },\n            { key: \"flags.midi-qol.concentration-data.targets\", mode: jez.ADD, value: { \"actorId\": actorD.id, \"tokenId\": tokenD.id }, priority: 20 }\n        ]\n    };\n    // await actorD.createEmbeddedEntity(\"ActiveEffect\", effectData); // Depricated \n    await actorD.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Apply the Bonus Damage for Curse of Vulnerability\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nfunction doBonusDamage(options = {}) {\n    const FUNCNAME = \"doBonusDamage(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Obtain and optionally log a bunch of information for application of damage\n    //  \n    const target = canvas.tokens.get(args[0].targets[0].id);\n    const actorD = game.actors.get(args[0].actor._id);\n    const tokenD = canvas.tokens.get(args[0].tokenId);\n    const aItem = args[0].item; // Needed to determine if invoking effect is am attack\n    let curseItemD = DAE.getFlag(target.actor, `${MACRO}.curseItemD`);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    if (TL > 1) jez.trace(`${TAG} Obtained values for function`,\n        \"target\", target, \"target.name\", target.name,\n        // \"actorD\", actorD, \"actorD.name\", actorD.name, \n        \"tokenD\", tokenD, \"tokenD.name\", tokenD.name,\n        \"aItem\", aItem, \"aItem.name\", aItem.name,\n        \"curseItemD\", curseItemD);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Make sure the actor has midi-qol.hexmark which is being hijacked for this macro\n    //   \n    if (target.id !== getProperty(tokenD.actor.data.flags, \"midi-qol.hexMark\")) {\n        if (TL > 1) jez.trace(`${TAG} Should not get here?`, 'target.id', target.id,\n            \"tokenD.actor.data.flags\", tokenD.actor.data.flags,\n            'getProperty(tokenD.actor.data.flags, \"midi-qol.hexMark\")',\n            getProperty(tokenD.actor.data.flags, \"midi-qol.hexMark\"));\n        return {};\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Replace the image for the curse with ICON\n    //      \n    curseItemD.img = ICON;\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Was the action that invoked this an attack (mwak, msak, rwak, rsak)?  If it \n    // wasn't just return without extra damage.\n    //  \n    let action = aItem.data.actionType;\n    if ((action === \"mwak\") || (action === \"msak\") ||\n        (action === \"rwak\") || (action === \"rsak\")) {\n        if (TL > 1) jez.trace(`${TAG} Action type is an attack!  Damage to be done.`, action);\n    } else {\n        if (TL > 1) jez.trace(`${TAG} + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +`,\n            \"Action type is not an attack. :(  No damage.\", action,\n            `Early Exit`, `${MACRONAME} ${FUNCNAME}`);\n        return {};\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Time to actually do some damage!\n    //  \n    let damageRoll = new Roll(`1d8`).evaluate({ async: false });\n    if (TL > 1) jez.trace(`${TAG}  damageRoll`, damageRoll, \" Damage Total\", damageRoll.total);\n    game.dice3d?.showForRoll(damageRoll);\n\n    new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, 'necrotic',\n        [target], damageRoll, {\n        flavor: `<b>${target.name}</b> suffers further from <b>${actorD.name}</b>'s Curse of <b>Vulnerability</b>`,\n        itemData: curseItemD,\n        itemCardId: \"new\"\n    });\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "exportSource": {
      "world": "travels-in-barovia-ce",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.2"
    }
  }
}