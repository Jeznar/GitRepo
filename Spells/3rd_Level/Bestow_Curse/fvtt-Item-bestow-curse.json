{
  "name": "Bestow Curse",
  "type": "spell",
  "img": "Icons_JGB/Misc/curse.png",
  "data": {
    "description": {
      "value": "<p>You touch a creature, and that creature must succeed on a Wisdom saving throw or become cursed for the duration of the spell. When you cast this spell, choose the nature of the curse from the following options:</p>\n<ul>\n<li><strong>Ineptitude: </strong>Choose one ability score. While cursed, the target has disadvantage on ability checks and saving throws made with that ability score.</li>\n<li><strong>Aversion: </strong>While cursed, the target has disadvantage on attack rolls against you.</li>\n<li><strong>Lethergy:</strong> While cursed, the target must make a Wisdom saving throw at the start of each of its turns. If it fails, it wastes its action that turn doing nothing.</li>\n<li><strong>Vulnerability: </strong>While the target is cursed, your attacks and spells deal an extra 1d8 necrotic damage to the target. <strong>Foundry VTT: @Item[p2uPVOtv8QXdKbl5]{Bestow Curse Damage}</strong></li>\n</ul>\n<p>A remove curse spell ends this effect. At the DM's option, you may choose an alternative curse effect, but it should be no more powerful than those described above. The DM has final say on such a curse's effect.</p>\n<p><em><strong>At Higher Levels.</strong></em> If you cast this spell using a spell slot of 4th level or higher, the duration is concentration, up to 10 minutes. If you use a spell slot of 5th level or higher, the duration is 8 hours. If you use a spell slot of 7th level or higher, the duration is 24 hours. If you use a 9th level spell slot, the spell lasts until it is dispelled. Using a spell slot of 5th level or higher grants a duration that doesn't require concentration.</p>",
      "chat": "<p>You touch a creature, and that creature must succeed on a Wisdom saving throw or become cursed for the duration of the spell. When you cast this spell, choose the nature of the curse from the following options:</p>\n<ul>\n<li>Choose one ability score. While cursed, the target has disadvantage on ability checks and saving throws made with that ability score.</li>\n<li>While cursed, the target has disadvantage on attack rolls against you.</li>\n<li>While cursed, the target must make a Wisdom saving throw at the start of each of its turns. If it fails, it wastes its action that turn doing nothing.</li>\n<li>While the target is cursed, your attacks and spells deal an extra 1d8 necrotic damage to the target.</li>\n</ul>\n<p>A remove curse spell ends this effect. At the DM's option, you may choose an alternative curse effect, but it should be no more powerful than those described above. The DM has final say on such a curse's effect.</p>\n<p><em><strong>At Higher Levels.</strong></em> If you cast this spell using a spell slot of 4th level or higher, the duration is concentration, up to 10 minutes. If you use a spell slot of 5th level or higher, the duration is 8 hours. If you use a spell slot of 7th level or higher, the duration is 24 hours. If you use a 9th level spell slot, the spell lasts until it is dispelled. Using a spell slot of 5th level or higher grants a duration that doesn't require concentration.</p>",
      "unidentified": ""
    },
    "source": "Basic Rules, Player's Handbook pg 218",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": "Concentration"
    },
    "duration": {
      "value": 1,
      "units": "minute"
    },
    "target": {
      "value": null,
      "width": null,
      "units": "touch",
      "type": ""
    },
    "range": {
      "value": null,
      "long": null,
      "units": "touch"
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "save",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": null
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "wis",
      "dc": null,
      "scaling": "spell"
    },
    "level": 3,
    "school": "nec",
    "components": {
      "value": "",
      "vocal": true,
      "somatic": true,
      "material": false,
      "ritual": false,
      "concentration": true
    },
    "materials": {
      "value": "",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "prepared",
      "prepared": true
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    },
    "attunement": null
  },
  "effects": [
    {
      "_id": "vADZd5uo4Zi3puAy",
      "changes": [
        {
          "key": "macro.itemMacro",
          "mode": 0,
          "value": "0",
          "priority": "20"
        }
      ],
      "disabled": false,
      "duration": {
        "startTime": null
      },
      "icon": "Icons_JGB/Misc/curse.png",
      "label": "Cursed",
      "transfer": false,
      "flags": {
        "dae": {
          "stackable": "none",
          "macroRepeat": "startEveryTurn",
          "specialDuration": [],
          "transfer": false
        },
        "dnd5e-helpers": {
          "rest-effect": "Ignore"
        },
        "ActiveAuras": {
          "isAura": false,
          "aura": "None",
          "radius": null,
          "alignment": "",
          "type": "",
          "ignoreSelf": false,
          "height": false,
          "hidden": false,
          "hostile": false,
          "onlyOnce": false
        }
      },
      "tint": null,
      "selectedKey": "macro.itemMacro"
    }
  ],
  "flags": {
    "ddbimporter": {
      "id": 136112,
      "definitionId": 2013,
      "entityTypeId": 435869154,
      "dndbeyond": {
        "lookup": "generic",
        "lookupName": "generic",
        "level": null,
        "castAtLevel": null
      },
      "sources": [
        {
          "sourceId": 1,
          "pageNumber": null,
          "sourceType": 2
        },
        {
          "sourceId": 2,
          "pageNumber": 218,
          "sourceType": 1
        }
      ],
      "tags": [
        "Debuff"
      ]
    },
    "betterRolls5e": {
      "quickVersatile": {
        "altValue": true
      },
      "quickCharges": {
        "value": {
          "use": true,
          "resource": true
        },
        "altValue": {
          "use": true,
          "resource": true
        }
      }
    },
    "cf": {
      "id": "temp_edz3xuutj1n"
    },
    "core": {
      "sourceId": "Compendium.My-Shared-DDB.spells.lw5YXzdErYC2Y7t4"
    },
    "enhancedcombathud": {
      "set1p": false,
      "set2p": false,
      "set3p": false
    },
    "midi-qol": {
      "onUseMacroName": "[postActiveEffects]ItemMacro",
      "effectActivation": false
    },
    "betterCurses": {
      "isCurse": true,
      "curseName": "BestowCurse",
      "formula": "1d8",
      "mwak": true,
      "rwak": true,
      "msak": true,
      "rsak": true
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Bestow Curse",
          "type": "script",
          "author": "ZjFlOWYxZjM5ZTZj",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const MACRONAME = \"Bestow_Curse.1.5.js\";\n/*****************************************************************************************\n * Implemention of Bestow Curse.\n * \n * Description: long....go read it elsewhere.  The suggested afllictions, and importantly \n * the name I am giving each are:\n * \n * Ineptitude    - The afflicted has disadvantage on ability checks and saving throws made \n *                 with a caster selected ability score.\n * Aversion      - The afflicted has disadvantage on attack rolls against caster.\n * Lethergy      - The afflicted must make a Wisdom saving throw at the start of each of its \n *                 turns. If it fails, it wastes its action that turn, doing nothing.\n * Vulnerability - Caster's attacks deal an extra 1d8 necrotic damage to the target.\n * Other         - Some other effect agreed on by player and GM\n * \n * This is my attempt to implement this with a DAE itemm macro.\n * \n * 12/16/21 0.1 Creation and basic application of curse\n * 12/16/21 0.2 Addition of curse selection menu to the doOn function and Ineptitude \n *              automation\n * 12/16/21 0.3 Work with AE Flag setting to manage removal of bonus buff\n * 12/16/21 0.4 Add doEach to implment the saving through at the start of each round.\n * 12/17/21 0.6 Jon Replaced if statements with ternary statements and created the log() function.\n * 12/17/21 0.7 Jon Adding Vulnerability logic.\n * 12/18/21 0.8 JGB Replaced all the if(DEBUG) console.log calls with log function \n * 12/18/21 0.9 JGB Work on a damageonlyworkflow for curse of vulnerability\n * 12/19/21 1.0 JGB Cleanups\n * 12/21/21 1.1 JGB Reshuffling looking for itemD not defined error\n * 12/21/21 1.2 JGB Combine nearly redundent selection functions\n * 05/02/22 1.3 JGB Update for Foundry 9.x\n * 05/05/22 1.4 JGB change createEmbeddedEntity to createEmbeddedDocuments for 9.x\n * 07/29/22 1.5 JGB Added Convenient Description and fixed logic error in Vulnerabilty \n ******************************************************************************************/\nconst DEBUG = true;\nconst CURSENAME = \"BestowCurse\";\nconst CONDITION = \"Cursed\";\nconst ICON = \"Icons_JGB/Misc/curse.png\";\nconst NOACTIONSICON = \"Icons_JGB/Misc/Stop_Sign.png\";\nconst CUSTOM = 0, MULTIPLY = 1, ADD = 2, DOWNGRADE = 3, UPGRADE = 4, OVERRIDE = 5;\nconst MACRO = MACRONAME.split(\".\")[0]     // Trim of the version number and extension\nconst LAST_ARG = args[args.length - 1]; \nconst SAVE_DC = args[0]?.item?.data?.save?.dc\n\n\nconst CurseofLethergy = \"Curse of Lethergy\";\nconst CurseofIneptitude = \"Curse of Ineptitude\"\nlet msg = \"\";\n//---------------------------------------------------------------------------------------------------\n// Set the value for the Active Token (aToken)\nlet aToken;         \nif (LAST_ARG.tokenId) aToken = canvas.tokens.get(LAST_ARG.tokenId); \nelse aToken = game.actors.get(LAST_ARG.tokenId);\nlet aActor = aToken.actor; \n\nlet tactor = (LAST_ARG.tokenId) \n\t? canvas.tokens.get(LAST_ARG.tokenId).actor \n\t: game.actors.get(LAST_ARG.actorId);\n\nlog(\"---------------------------------------------------------------------------\",\n    \"Starting\", MACRONAME,\n    \"Macro\", MACRO,\n    \"Curse\", CURSENAME,\n    \"tactor\", tactor);\nfor (let i = 0; i < args.length; i++) log(`    args[${i}]`, args[i]);\n\nif (args[0]?.tag === \"OnUse\") doOnUse();   \t\t\t    // Midi ItemMacro On Use\n if (args[0] === \"on\") doOn();          \t\t\t    // DAE Application\nif (args[0] === \"off\") doOff();        \t\t\t        // DAE removal\nif (args[0] === \"each\") doEach();\t\t\t\t\t    // DAE removal\nif (args[0]?.tag === \"DamageBonus\") doBonusDamage();    // DAE Damage Bonus\n\nlog(\"---------------------------------------------------------------------------\",\n    \"Finishing\", MACRONAME);\nreturn;\n\n /***************************************************************************************\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ***************************************************************************************/\n/****************************************************************************************\n * Execute code for a ItemMacro onUse\n ***************************************************************************************/\n async function doOnUse() {\n    const FUNCNAME = \"doOnUse()\";\n    log(\"---------------------------------------------------------------------------\",\n        \"Starting\", `${MACRONAME} ${FUNCNAME}`,\n        \"Curse\", CURSENAME);\n    for (let i = 0; i < args.length; i++) log(`  args[${i}]`, args[i]);\n\n    let itemD = args[0]?.item;\n    let targetD = canvas.tokens.get(args[0]?.targets[0]?.id);\n    log(\"Obtained values\", \"itemD\", itemD, \"targetD\", targetD);\n\n    //---------------------------------------------------------------------------------------\n    // Make sure exactly one token was targeted\n    //\n    if (oneTarget()) {\n        log(` one target is targeted (a good thing)`);\n    } else {\n        log(` exception on number of targets selected: ${msg}`);\n        await postResults(msg);\n        log(`Ending ${MACRONAME} ${FUNCNAME}`);\n        return;\n    }\n\n    //---------------------------------------------------------------------------------------\n    // Make sure target failed its saving throw\n    //\n    if (failedCount() === 1) {\n        log(`Target failed save, continue`);\n    } else {\n        log(`Target passed save, exit`);\n        await postResults(\"Target made its saving thow, no effects added\");\n        log(`Ending ${MACRONAME} ${FUNCNAME}`);\n        return;\n    }\n\n    //---------------------------------------------------------------------------------------\n    // Select the curse to apply\n    //\n    const queryTitle = \"Select Specific Curse to be Applied\"\n    const queryText = \"Pick one from drop down list\"\n    //pickCurse(queryTitle, queryText, pickCurseCallBack,\n    pickFromList(queryTitle, queryText, pickCurseCallBack,\n        \"Ineptitude - Disadvantage on one stat's ability checks and saves\",\n        \"Aversion - Disadvantage on attack rolls against caster.\",\n        \"Lethergy - Wisdom save or waste each turn.\",\n        \"Vulnerability - Caster's attacks deal an extra damage\",\n        \"Other - Other effect agreed on by player and GM\");\n\n    //------------------------------------------------------------------------------------\n    // Set a flag with the saveDC for later use\n    //\n    log(\"itemD\", itemD);\n    const saveDC = itemD.data.save.dc\n    log(\"saveDC\", saveDC);\n\n    await DAE.setFlag(targetD.actor, `${MACRO}.saveDC`, saveDC);\n    await DAE.setFlag(targetD.actor, `${MACRO}.curseItemD`, itemD);\n    log(`Set DAE flags on ${targetD.actor.name}`,\n        `${MACRO}.saveDC`, saveDC,\n        `${MACRO}.curseItemD`, itemD);\n\n    log(\"---------------------------------------------------------------------------\",\n        `Finished`, `${MACRONAME} ${FUNCNAME}`);\n    return;\n}\n\n/****************************************************************************************\n * Execute code for a DAE Macro application (on) - nothing other than place holding\n ***************************************************************************************/\n async function doOn() {\n    const FUNCNAME = \"doOn()\";\n    log(\"---------------------------------------------------------------------------\",\n        \"Starting\", `${MACRONAME} ${FUNCNAME}`);\n    for (let i = 0; i < args.length; i++) log(`  args[${i}]`, args[i]);\n\n    log(\"---------------------------------------------------------------------------\",\n        `Finished`, `${MACRONAME} ${FUNCNAME}`);\n    return;\n}\n\n/****************************************************************************************\n * Execute code for a DAE Macro removal (off)\n ***************************************************************************************/\nasync function doOff() {\n    const FUNCNAME = \"doOnOff()\";\n    let afflictedToken = canvas.tokens.get(args[1]);\n\n    log(\"---------------------------------------------------------------------------\",\n        \"Starting\", `${MACRONAME} ${FUNCNAME}`, \n        \"afflictedToken\", afflictedToken, \n        \"tactor\", tactor);  \n    for (let i = 0; i < args.length; i++) log(`  args[${i}]`, args[i]);\n\n    //----------------------------------------------------------------------------------\n    // Check for existance of flags, log the values, and delete them.\n    //\n    let secondDebuff = DAE.getFlag(tactor, `${MACRO}.SecondDebuff`);\n    let saveDC = DAE.getFlag(tactor, `${MACRO}.SecondDebuff`);\n    let curseItemD = DAE.getFlag(tactor, `${MACRO}.SecondDebuff`);\n    log(\"#### Flags Set and Values ####\",\n        \"secondDebuff\", secondDebuff,\n        \"saveDC\", saveDC,\n        \"curseItemD\", curseItemD);\n    await DAE.unsetFlag(tactor, `${MACRO}.SecondDebuff`);\n    await DAE.unsetFlag(tactor, `${MACRO}.saveDC`);\n    await DAE.unsetFlag(tactor, `${MACRO}.curseItemD`); \n\n    //----------------------------------------------------------------------------------\n    // Check for debuff matching the flag.  If it exists, remove it.\n    //\n    let secondDebuffEffect = tactor.effects\n        .find(ef => ef.data.label === secondDebuff) ?? null; // Added a null case.\n    if (secondDebuffEffect) {\n        let message = `${tactor.name} has ${secondDebuff} effect: `;\n        log(message, secondDebuffEffect);\n        await secondDebuffEffect.delete();\n    } else {\n        let message = `${tactor.name} lacks ${secondDebuff} effect.`;\n        log(message);\n    }\n\n    log(\"---------------------------------------------------------------------------\",\n        `Finished`, `${MACRONAME} ${FUNCNAME}`);\n    return;\n}\n\n/****************************************************************************************\n * Execute code for a DAE Macro each time on the target's turn per DAE setting\n ***************************************************************************************/\nasync function doEach() {\n    const FUNCNAME = \"doEach()\";\n    log(\"===========================================================================\",\n        `Starting`, `${MACRONAME} ${FUNCNAME}`, \"tactor\", tactor);\n    for (let i = 0; i < args.length; i++) log(`  args[${i}]`, args[i]);\n\n    let secondDebuff = DAE.getFlag(tactor, `${MACRO}.SecondDebuff`);\n    log(`### secondDebuff: `, secondDebuff);\n\n    if (secondDebuff === CurseofLethergy) {\n        let abilitySave = \"wis\";     // Set appropriate stat for save\n        let saveDC = DAE.getFlag(tactor, `${MACRO}.saveDC`);\n        log(`### saveDC = ${saveDC}`);\n\n        let save = await tactor.rollAbilitySave(abilitySave, {\n            // Does not return item card. TODO: Look into Crymic Macros for Midi Save.\n            chatMessage: true,\n            fastForward: true,\n            flavor: `Wisdom save vs <b>DC${saveDC}</b>.<br>\n            On failure, ${tactor.name} takes no actions this round.`\n        });\n        log('Result of save', save);\n\n    save.flavor = \"new message\"    \n        if (save.total >= saveDC) { // TODO Update flavor text, based on result of save\n            msg = `${tactor.name} made its save.  Rolling ${save.total} vs ${saveDC} DC.`;\n        }\n        else {\n            msg = `${tactor.name} failed its save.  Rolling ${save.total} vs ${saveDC} DC.`;\n            //-------------------------------------------------------------------------------\n            // Slap a 1 turn duration \"No Actions\" condition on the token -- \n            // TODO: Does not stick, flashes and vanishes\n            //\n            let gameRound = game.combat ? game.combat.round : 0;\n            let effectData = {\n                label: \"No_Actions\",\n                icon: NOACTIONSICON,\n                origin: tactor.uuid,\n                disabled: false,\n                duration: { rounds: 2, turns: 2, startRound: gameRound, seconds: 12, startTime: game.time.worldTime },\n                flags: { \n                    dae: { macroRepeat: \"none\", specialDuration: [\"turnStart\"] },\n                    convenientDescription: `No Actions or Bonus Actions (Reactions allowed)`\n                },\n            };\n\n            await MidiQOL.socket().executeAsGM(\"createEffects\",{actorUuid:tactor.uuid, effects: [effectData] });\n            log(`applied \"No Actions\" Debuff: `, effectData);\n            msg = `No actions this turn!`\n            bubbleForAll(aToken.id, msg, true, true)\n            await jez.wait(10);\n        }\n\n        log(msg, \"save roll\", save);\n    }\n    \n    log(\"===========================================================================\",\n        `Ending`, `${MACRONAME} ${FUNCNAME}`);\n\n    return;\n}\n\n/****************************************************************************************\n * Create and process selection dialog, passing it onto specified callback function\n ***************************************************************************************/\n function pickFromList(queryTitle, queryText, pickCallBack, ...queryOptions) {\n    const FUNCNAME = \"pickFromList(queryTitle, queryText, ...queryOptions)\";\n    log(\"---------------------------------------------------------------------------\",\n        `Starting`, `${MACRONAME} ${FUNCNAME}`,\n        `queryTitle`, queryTitle,\n        `queryText`, queryText,\n        `pickCallBack`, pickCallBack,\n        `queryOptions`, queryOptions);\n\n    if (typeof(pickCallBack)!=\"function\" ) {\n        let msg = `pickFromList given invalid pickCallBack, it is a ${typeof(pickCallBack)}`\n        ui.notifications.error(msg);\n        log(msg);\n        return\n    }   \n\n    if (!queryTitle || !queryText || !queryOptions) {\n        let msg = `pickFromList arguments should be (queryTitle, queryText, pickCallBack, ...queryOptions),\n                   but yours are: ${queryTitle}, ${queryText}, ${pickCallBack}, ${queryOptions}`;\n        ui.notifications.error(msg);\n        log(msg);\n        return\n    }\n\n    let template = `\n    <div>\n    <div class=\"form-group\">\n        <label>${queryText}</label>\n        <select id=\"selectedOption\">`\n    for (let option of queryOptions) {\n        template += `<option value=\"${option}\">${option}</option>`\n    }\n    template += `</select>\n    </div></div>`\n\n    new Dialog({\n        title: queryTitle,\n        content: template,\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: 'OK',\n                callback: async (html) => {\n                    const selectedOption = html.find('#selectedOption')[0].value\n                    log('selected option', selectedOption)\n                    pickCallBack(selectedOption)\n                },\n            },\n            cancel: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: 'Cancel',\n                callback: async (html) => {\n                    log('canceled')\n                    pickCallBack(null)\n                },\n            },\n        },\n        default: 'cancel',\n    }).render(true)\n\n    log(\"---------------------------------------------------------------------------\",\n        `Finished`, `${MACRONAME} ${FUNCNAME}`);\n        return;\n}\n\n/****************************************************************************************\n * Receive selected Curse and continue main steps\n ***************************************************************************************/\nasync function pickCurseCallBack(selection) {\n    const FUNCNAME = \"pickCurseCallBack(selection)\";\n    let itemD = args[0]?.item;\n    let curseName = selection?.split(\" \")[0]     // Grab first word of the selection\n\n    log(\"---------------------------------------------------------------------------\",\n        `Starting`, `${MACRONAME} ${FUNCNAME}`,   \n        `selection`, selection,\n        `itemD`, itemD, \n        `curseName`, curseName);\n\n    let curseDiscription = \"\";\n    let level = args[0].spellLevel;\n\n    let gameRound = game.combat ? game.combat.round : 0;\n    const rounds = level === 3 ? 10 : level === 4 ? 100 : level === 5 ? 800 : level === 6 ? 800 : 9999999;\n    const seconds = rounds * 6;\n\n    switch (curseName) {\n        case \"Ineptitude\":\n            curseDiscription = `<b>Curse of ${curseName}</b>: The afflicted has disadvantage on \n                ability checks and saving throws made with a caster selected ability score.`;\n            postResults(curseDiscription);\n            const queryTitle = \"Select Stat to be Afflicted\"\n            const queryText = \"Pick one from drop down list\"\n            //pickStat(queryTitle, queryText, \n            pickFromList(queryTitle, queryText, pickStatCallBack, \n                \"Strength\", \"Dexterity\", \"Constitution\", \"Intelligence\", \"Wisdom\", \"Charisma\");\n            break;\n        case \"Aversion\":\n            curseDiscription = `<b>Curse of ${curseName}</b>: The afflicted has disadvantage on \n            attack rolls against caster.\n            <br><br><b>FoundryVTT</b>: This should be handled manually.`\n            postResults(curseDiscription);\n            applyCurseStub(curseName);\n            break;\n        case \"Lethergy\":\n            curseDiscription = `<b>Curse of ${curseName}</b>: The afflicted must make a \n                <b>Wisdom save</b> against <b>DC${itemD.data.save.dc}</b> at the start of each \n                of its turns. If it fails, it wastes its action that turn, doing nothing.`\n            postResults(curseDiscription);\n            applyCurseStub(curseName);\n            break;\n        case \"Vulnerability\":\n            curseDiscription = `<b>Curse of ${curseName}</b>: Caster's attacks deal an extra \n                1d8 necrotic damage to the target.`\n            postResults(curseDiscription);\n            applyCurseStub(curseName);\n            bonusDamage(canvas.tokens.get(args[0].targets[0].id), itemD, args[0].uuid, \n                canvas.tokens.get(args[0].tokenId), game.actors.get(args[0].actor._id), \n                rounds, seconds, gameRound)\n            break;\n        case \"Other\":\n            curseDiscription = `<b>Curse of ${curseName}</b>: Some other effect agreed on \n            by player and GM. <br><br><b>FoundryVTT</b>: This should be handled manually.`\n            postResults(curseDiscription);\n            applyCurseStub(curseName);\n            break;\n        default:\n            curseDiscription = `Unfortunately, this is an undefined condition.`\n            postResults(curseDiscription);\n            break;\n    }\n    log(`${curseName} description: ${curseDiscription}`);\n\n    log(\"---------------------------------------------------------------------------\",\n        `Finished`, `${MACRONAME} ${FUNCNAME}`);\n    return;\n}\n\n/****************************************************************************************\n * Receive selected stat and continue main steps.  This is only used by Curse of Lethergy\n ***************************************************************************************/\nasync function pickStatCallBack(selection) {\n    const FUNCNAME = \"pickStatCallBack(selection)\";\n\n    let player = canvas.tokens.get(args[0]?.tokenId);\n    let targetD = canvas.tokens.get(args[0]?.targets[0]?.id);\n    let stat = \"\";\n    log(\"---------------------------------------------------------------------------\",\n        `Starting`, `${MACRONAME} ${FUNCNAME}`, \n        `selection`, selection,\n        `player`, player, \n        `targetD`, targetD);\n\n    // ---------------------------------------------------------------------------------------\n    // Add cursed condition to target\n    //\n    switch(selection) {\n        case \"Strength\"     : stat = \"str\"; break;\n        case \"Dexterity\"    : stat = \"dex\"; break;\n        case \"Constitution\" : stat = \"con\"; break;\n        case \"Intelligence\" : stat = \"int\"; break;\n        case \"Wisdom\"       : stat = \"wis\"; break;\n        case \"Charisma\"     : stat = \"cha\"; break;\n        default             : stat = \"XYZ\"; break;\n    }                   \n    log(`Short Stat Name`, stat);\n    \n    const secondDebuff = `${CurseofIneptitude} (${selection})`\n    let gameRound = game.combat ? game.combat.round : 0;\n    let effectData = {\n        label: secondDebuff,\n        icon: ICON,\n        origin: player.actor.uuid,\n        disabled: false,\n        duration: { rounds: 99, startRound: gameRound },\n        flags: { convenientDescription: `${selection} ability checks and saves at disadvantage` }, \n        changes: [\n            { key: `flags.midi-qol.disadvantage.ability.check.${stat}`, mode: ADD, value: 1, priority: 20 },\n            { key: `flags.midi-qol.disadvantage.ability.save.${stat}`,  mode: ADD, value: 1, priority: 20 },\n        ]\n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\",{actorUuid:targetD.actor.uuid, effects: [effectData] });\n    await DAE.setFlag(targetD.actor, `${MACRO}.SecondDebuff`, secondDebuff);\n\n    log(\"---------------------------------------------------------------------------\",\n        `Finished`, `${MACRONAME} ${FUNCNAME}`);\n    return;\n}\n\n/****************************************************************************************\n * Apply a stub effect with just the name of the effect for curse that are not automated\n ***************************************************************************************/\nasync function applyCurseStub(curseName) {\n    const FUNCNAME = \"applyCurseStub(curseName)\";\n    let player = canvas.tokens.get(args[0]?.tokenId);\n    let targetD = canvas.tokens.get(args[0]?.targets[0]?.id);\n    log(\"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---\",\n        `Starting`, `${MACRONAME} ${FUNCNAME}`, \n        \"curseName\", curseName, \n        \"player\", player, \n        \"targetD\", targetD);\n    // --------------------------------------------------------------------------------\n    // Set the convenientDescription value based on curseName\n    //\n    let ceDesc = \"\"\n    switch (curseName) {\n        case \"Aversion\":\n            ceDesc = `Disadvantage on attack rolls against ${aToken.name}`; break;\n        case \"Lethergy\":\n            ceDesc = `DC${SAVE_DC} WIS Save or No Actions each turn`; break;\n        case \"Vulnerability\":\n            ceDesc = `${aToken.name}'s attacks deal an extra 1d8 necrotic damage`; break;\n        default:\n            ceDesc = `Some other effect agreed on by player and GM`; break;\n    }\n    // --------------------------------------------------------------------------------\n    // Add cursed condition to target\n    //\n    const secondDebuff = `Curse of ${curseName}`\n    let gameRound = game.combat ? game.combat.round : 0;\n    let effectData = {\n        label: secondDebuff,\n        icon: ICON,\n        origin: player.actor.uuid,\n        disabled: false,\n        duration: { rounds: 999999, startRound: gameRound },\n        flags: { convenientDescription: ceDesc }, \n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\",{actorUuid:targetD.actor.uuid, effects: [effectData] });\n    await DAE.setFlag(targetD.actor, `${MACRO}.SecondDebuff`, secondDebuff);\n\n    log(`Finishing`, FUNCNAME);\n    log(\"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---\");\n}\n\n/***************************************************************************************\n * Post the results to chat card\n ***************************************************************************************/\nasync function postResults(resultsString) {\n    const FUNCNAME = \"postResults(resultsString)\";\n    log(\"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\");\n    log(`Starting ${MACRONAME} ${FUNCNAME}`,\n        `resultsString`, resultsString);\n    for (let i = 0; i < args.length; i++) log(`  args[${i}]`, args[i]);\n\n    // let chatmsg = await game.messages.get(itemCard.id)\n    let chatmsg = game.messages.get(LAST_ARG.itemCardId);\n    let content = await duplicate(chatmsg.data.content);\n    log(`chatmsg: `, chatmsg);\n    const searchString = /<div class=\"end-midi-qol-saves-display\">/g;\n    const replaceString = `<div class=\"end-midi-qol-saves-display\">${resultsString}`;\n    content = await content.replace(searchString, replaceString);\n    await chatmsg.update({ content: content });\n    await ui.chat.scrollBottom();\n\n    log(\"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\",\n        `Finished`, `${MACRONAME} ${FUNCNAME}`);\n    return;\n}\n\n/****************************************************************************************\n * BonusDamage: When a target gets the curse of vulnerability, create this effect. \n ***************************************************************************************/\nasync function bonusDamage(target, itemD, uuid, tokenD, actorD, rounds, seconds, gameRound) {\n    const FUNCNAME = \"bonusDamage(target, itemD, uuid, tokenD, actorD, rounds, seconds, gameRound)\";\n    log(\"+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\");\n    log(`Starting ${MACRONAME} ${FUNCNAME}`, \n        \"target\", target, \n        \"itemD\", itemD, \n        \"uuid\", uuid, \n        \"tokenD\", tokenD, \n        \"actorD\", actorD, \n        \"rounds\", rounds, \n        \"seconds\", seconds,\n        \"gameRound\", gameRound);\n\n    // --------------------------------------------------------------------------------\n    // Define and add the curse effect to caster\n    //        \n    let effectData = {\n        label: itemD.name,\n        icon: ICON,\n        origin: uuid,\n        disabled: false,\n        duration: { rounds: rounds, seconds: seconds, startRound: gameRound, startTime: game.time.worldTime },\n        flags: { dae: { itemData: itemD } },\n        changes: [\n            { key: \"flags.midi-qol.hexMark\", mode: OVERRIDE, value: target.id, priority: 20 },\n            { key: \"flags.dnd5e.DamageBonusMacro\", mode: CUSTOM, value: `ItemMacro.${itemD.name}`, priority: 20 },\n            { key: \"flags.midi-qol.concentration-data.targets\", mode: ADD, value: { \"actorId\": actorD.id, \"tokenId\": tokenD.id }, priority: 20 }\n        ]\n    };\n    // await actorD.createEmbeddedEntity(\"ActiveEffect\", effectData); // Depricated \n    await actorD.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\n    log(\"+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\",\n        `Finished`, `${MACRONAME} ${FUNCNAME}`);\n}\n\n/****************************************************************************************\n * Apply the Bonus Damage for Curse of Vulnerability\n ***************************************************************************************/\nfunction doBonusDamage() {\n    const FUNCNAME = \"doBonusDamage()\";\n    const DAMAGETYPE = \"necrotic\";\n\n    log(\"+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\",\n        `Starting`, `${MACRONAME} ${FUNCNAME}`,\n        \"DAMAGETYPE\", DAMAGETYPE);\n    for (let i = 0; i < args.length; i++) log(`  args[${i}]`, args[i]);\n\n    // --------------------------------------------------------------------------------\n    // Obtain and optionally log a bunch of information for application of damage\n    //  \n    const target = canvas.tokens.get(args[0].targets[0].id);\n    const actorD = game.actors.get(args[0].actor._id);\n    const tokenD = canvas.tokens.get(args[0].tokenId);\n    const itemD  = args[0].item; // Needed to determine if invoking effect is am attack\n    let curseItemD = DAE.getFlag(target.actor, `${MACRO}.curseItemD`); \n\n    log(`Obtained values for function`,\n        \"target\", target, \"target.name\", target.name,\n        // \"actorD\", actorD, \"actorD.name\", actorD.name, \n        \"tokenD\", tokenD, \"tokenD.name\", tokenD.name,\n        \"itemD\", itemD, \"itemD.name\", itemD.name,\n        \"curseItemD\", curseItemD);\n\n    // --------------------------------------------------------------------------------\n    // Make sure the actor has midi-qol.hexmark which is being hijacked for this macro\n    //   \n    if (target.id !== getProperty(tokenD.actor.data.flags, \"midi-qol.hexMark\")) {\n        log(\"Should not get here?\", 'target.id', target.id,\n            \"tokenD.actor.data.flags\", tokenD.actor.data.flags,\n            'getProperty(tokenD.actor.data.flags, \"midi-qol.hexMark\")', \n            getProperty(tokenD.actor.data.flags, \"midi-qol.hexMark\"));\n        return {};\n    }\n\n    // --------------------------------------------------------------------------------\n    // Replace the image for the curse with ICON\n    //      \n    curseItemD.img = ICON;\n\n    // --------------------------------------------------------------------------------\n    // Was the action that invoked this an attack (mwak, msak, rwak, rsak)?  If it \n    // wasn't just return without extra damage.\n    //  \n    let action = itemD.data.actionType;\n    if ((action === \"mwak\") || (action === \"msak\") ||\n        (action === \"rwak\") || (action === \"rsak\")) {\n            log(\"Action type is an attack!  Damage to be done.\", action);\n    } else {\n        log(\"+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\",\n            \"Action type is not an attack. :(  No damage.\", action,\n            `Early Exit`, `${MACRONAME} ${FUNCNAME}`);\n        return {};\n    }\n\n    // mwak, msak, rwak, rsak -- Following is voodoo code that was used previously\n    /* if (![\"ak\"].some(actionType => (itemD.data.actionType || \"\").includes(actionType))) {\n        log(\"Didn't find an ak\");\n        return {};\n    } */\n\n    // --------------------------------------------------------------------------------\n    // Time to actually do some damage!\n    //  \n    //return { damageRoll: `1d8[${damageType}]`, flavor: `(Hex (${CONFIG.DND5E.damageTypes[damageType]}))`, \n    //         damageList: args[0].damageList, itemCardId: args[0].itemCardId };\n    let damageRoll = new Roll(`1d8`).evaluate({ async: false });\n    log(\" damageRoll\", damageRoll, \" Damage Total\", damageRoll.total);\n    game.dice3d?.showForRoll(damageRoll);\n\n    new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, DAMAGETYPE, \n        [target], damageRoll, {\n        flavor: `<b>${target.name}</b> suffers further from <b>${actorD.name}</b>'s \n                    Curse of <b>Vulnerability</b>`,\n        itemData: curseItemD,\n        itemCardId: \"new\"\n    });\n\n    log(\"+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +\",\n        `Finished`, `${MACRONAME} ${FUNCNAME}`);\n}\n\n/************************************************************************\n * Verify exactly one target selected, boolean return\n*************************************************************************/\nfunction oneTarget() {\n    if (!game.user.targets) {\n        msg = `Targeted nothing, must target single token to be acted upon`;\n        // ui.notifications.warn(msg);\n        log(msg);\n        return (false);\n    }\n    if (game.user.targets.ids.length != 1) {\n        msg = `Target a single token to be acted upon. Targeted ${game.user.targets.ids.length} tokens`;\n        // ui.notifications.warn(msg);\n        log(msg);\n        return (false);\n    }\n    log(` targeting one target`);\n    return (true);\n}\n\n/****************************************************************************************\n * Return the number of tokens that failed their saving throw\n ***************************************************************************************/\nfunction failedCount() {\n    let failCount = args[0].failedSaves.length\n    log(`${failCount} args[0].failedSaves: `, args[0].failedSaves)\n    return (failCount);\n}\n\n/****************************************************************************************\n * DEBUG Logging\n * \n * If passed an odd number of arguments, put the first on a line by itself in the log,\n * otherwise print them to the log seperated by a colon.  \n * \n * If more than two arguments, add numbered continuation lines. \n ***************************************************************************************/\n function log(...parms) {\n    if (!DEBUG) return;             // If DEBUG is false or null, then simply return\n    let numParms = parms.length;    // Number of parameters received\n    let i = 0;                      // Loop counter\n    let lines = 1;                  // Line counter \n\n    if (numParms % 2) {  // Odd number of arguments\n        console.log(parms[i++])\n        for ( i; i<numParms; i=i+2) console.log(` ${lines++})`, parms[i],\":\",parms[i+1]);\n    } else {            // Even number of arguments\n        console.log(parms[i],\":\",parms[i+1]);\n        i = 2;\n        for ( i; i<numParms; i=i+2) console.log(` ${lines++})`, parms[i],\":\",parms[i+1]);\n    }\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "exportSource": {
      "world": "travels-in-barovia-ce",
      "system": "dnd5e",
      "coreVersion": "9.269",
      "systemVersion": "1.6.2"
    }
  }
}