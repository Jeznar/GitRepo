{
  "name": "Enthrall",
  "type": "spell",
  "img": "Icons_JGB/Spells/2nd_Level/enthralling.png",
  "data": {
    "description": {
      "value": "<p>You weave a distracting string of words, causing creatures of your choice that you can see within range and that can hear you to make a&nbsp;<strong>WIS save</strong>.</p>\n<p>Any creature that&nbsp;<strong>can&rsquo;t be Charmed succeeds on this save</strong>&nbsp;automatically, and if you or your companions are fighting a creature, it has advantage on the save.</p>\n<p>On a failed save, the target has disadvantage on Wisd‚Å†om (Perception) checks made to perceive any creature other than you until the spell ends or until the target can no longer hear you.</p>\n<p>The spell ends if you are Incapacitated or can no longer speak.</p>\n<hr style=\"border-top: 1px solid var(--color-border-light-primary); border-bottom: 1px solid var(--color-border-light-highlight);\" />\n<p><strong>FoundryVTT:&nbsp;</strong>Player should not target before casting.&nbsp; It will provide selection dialogs and automate the spell other than the actual conditional disadvantage.&nbsp; It also doesn't drop immediately when the caster is incapacitated of unable to speak, that can be handled manually.</p>",
      "chat": "",
      "unidentified": ""
    },
    "source": "",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": 1,
      "units": "minute"
    },
    "target": {
      "value": null,
      "width": null,
      "units": "",
      "type": ""
    },
    "range": {
      "value": 60,
      "long": null,
      "units": "ft"
    },
    "uses": {
      "value": null,
      "max": "",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "other",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": ""
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "level": 2,
    "school": "enc",
    "components": {
      "value": "",
      "vocal": true,
      "somatic": true,
      "material": false,
      "ritual": false,
      "concentration": false
    },
    "materials": {
      "value": "",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "prepared",
      "prepared": true
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    },
    "attunement": null
  },
  "effects": [],
  "flags": {
    "core": {
      "sourceId": "Item.LFPgWt8PZNtmCkft"
    },
    "midi-qol": {
      "effectActivation": false,
      "onUseMacroName": "[postActiveEffects]ItemMacro"
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Enthrall",
          "type": "script",
          "author": "ZjFlOWYxZjM5ZTZj",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const MACRONAME = \"Enthrall.0.1.js\"\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * RAW Derscription \n *   You weave a distracting string of words, causing creatures of your choice that you can see within range and that can hear you \n *   to make a Wisdom saving throw. Any creature that can't be charmed succeeds on this saving throw automatically, and if you or \n *   your companions are fighting a creature, it has advantage on the save. On a failed save, the target has disadvantage on Wisdom \n *   (Perception) checks made to perceive any creature other than you until the spell ends or until the target can no longer hear \n *   you. The spell ends if you are incapacitated or can no longer speak.\n * \n * The steps to implment this spell are anticipated to be as follows, with part implmented as doOnUse, doEach, and doOff\n * \n * doOnUse\n * -------\n * - Build an array of all potential targets within 60 feet that can be seen by the caster, \n *   o checking for Line of Sight blocks\n *   o and that the caster is not blinded.\n * - Prune potential target array of any targets that can not hear (deafend or Line of Sound blocked) the caster\n * - If there are no eligible targets terminate with message \n * - Present a dialog allowing caster to choose which of the eligible targets should be subject of enthrall\n * - If caster is in combat, present the list of selected targets and ask which are in combat with the caster or companions\n * - Run VFX on caster of spell \n * - Roll saves for the targets\n *   o Those marked as in combat have advantage\n *   o Those that are immune to charm condition automatically save (roll forced 99)\n * - Present list of those that saved and those that failed the save and description of effect (which is manual)\n * - If no targets failed save, terminate\n * - Run VFX on those that failed their saves\n * - Place modified CE effect on those that failed that includes a run every turn to trigger the doEach steps \n *   o Description needs to name the caster of the spell\n * - Place enthralling effect on the caster that includes a list of ids for affected targets and triggers doEach\n * \n * doEach\n * ------\n * - Determine if active token is caster or a victim of this spell\n * - If the active token is caster, remove the enthralling effect if the caster has one or more SPELL_DROP_EFFECTS:\n *   Silenced, Dead, Unconscious, or Incapacitated\n * - Otherwise check to see if token can hear the caster, if they can't remove the enthralled effect\n * \n * doOff\n * -----\n * - Determine if active token is caster or a victim of this spell\n * - If the active token is caster, attemot to remove the enthralled effect from all of the targets\n * - Otherwise, say that you have been freed from the enthrall and post a message\n * \n * 02/08/23 0.1 Creation of Macro\n * 02/09/23 0.1 Outline the steps to implement\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nconst MACRO = MACRONAME.split(\".\")[0]       // Trim off the version number and extension\nconst TAG = `${MACRO} |`\nconst TL = 0;                               // Trace Level for this macro\nlet msg = \"\";                               // Global message string\n//-----------------------------------------------------------------------------------------------------------------------------------\nif (TL > 0) jez.trace(`${TAG} === Starting ===`);\nif (TL > 1) for (let i = 0; i < args.length; i++) jez.trace(`  args[${i}]`, args[i]);\n//-----------------------------------------------------------------------------------------------------------------------------------\n// Set standard variables\n//\nconst L_ARG = args[args.length - 1]; // See https://gitlab.com/tposney/dae#lastarg for contents\nlet aToken = (L_ARG.tokenId) ? canvas.tokens.get(L_ARG.tokenId) : game.actors.get(L_ARG.tokenId)\nlet aActor = aToken.actor;\nlet aItem = (args[0]?.item) ? args[0]?.item : L_ARG.efData?.flags?.dae?.itemData\nconst VERSION = Math.floor(game.VERSION);\nconst GAME_RND = game.combat ? game.combat.round : 0;\nconst SPELL_DROP_EFFECTS = [ 'Silenced', 'Dead', 'Unconscious', 'Incapacitated' ]\n//-----------------------------------------------------------------------------------------------------------------------------------\n// Set Macro specific globals\n//\nconst ENTHRALLED_JRNL = `@JournalEntry[${game.journal.getName(\"Enthralled\").id}]{Enthralled}`\n//-----------------------------------------------------------------------------------------------------------------------------------\n// Run the main procedures, choosing based on how the macro was invoked\n//\nif (args[0]?.tag === \"OnUse\") await doOnUse({ traceLvl: TL });          // Midi ItemMacro On Use\nif (args[0] === \"each\") doEach({ traceLvl: TL });\t\t\t\t\t    // DAE everyround\nif (args[0] === \"off\") await doOff({ traceLvl: TL });                   // DAE removal\nif (TL > 1) jez.trace(`${TAG} === Finished ===`);\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ***********************************************************************************************************************************\n * Post results to the chat card\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nfunction postResults(msg) {\n    const FUNCNAME = \"postResults(msg)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL > 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 2) jez.trace(\"postResults Parameters\", \"msg\", msg)\n    //-------------------------------------------------------------------------------------------------------------------------------\n    let chatMsg = game.messages.get(args[args.length - 1].itemCardId);\n    jez.addMessage(chatMsg, { color: jez.randomDarkColor(), fSize: 14, msg: msg, tag: \"saves\" });\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * - Build an array of all potential targets within 60 feet that can be seen by the caster, \n *   o checking for Line of Sight blocks\n *   o and that the caster is not blinded.\n * - Prune potential target array of any targets that can not hear (deafend or Line of Sound blocked) the caster\n * - If there are no eligible targets terminate with message \n * - Present a dialog allowing caster to choose which of the eligible targets should be subject of enthrall\n * - If caster is in combat, present the list of selected targets and ask which are in combat with the caster or companions\n * - Run VFX on caster of spell \n * - Roll saves for the targets\n *   o Those marked as in combat have advantage\n *   o Those that are immune to charm condition automatically save (roll forced 99)\n * - Present list of those that saved and those that failed the save and description of effect (which is manual)\n * - If no targets failed save, terminate\n * - Run VFX on those that failed their saves\n * - Place modified CE effect on those that failed that includes a run every turn to trigger the doEach steps \n *   o Description needs to name the caster of the spell\n * - Place enthralling effect on the caster that includes a list of ids for affected targets and triggers doEach\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function doOnUse(options = {}) {\n    const FUNCNAME = \"doOnUse(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    await jez.wait(100)\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // Define function variables\n    //\n    let canSeeIds = []\n    let canHearIds = []\n    let targetableIds = []\n    const SEP_CHAR = '-'\n    let tokenNames = [] // Array that contains the token names of candidates, corresponds with tokenNames\n    let tokenIds = []   // Array that contains the token Ids of those that can be seen and hear\n    let filteredCnt = 0\n    let combatantNames = []\n    let combatantIds = []\n    let combatantCnt = 0\n    let opponentIndexs = []\n    let opponentTokenIds = []\n    let targetIds = []\n    let bystanderTokenIds = []\n    let bystanderTokens = []\n    let opponentTokens = []\n    const SAVE_TYPE = 'wis'\n    const SAVE_DC = jez.getSpellDC(aToken)\n    let failSaves = []  // Array to contain the tokens that failed their saving throws\n    let madeSaves = []  // Array to contain the tokens that made their saving throws\n    let madeNames = \"\"\n    let failNames = \"\"\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Build an array of all potential targets within 60 feet that can be seen by the caster, checking for Line of Sight blocks and that the caster is not blinded.`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    // Does the caster have the blinded condition?\n    let blindedEffect = await aActor.effects.find(i => i.data.label === \"Blinded\");\n    if (blindedEffect) return jez.badNews(`${aToken.name} is blinded and can't see any targets. Spell has no effect.`, \"i\")\n    // Build array of those within 60 feet that can be seen by the caster\n    const CAN_BE_SEEN = await getThoseThatCanBeSeen(60, { traceLvl: TL })\n    if (CAN_BE_SEEN.length === 0) return jez.badNews(`No targets in range can be seen`, \"i\")\n    for (let i = 0; i < CAN_BE_SEEN.length; i++) {\n        if (TL > 3) jez.trace(`${TAG} | Can Be Seen: ${CAN_BE_SEEN[i].name}${SEP_CHAR}${CAN_BE_SEEN[i].id}`)\n        canSeeIds.push(`${CAN_BE_SEEN[i].name}${SEP_CHAR}${CAN_BE_SEEN[i].id}`)\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Prune potential target array of any targets that can not hear (deafend or Line of Sound blocked) the caster`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    // Build array of tokens that can hear the caster\n    const CAN_HEAR = await getThoseThatCanHear(60, { traceLvl: 0 })\n    if (CAN_HEAR.length === 0) return jez.badNews(`No in range targets can hear the caster`, \"i\")\n    for (let i = 0; i < CAN_HEAR.length; i++) {\n        if (TL > 3) jez.trace(`${TAG} | Can Hear: ${CAN_HEAR[i].name}${SEP_CHAR}${CAN_HEAR[i].id}`)\n        canHearIds.push(`${CAN_HEAR[i].name}${SEP_CHAR}${CAN_HEAR[i].id}`)\n    }\n    // Obtain the intersection of the two arrays as affectable targets \n    for (let i = 0; i < canHearIds.length; i++)\n        // TODO: get correct syntax for this operation\n        if (canSeeIds.includes(canHearIds[i])) targetableIds.push(canHearIds[i])\n    if (TL > 2) jez.trace(`${TAG} Token Arrays:`, \n        `canSeeIds    `, canSeeIds, `canHearIds   `, canHearIds, `targetableIds`, targetableIds)\n    // Example value of targetableIds (7) [\n    //    'Acolyte-3LcEh5rpD6ax8Ll7', 'Acolyte-eIzYNsFkw8YKCBHh', 'Gate Guard-r78yGjIFRFzX6giL', 'Guard Captain-1CWFDI7gXlSrAjPs', \n    //    'Guard-qYxnYBuL8fWepCdR', 'Militia Leader-grzlDpnm3M8AOgmS', 'Minnie McWizard-VqULthPX1ZdfAPcs']\n    targetableIds.sort()\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `If there are no eligible targets terminate with message`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    if (targetableIds.length === 0) return jez.badNews(`No valid targets in range`, \"i\")\n    if (TL > 3) for (let i = 0; i < targetableIds.length; i++) jez.trace(`${TAG} | ${i + 1} Candidate ${i}: ${targetableIds[i]}`)\n    //\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Present a dialog allowing caster to choose which of the eligible targets should be subject of enthrall`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    // Build array of token names to be presented to caster\n    for (let i = 0; i < targetableIds.length; i++) {\n        const ATOMS = targetableIds[i].split(SEP_CHAR)\n        if (TL > 4) jez.trace(`${TAG} ${ATOMS.length} ATOMS`, ATOMS)\n        if (ATOMS.length !== 2) return jez.badNews(`Bad Juju. Failed to parse ${targetableIds[i]}. Expected <Name>${SEP_CHAR}<ID>`)\n        tokenNames.push(`${++filteredCnt}. ${ATOMS[0]}`)             // Push name into display array\n        tokenIds.push(ATOMS[1])                                      // Push correponding id\n    }\n    if (TL > 1) jez.trace(`${TAG} array contents`, 'tokenNames', tokenNames, 'tokenIds', tokenIds)\n    // Call pick targets function\n    const TARGETS = await pickTargets(tokenNames, '', { traceLvl: TL })\n    if (!TARGETS) return\n    if (!TARGETS === undefined) return\n    // Build array of Target Ids, subset of tokenIds\n    for (let i = 0; i < TARGETS.length; i++) targetIds.push(tokenIds[parseInt(TARGETS[i]) - 1])\n    if (TL > 2) jez.trace(`${TAG} targetIds`, targetIds);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Present list of selected targets that are in combat and ask which are in combat with the caster or companions`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    // Loop through the TARGETS making array of names and Ids in combat\n    let targetedTokens = []\n    let indexes = []\n    if (TL > 2) jez.trace(`${TAG} Targets`, TARGETS);\n    for (let i = 0; i < TARGETS.length; i++) indexes.push(parseInt(TARGETS[i])) // Nab leading integer as the array index for each\n    if (TL > 3) jez.trace(`${TAG} indexes`, indexes);\n    for (let i = 0; i < indexes.length; i++) {\n        targetedTokens.push(canvas.tokens.placeables.find(ef => ef.id === tokenIds[indexes[i] - 1]))\n        // Build list of those in combat by testing _token.combatant --> True indicates combat\n        if (targetedTokens[i].combatant) {\n            combatantNames.push(`${++combatantCnt}. ${targetedTokens[i].name}`)\n            combatantIds.push(targetedTokens[i].id)\n        }\n        if (TL > 3) for (let i = 0; i < combatantIds.length; i++)\n            jez.trace(`${TAG} | ${i + 1} Combatant: ${combatantNames[i]} ${combatantIds[i]}`)\n    }\n    // Have the caster select targets that are in combat with the caster or his/her companions\n    if (combatantIds.length > 0) {\n        const OPPONENTS = await pickOpponents(combatantNames, { traceLvl: TL })\n        if (TL > 2) jez.trace(`${TAG} OPPONENTS`, OPPONENTS);\n        // Build an array of the tokenIds that are in combat \n        if (OPPONENTS) {\n            for (let i = 0; i < OPPONENTS.length; i++) opponentIndexs.push(parseInt(OPPONENTS[i])) // Nab leading integer \n            for (let i = 0; i < opponentIndexs.length; i++)\n                opponentTokenIds.push(combatantIds[opponentIndexs[i] - 1])\n        }\n    }\n    console.log('4')\n    if (TL > 3) jez.trace(`${TAG} opponentTokenIds`, opponentTokenIds);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Run VFX on caster of spell`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    runVFXCaster(aToken)\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Roll saves for the targets, Those marked as in combat have advantage, Those that are immune to charm condition automatically save (roll forced 99)`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    // Build array of those not in combat by excluding those that are in combat\n    for (let i = 0; i < targetIds.length; i++) if (!opponentTokenIds.includes(targetIds[i])) bystanderTokenIds.push(targetIds[i])\n    if (TL > 2) {\n        jez.trace(`${TAG} These targets are selected for the spell:`, targetIds)\n        jez.trace(`${TAG} These targets are opponents in combat:`, opponentTokenIds)\n        jez.trace(`${TAG} These targets are bystanders (not in combat):`, bystanderTokenIds)\n    }\n    // Build array of bystander Token5es\n    for (let i = 0; i < bystanderTokenIds.length; i++)\n        bystanderTokens.push(canvas.tokens.placeables.find(ef => ef.id === bystanderTokenIds[i]))\n    if (TL > 2) jez.trace(`${TAG} bystanderTokens`, bystanderTokens)\n    // Have the bystanders roll their saving throws\n    for (let i = 0; i < bystanderTokens.length; i++) {\n        // Handle immune to charm case \n        if (bystanderTokens[i].actor.data.data.traits.ci.value.includes('charmed')) {\n            const PSEUDO_BONUS = Math.floor(Math.random() * 6);\n            if (TL > 2) jez.trace(`${TAG} ${bystanderTokens[i].name} immune vs ${SAVE_DC}`)\n            madeSaves.push(bystanderTokens[i])\n            madeNames += `<b>${bystanderTokens[i].name}</b>: ${SAVE_DC - 1 + PSEUDO_BONUS} (1d20+${PSEUDO_BONUS})<br>`\n            continue\n        }\n        // Handle not immune to charm\n        let save = (await bystanderTokens[i].actor.rollAbilitySave(SAVE_TYPE, { chatMessage: false, fastforward: true }));\n        if (save.total < SAVE_DC) {\n            if (TL > 2) jez.trace(`${TAG} ${bystanderTokens[i].name} failed: ${SAVE_TYPE}${save.total} vs ${SAVE_DC}`)\n            failSaves.push(bystanderTokens[i])\n            failNames += `<b>${bystanderTokens[i].name}</b>: ${save.total} (${save._formula})<br>`\n        } else {\n            if (TL > 2) jez.trace(`${TAG} ${bystanderTokens[i].name} saved: ${SAVE_TYPE}${save.total} vs ${SAVE_DC}`)\n            madeSaves.push(bystanderTokens[i])\n            madeNames += `<b>${bystanderTokens[i].name}</b>: ${save.total} (${save._formula})<br>`\n        }\n    }\n    // Build array of opponent (combatant) Token5es\n    for (let i = 0; i < opponentTokenIds.length; i++)\n        opponentTokens.push(canvas.tokens.placeables.find(ef => ef.id === opponentTokenIds[i]))\n    // Have the combatants roll their saving throw (they get advantage)\n    for (let i = 0; i < opponentTokens.length; i++) {\n        // Handle immune to charm case \n        if (opponentTokens[i].actor.data.data.traits.ci.value.includes('charmed')) {\n            const PSEUDO_BONUS = Math.floor(Math.random() * 6);\n            if (TL > 2) jez.trace(`${TAG} ${opponentTokens[i].name} immune vs ${SAVE_DC}`)\n            madeSaves.push(opponentTokens[i])\n            madeNames += `<b>${opponentTokens[i].name}</b>: ${SAVE_DC - 1 + PSEUDO_BONUS} (1d20+${PSEUDO_BONUS})<br>`\n            continue\n        }\n        // Handle not immune to charm\n        let save = (await opponentTokens[i].actor.rollAbilitySave(SAVE_TYPE, { advantage: true, chatMessage: false, fastforward: true }));\n        if (save.total < SAVE_DC) {\n            if (TL > 2) jez.trace(`${TAG} ${opponentTokens[i].name} failed: ${SAVE_TYPE}${save.total} vs ${SAVE_DC}`)\n            failSaves.push(opponentTokens[i])\n            failNames += `<b>${opponentTokens[i].name}</b>: ${save.total} (${save._formula})<br>`\n        } else {\n            if (TL > 2) jez.trace(`${TAG} ${opponentTokens[i].name} saved: ${SAVE_TYPE}${save.total} vs ${SAVE_DC}`)\n            madeSaves.push(opponentTokens[i])\n            madeNames += `<b>${opponentTokens[i].name}</b>: ${save.total} (${save._formula})<br>`\n        }\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Present list of those that saved and those that failed the save and description of effect (which is manual)`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    postResults(`${SAVE_TYPE.toUpperCase()} DC${SAVE_DC} saving throw to avoid effect. Effects of ${ENTHRALLED_JRNL} \n        are not automated.`)\n    if (madeNames) {\n        await jez.wait(100)\n        postResults(`Successful saving throws:<br>` + madeNames)\n    }\n    if (failNames) {\n        await jez.wait(100)\n        postResults(`Failed saving throws:<br>` + failNames)\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `If no targets failed save, terminate`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    if (failSaves.length === 0) return jez.badNews('Spell had no effect', 'i')\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Run VFX on those that failed their saves`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    runVFXAfflicted(failSaves)\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Place modified CE effect on those that failed that includes a run every turn to trigger the doEach steps. Description needs to name the caster of the spell.  Keeping a tokenId list of those effected`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    // Build a modified Enthralled effect appropriate to apply to the afflicted.  It needs:\n    // - Effect added to call ItemMacro\n    // - Macro Repeat at start of each turn\n    // - a CE description added\n    // - duration of the effect (1 ninute, 10 rounds)\n    let effectData = game.dfreds.effectInterface.findEffectByName('Enthralled').convertToObject();\n    effectData.changes.push({ key: 'macro.itemMacro', mode: jez.ADD, value: `Afflicted ${aToken.id}`, priority: 20 })\n    effectData.flags.dae.macroRepeat = \"startEveryTurn\"\n    const CE_DESC = `Disadvantage on WIS (Perception) checks made to perceive any creature other than ${aToken.name}.`\n    effectData.description = CE_DESC\n    // Add our fancy effect to all that failed saves\n    for (let i = 0; i < failSaves.length; i++)\n        game.dfreds.effectInterface.addEffectWith({ effectData: effectData, uuid: failSaves[i].actor.uuid, origin: aItem.uuid });\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Place enthralling effect on the caster that includes a list of ids for affected targets and triggers doEach`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    // Build a string containing space delimited token ids of the afflicted\n    let failedTokenIds = ''\n    for (let i = 0; i < failSaves.length; i++) {\n        failedTokenIds += failSaves[i].id\n        if (i < failSaves.length - 1) failedTokenIds += ' '\n    }\n    // Build data structure for our enthralling effect\n    const CE_DESC_ENTHRALLING = `Maintaining enthralled effect`\n    let effectDataOrigin = {\n        label: 'Enthralling',\n        icon: aItem.img,\n        flags: {\n            convenientDescription: CE_DESC_ENTHRALLING,\n            dae: { itemData: aItem, stackable: false, macroRepeat: \"startEveryTurn\", specialDuration: [\"shortRest\", \"longRest\"] },\n        },\n        origin: actor.uuid,\n        disabled: false,\n        duration: { rounds: 10, startRound: GAME_RND, seconds: 60, startTime: game.time.worldTime },\n        changes: [{ key: \"macro.itemMacro\", mode: jez.ADD, value: failedTokenIds, priority: 20 }]\n    };\n    // Apply the effect\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: aActor.uuid, effects: [effectDataOrigin] });\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    // msg = `Say something useful...`\n    // postResults(msg)\n    if (TL > 0) jez.trace(`${TAG} --- Finished ---`);\n    return true;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Perform the code that runs when this macro is invoked each round by DAE\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function doEach(options = {}) {\n    const FUNCNAME = \"doEach(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Determine if ${aToken.name} is caster or a victim of this spell`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    const AFFLICTED = args[1] === 'Afflicted' ? true : false\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `If ${aToken.name} is caster, remove the enthralling effect if the caster has one of the SPELL_DROP_EFFECTS`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    let found = false\n    if (!AFFLICTED) {\n        if (TL > 2) jez.trace(`${TAG} ${aToken.name} is the origin of the spell`)\n        for (let i = 0; i < SPELL_DROP_EFFECTS.length; i++) {\n            if (TL > 1) jez.trace(`${TAG} Checking for condition: ${SPELL_DROP_EFFECTS[i]}`);\n            let chkEffect = await aActor.effects.find(j => j.data.label === SPELL_DROP_EFFECTS[i]);\n            if (TL > 2) jez.trace(`${TAG} aActor.effects:`, aActor.effects)\n            if (TL > 2) jez.trace(`${TAG} chkEffect content:`, chkEffect)\n            if (chkEffect) {\n                found = true\n                if (TL > 1) jez.trace(`${TAG} Found ${SPELL_DROP_EFFECTS[i]} on ${aToken.name}`);\n                let enthrallingEffect = await aActor.effects.find(i => i.data.label === \"Enthralling\");\n                if (enthrallingEffect) jez.deleteEffectAsGM(enthrallingEffect.uuid, { traceLvl: TL });\n                msg = `<b>${aToken.name}</b> is ${SPELL_DROP_EFFECTS[i]} and can no longer maintain the <b>Enthralling</b> effect.`\n                title = 'Enthralling spell ended'\n                jez.postMessage({color: jez.randomDarkColor(), fSize: 14, icon: aToken.data.img, msg: msg, title: title, token: aToken})\n                break\n            }\n        }\n        // let silencedEffect = await aActor.effects.find(i => i.data.label === \"Silenced\");\n        // if (silencedEffect) {\n        //     let enthrallingEffect = await aActor.effects.find(i => i.data.label === \"Enthralling\");\n        //     if (enthrallingEffect) jez.deleteEffectAsGM(enthrallingEffect.uuid, { traceLvl: TL })\n        // }\n        if (found === false) {\n            bubbleForAll(aToken.id, `I am enthralling`, true, true)\n            runVFXCaster(aToken)\n        }\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Otherwise check to see if ${aToken.name} can hear the caster, if they can't remove the enthralled effect`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    if (AFFLICTED) {\n        if (TL > 2) jez.trace(`${TAG} origin token id ${args[2]}`)\n        let oToken = canvas.tokens.get(args[2])\n        if (TL > 2) jez.trace(`${TAG} ${args[2]} oToken`, oToken)\n        if (TL > 2) jez.trace(`${TAG} ${aToken.name} is afflicted by the spell from ${oToken.name}`)\n        // Define the ray between the two locations\n        let ray = new Ray(aToken.center, oToken.center)\n        // check the line of sound\n        let badLoS = canvas.walls.checkCollision(ray, { type: \"sound\", mode: \"any\" })\n        if (badLoS) {\n            let enthralledEffect = await aActor.effects.find(i => i.data.label === \"Enthralled\");\n            if (enthralledEffect) jez.deleteEffectAsGM(enthralledEffect.uuid, { traceLvl: TL })\n        }\n        else {\n            bubbleForAll(aToken.id, `${oToken.name} has my rapt attention`, true, true)\n            runVFXAfflicted([aToken])\n        }\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n    return true;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Perform the code that runs when this macro is removed by DAE, set Off\n * This runs on actor that has the affected removed from it.\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function doOff(options = {}) {\n    const FUNCNAME = \"doOff(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Determine if active token is caster or a victim of this spell`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    const AFFLICTED = args[1] === 'Afflicted' ? true : false\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `If the active token is caster, attempt to remove the enthralled effect from all of the targets`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    if (!AFFLICTED) {\n        for (let i = 1; i < args.length - 1; i++) {\n            let tToken = canvas.tokens.get(args[i])\n            if (TL > 2) jez.trace(`${TAG} tToken`, tToken)\n            let enthralledEffect = await tToken.actor.effects.find(i => i.data.label === \"Enthralled\");\n            if (enthralledEffect) jez.deleteEffectAsGM(enthralledEffect.uuid, { traceLvl: TL })\n        }\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    msg = `Otherwise, say that you have been freed from the enthrall and post a message`\n    if (TL > 2) { jez.trace(`${TAG} -----------------`); jez.trace(`${TAG} ${msg}`) }\n    if (AFFLICTED) {\n        bubbleForAll(aToken.id, 'I am no longered enthralled', true, true)\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    //\n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n    return;\n}\n/***********************************************************************************************************************************\n* Finding the set of all creatures within defined distance that can be seen by the caster \n*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function getThoseThatCanBeSeen(DISTANCE, options = {}) {\n    const FUNCNAME = \"getThoseThatCanBeSeen(DISTANCE, options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, 'DISTANCE', DISTANCE, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    //\n    let opts = {\n        exclude: \"self\",        // self, friendly, or none (self is default)\n        direction: \"o2t\",       // t2o or o2t (Origin to Target) (t2o is default) \n        chkSight: true,         // Boolean (false is default)\n        chkBlind: false,        // Boolean (false is default)\n        traceLvl: 0,           // Trace level, integer typically 0 to 5\n    }\n    let returned = await jez.inRangeTargets(aToken, DISTANCE, opts);\n    if (TL > 0) jez.trace(`${TAG} --- Finished ---`);\n    return returned;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n* Find the set of all creatures within defined distance that can hear the caster \n*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function getThoseThatCanHear(DISTANCE, options = {}) {\n    const FUNCNAME = \"getThoseThatCanHear(DISTANCE, options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    //\n    let opts = {\n        exclude: \"self\",        // self, friendly, or none (self is default)\n        direction: \"t20\",       // t2o or o2t (Origin to Target) (t2o is default) \n        chkHear: true,\n        chkDeaf: true,          // Boolean (false is default)\n        traceLvl: 0,           // Trace level, integer typically 0 to 5\n    }\n    let returned = await jez.inRangeTargets(aToken, DISTANCE, opts);\n    if (TL > 0) jez.trace(`${TAG} --- Finished ---`);\n    return returned;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n* Pick Targets \n*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function pickTargets(tokenNames, xtraMsg, options = {}) {\n    const FUNCNAME = \"pickTargets(tokenNames, xtraMsg, options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting`, 'tokenNames', tokenNames, 'xtraMsg', xtraMsg, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    //\n    let queryTitle = \"Select Targets of Enthrall Spell\"\n    let queryText = `Pick creatures that should be forced to roll saves or be enthalled by ${aToken.name}.<br><br>${xtraMsg}`\n    const SELECTIONS = await jez.pickCheckListArray(queryTitle, queryText, null, tokenNames);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // If cancel button was selected on the preceding dialog, null is returned ==> Terminate\n    //\n    if (SELECTIONS === null) return;\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // If nothing was selected (empty array), call again and terminate this one\n    //\n    if (SELECTIONS.length === 0) {\n        xtraMsg = `No creatures selected last try.  Please select at least one before clicking <b>Selected Only</b> button.<br><br>`\n        pickTargets(tokenNames, xtraMsg, { traceLvl: TL })\t\t// itemSelected is a global that is passed to preceding func\n        return;\n    }\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    if (TL > 0) jez.trace(`${TAG} --- Finished ---`);\n    return SELECTIONS;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n* Mark those in combat with the caster or companions \n*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function pickOpponents(tokenNames, options = {}) {\n    const FUNCNAME = \"pickOpponents(tokenNames, options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting`, 'tokenNames', tokenNames, \"options\", options);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // \n    //\n    let queryTitle = \"Select Opponents in Combat\"\n    let queryText = `Pick creatures that are in combat with ${aToken.name} or his/her companions.<br><br>`\n    const SELECTIONS = await jez.pickCheckListArray(queryTitle, queryText, null, tokenNames);\n    //-------------------------------------------------------------------------------------------------------------------------------\n    // If cancel button was selected on the preceding dialog, null is returned ==> Terminate\n    // \n    if (TL > 0) jez.trace(`${TAG} --- Finished ---`);\n    return SELECTIONS;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Play the VFX on the afflicted\n*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function runVFXAfflicted(tokens) {\n    let vfxEffect = \"Icons_JGB/Spells/2nd_Level/enthrall.png\"\n    console.log(`runVFXAfflicted`, tokens)\n    for (let i = 0; i < tokens.length; i++) {\n        await jez.wait(Math.floor(Math.random() * 1500))\n        new Sequence()\n            .effect()\n            .file(vfxEffect)\n            .scaleToObject(0.2)\n            .scaleOut(16, 4000, { delay: -4000 })\n            .fadeOut(4000)\n            .atLocation(tokens[i])\n            .opacity(1)\n            .play();\n    }\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*\n * Play the VFX onthe caster\n*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0*********1*********2*********3*/\nasync function runVFXCaster(token) {\n    new Sequence()\n        .effect()\n        .file(aItem.img)\n        .duration(8000)\n        .atLocation(token)\n        .scaleToObject(0.25)\n        .scaleOut(16, 4000, { delay: -4000 })\n        .fadeOut(4000)\n        .opacity(1)\n        .play();\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "exportSource": {
      "world": "travels-in-barovia-ce",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.2"
    }
  }
}