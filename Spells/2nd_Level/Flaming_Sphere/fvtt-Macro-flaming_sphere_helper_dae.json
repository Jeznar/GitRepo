{
  "name": "Flaming_Sphere_Helper_DAE",
  "type": "script",
  "author": "ZjFlOWYxZjM5ZTZj",
  "img": "modules/jb2a_patreon/Library/2nd_Level/Flaming_Sphere/FlamingSphere_02_Orange_Thumb.webp",
  "scope": "global",
  "command": "const MACRONAME = \"Flaming_Sphere_Helper_DAE.0.4.js\"\njez.log(MACRONAME)\n/*****************************************************************************************\n * Helper fr Flaming_Sphere, based on Moonbeam_Helper_DAE.0.4\n * \n * 01/01/22 0.1 Creation of Macro\n * 03/16/22 0.2 Move into GitRepo chasing what appears to be permissions issue\n * 05/16/22 0.5 Update for FoundryVTT 9.x .deleteOwnedItem() --> .deleteEmbeddedDocuments()\n *****************************************************************************************/\nconst MACRO = MACRONAME.split(\".\")[0]     // Trim of the version number and extension\nconst MINION_UNIQUE_NAME = args[1];\nconst VFX_NAME = args[2];\nconst ATTACK_ITEM = args[3];\nconst VFX_OPACITY = args[4] || 0.95;\nconst VFX_SCALE = args[5] || 0.65;\njez.log(\"---------------------------------------------------------------------------\",\n    `Starting ${MACRONAME}`,\"MINION_UNIQUE_NAME\");\nfor (let i = 0; i < args.length; i++) jez.log(`  args[${i}]`, args[i]);\n\nif (!MINION_UNIQUE_NAME || !VFX_NAME || !ATTACK_ITEM ) {\n    ui.notifications.error(`${MACRONAME} received invalid parameters, please, politely ask Joe to fix this`);\n    jez.log(`Bad stuff received by ${MACRONAME}`,\n        \"MINION_UNIQUE_NAME\", MINION_UNIQUE_NAME,\n        \"VFX_NAME\", VFX_NAME,\n        \"ATTACK_ITEM\", ATTACK_ITEM,\n        \"VFX_OPACITY\", VFX_OPACITY,\n        \"VFX_SCALE\", VFX_SCALE);\n    return;\n}\n\njez.log(\"\",\"MINION_UNIQUE_NAME\",MINION_UNIQUE_NAME,\"VFX_NAME\",VFX_NAME,\"ATTACK_ITEM\",ATTACK_ITEM,\n    \"VFX_OPACITY\",VFX_OPACITY,\"VFX_SCALE\",VFX_SCALE);\n\nconst CUSTOM = 0, MULTIPLY = 1, ADD = 2, DOWNGRADE = 3, UPGRADE = 4, OVERRIDE = 5;\nconst lastArg = args[args.length - 1];\nlet msg = \"\";\nlet aActor;         // Acting actor, creature that invoked the macro\nlet aToken;         // Acting token, token for creature that invoked the macro\nlet aItem;          // Active Item information, item invoking this macro\nif (lastArg.tokenId) aActor = canvas.tokens.get(lastArg.tokenId).actor; else aActor = game.actors.get(lastArg.actorId);\nif (lastArg.tokenId) aToken = canvas.tokens.get(lastArg.tokenId); else aToken = game.actors.get(lastArg.tokenId);\nif (args[0]?.item) aItem = args[0]?.item; else aItem = lastArg.efData?.flags?.dae?.itemData;\n\nif (args[0] === \"off\") await doOff();         // DAE removal\nif (args[0] === \"on\") await doOn();           // DAE Application\nif (args[0] === \"each\") doEach();\t\t\t  // DAE each round execution\n\njez.log(\"---------------------------------------------------------------------------\",\n    \"Finished\", `${MACRONAME}`);\nreturn;\n\n/***************************************************************************************************\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ***************************************************************************************************\n\n /****************************************************************************************\n * Execute code for a DAE Macro each time on the target's turn per DAE setting\n ***************************************************************************************/\nasync function doEach() {\n    const FUNCNAME = \"doEach()\";\n    jez.log(\"===========================================================================\",\n        `Starting`, `${MACRONAME} ${FUNCNAME}`);\n    for (let i = 0; i < args.length; i++) jez.log(`  args[${i}]`, args[i]);\n\n    let concentrating = hasEffect(aActor, \"Concentrating\")\n    log (\"+ Effect\", concentrating)\n\n    if (!concentrating) {\n        jez.log(\"No longer concentrating, remove the Flaming_Sphere effect\");\n        let Flaming_SphereEffect = aActor.effects.find(ef => ef.data.label === \"Flaming_Sphere\") ?? null; \n        if (Flaming_SphereEffect) {\n            jez.log(\"Flaming_Sphere effect found\", Flaming_SphereEffect);\n            await Flaming_SphereEffect.delete();\n        } else {\n            jez.log(\"Flaming_Sphere effect was not found, this should not have happened.\");\n        }\n    }\n\n    jez.log(\"===========================================================================\",\n        `Ending`, `${MACRONAME} ${FUNCNAME}`);\n    return;\n}\n\n\n/***************************************************************************************************\n * Check to see if target has named effect. Return the effect or null\n ***************************************************************************************************/\nfunction hasEffect(target, effect) {\n\n    jez.log(\"+++++++++\",\"target.data.effects\", target.data.effects, \"effect\", effect)\n    let effectData = target.data.effects.contents.find(ef => ef.data.label === effect)\n    if (effectData) { // Found a Concentraining Effect\n        jez.log(`${target.name} has ${effect} effect`, effectData);\n        jez.log(`effectData._sourceName`, effectData._sourceName)\n        return(effectData);\n    } else {\n        jez.log(`${target.name} lacks ${effect} effect`);\n        return(false)\n    }\n}\n\n/***************************************************************************************************\n * Perform the code that runs when this macro is removed by DAE, set Off\n * \n * https://github.com/fantasycalendar/FoundryVTT-Sequencer/wiki/Sequencer-Effect-Manager#end-effects\n ***************************************************************************************************/\nasync function doOff() {\n    const FUNCNAME = \"doOff()\";\n    jez.log(\"--------------Off---------------------\", \"Starting\", `${MACRONAME} ${FUNCNAME}`);\n    jez.log(`doOff ---> Delete ${ATTACK_ITEM} from ${aToken.name} if it exists`, aActor)\n    // await deleteItem(ATTACK_ITEM, aActor);\n    await jez.deleteItems(ATTACK_ITEM, \"spell\", aActor);\n    jez.log(`doOff ---> Delete the VFX from ${MINION_UNIQUE_NAME}`)\n    await deleteVFX(MINION_UNIQUE_NAME);\n    jez.log(`doOff ---> Delete ${MINION_UNIQUE_NAME}'s token`)\n    await deleteToken(MINION_UNIQUE_NAME);\n    jez.log(\"--------------Off---------------------\", \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n    return;\n}\n\n/***************************************************************************************************\n * Perform the code that runs when this macro is removed by DAE, set On\n ***************************************************************************************************/\nasync function doOn() {\n    const FUNCNAME = \"doOn()\";\n    jez.log(\"--------------On---------------------\", \"Starting\", `${MACRONAME} ${FUNCNAME}`);\n    jez.log(\"Nothing to do\");\n    jez.log(\"--------------On---------------------\", \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n    return;\n}\n/***************************************************************************************\n * Function to delete an item from actor\n *\n * Parameters\n *  - itemName: A string naming the item to be found in actor's inventory\n *  - actor: Optional actor to be searched, defaults to actor launching this macro\n ***************************************************************************************/\nasync function deleteItem(itemName, actor) {\n    const FUNCNAME = \"deleteItem(itemName, actor)\";\n    jez.log(\"-------------------------------\",\n        \"Starting\", `${MACRONAME} ${FUNCNAME}`,\n        \"itemName\", itemName,\n        `actor ${actor?.name}`, actor);\n\n    // If actor was not passed, pick up the actor invoking this macro\n    actor = actor ? actor : canvas.tokens.get(args[0].tokenId).actor;\n\n    let item = actor.items.find(item => item.data.name === itemName && item.type === \"spell\")\n    jez.log(\"*** Item to be deleted:\", item);\n    if (item == null || item == undefined) {\n        jez.log(`${actor.name} does not have ${itemName}`);\n        jez.log(`${FUNCNAME} returning false`);\n        return (false);\n    }\n    jez.log(`${actor.name} had ${item.name}`, item);\n    // await aActor.deleteOwnedItem(item._id);                 // Obsoletes as of Foundry 9.x\n    await aActor.deleteEmbeddedDocuments(\"Item\", [item._id])   // Format as of Foundry 9.x \n    jez.log(`${FUNCNAME} returning true`);\n\n    jez.log(\"-----------------------------------\", \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n    return (true);\n}\n/***************************************************************************************\n * Function to delete all copies of a named item of a given type from actor\n *\n * Parameters\n *  - itemName: A string naming the item to be found in actor's inventory\n *  - subject: actor, token, or token Id to be searched\n *  - type: type of item to be deleted, e.g. spell, weapon \n ***************************************************************************************/\nasync function deleteItems(itemName, type, subject) {\n    let itemFound = null\n    let message = \"\"\n    let actor5e = null\n    //----------------------------------------------------------------------------------------------\n    // Validate the subject parameter, stashing it into \"actor5e\" variable\n    //\n    if (typeof (subject) === \"object\") {                   // Hopefully we have a Token5e or Actor5e\n        if (subject.constructor.name === \"Token5e\") actor5e = subject.actor\n        else {\n            if (subject.constructor.name === \"Actor5e\") actor5e = subject\n            else {\n                message = `Object passed to jez.deleteItems(...) is type \n                '${typeof (subject)}' must be a Token5e or Actor5e`\n                ui.notifications.error(message)\n                console.log(message)\n                return (false)\n            }\n        }\n    } else {\n        if ((typeof (subject) === \"string\") && (subject.length === 16))\n            actor5e = jez.getTokenById(subject).actor\n        else {\n            message = `Subject parm passed to jez.deleteItems(...) is not a Token5e, \n            Actor5e, or Token.id: ${subject}`\n            ui.notifications.error(message)\n            console.log(message)\n            return (false)\n        }\n    }\n    //----------------------------------------------------------------------------------------------\n    // Validate that Type is a string.\n    //\n    if (typeof (type) != \"string\") {\n        message = `Type parm passed to jez.deleteItems(...) is '${typeof (type)}'.  It\n        must be a string identifying a FoundryVTT item type (e.g. spell, weapon).`\n        ui.notifications.error(message)\n        console.log(message)\n        return (false)\n    }\n    //----------------------------------------------------------------------------------------------\n    // Look for matches and delete them.  Generating a message for each deletion\n    //\n    while (itemFound = actor5e.items.find(item => item.data.name === itemName && \n            item.type === type)) {\n        jez.log(\"itemFound\", itemFound)\n        await itemFound.delete();\n        msg = `Deleted ${type} ${itemName}`      // Set notification message\n        ui.notifications.info(msg);\n        jez.log(msg);\n    }\n}\n/***************************************************************************************************\n * Delete a specified token from the scene using a RunAsGM Macro\n ***************************************************************************************************/\nasync function deleteToken(minion) {\n    const FUNCNAME = \"deleteToken(minion)\";\n    const RUNASGMMACRO = \"DeleteTokenMacro\";\n    jez.log(\"-----------------------------------\",\n        \"Starting\", `${MACRONAME} ${FUNCNAME}`,\n        \"minion\", minion);\n\n    let delToken = await findTokenByName(minion)\n    if (!delToken) {\n        jez.log(\"Found only tears\")\n        jez.log(\"------------------------------ \", \"Premature End\", `${MACRONAME} ${FUNCNAME}`);\n        return (false);\n    }\n    //----------------------------------------------------------------------------------------------\n    // Make the call to delete the token\n    //\n    // await wait(2000)\n    game.macros.getName(RUNASGMMACRO).execute(delToken);\n\n    jez.log(\"-----------------------------------\", \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n    return (true);\n}\n\n/***************************************************************************************************\n * Delete a specified token from the scene using a RunAsGM Macro\n ***************************************************************************************************/\n async function deleteVFX(minion) {\n    const FUNCNAME = \"executeSummon(minion)\";\n    const RUNASGMMACRO = \"DeleteTokenMacro\";\n    jez.log(\"-----------------------------------\",\n        \"Starting\", `${MACRONAME} ${FUNCNAME}`,\n        \"minion\", minion);\n    let delToken = \"\"\n\n    // Find the token that matchs the specified name.  Return if not found.\n    //\n    let eToken = await findTokenByName(minion)\n    jez.log(`eToken ${eToken.name}`, eToken);\n    if (!eToken) {\n        jez.log(\"Found only tears\")\n        jez.log(\"------------------------------ \", \"Premature End\", `${MACRONAME} ${FUNCNAME}`);\n        return (false);\n    }\n    //----------------------------------------------------------------------------------------------\n    // Make the call to end the token effects\n    //\n    jez.log(\"eToken._object\", eToken._object)\n    await Sequencer.EffectManager.endEffects({ name: VFX_NAME, object: eToken });\n    jez.log(\"-----------------------------------\", \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n    return (true);\n}\n\n/***************************************************************************************************\n * Find an owned token by name on current scene.  Return the token or null if not found\n ***************************************************************************************************/\nasync function findTokenByName(name) {\n    const FUNCNAME = \"findTokenByName(name)\";\n    jez.log(\"-----------------------------------\",\n        \"Starting\", `${MACRONAME} ${FUNCNAME}`,\n        \"name\", name)\n    let targetToken = \"\"\n    //----------------------------------------------------------------------------------------------\n    // Loop through toens on the canvas looking for the one we seek\n    //\n    let ownedTokens = canvas.tokens.ownedTokens\n    for (let i = 0; i < ownedTokens.length; i++) {\n        // jez.log(`  ${i}) ${ownedTokens[i].name}`, ownedTokens[i]);\n        if (name === ownedTokens[i].name) {\n            // jez.log(\"Eureka I found it!\")\n            targetToken = ownedTokens[i]\n            break;\n        }\n    }\n    if (targetToken) jez.log(`${name}'s token has been found`, targetToken)\n    else jez.log(`${name}'s token was not found :-(`)\n    jez.log(\"-----------------------------------\", \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n    return (targetToken);\n}",
  "flags": {
    "combat-utility-belt": {
      "macroTrigger": ""
    },
    "advanced-macros": {
      "runAsGM": false
    },
    "exportSource": {
      "world": "travels-in-barovia",
      "system": "dnd5e",
      "coreVersion": "9.269",
      "systemVersion": "1.6.0"
    }
  }
}