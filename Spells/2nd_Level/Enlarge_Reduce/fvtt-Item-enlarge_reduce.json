{
  "name": "Enlarge/Reduce",
  "type": "spell",
  "img": "/systems/dnd5e/icons/spells/link-blue-2.jpg",
  "data": {
    "description": {
      "value": "<p>%TOKENNAME% attempts to cause a visible creature or an object within range to grow larger or smaller for the duration. Choose either a creature or an object that is neither worn nor carried. If the target is unwilling, it can make a Constitution saving throw. On a success, the spell has no effect.</p>\n<p>If the target is a creature, everything it is wearing and carrying changes size with it. Any item dropped by an affected creature returns to normal size at once.</p>\n<p><strong>Enlarge.</strong> The target's size doubles in all dimensions, and its weight is multiplied by eight. This growth increases its size by one category-- from Medium to Large, for example. <span style=\"text-decoration: underline;\">If there isn't enough room for the target to double its size, the creature or object attains the maximum possible size in the space available</span>. Until the spell ends, the target also has <strong>advantage on Strength checks and Strength saving throws</strong>. The target's weapons also grow to match its new size. While these weapons are enlarged, the target's attacks with them deal <strong>1d4 extra damage</strong>.</p>\n<p><strong>Reduce.</strong> The target's size is halved in all dimensions, and its weight is reduced to one-eighth of normal. This reduction decreases its size by one category--from Medium to Small, for example. Until the spell ends, the target also has disadvantage on Strength checks and Strength saving throws. The target's weapons also shrink to match its new size. While these weapons are reduced, the target's attacks with them <strong>deal 1d4 less damage</strong> (this can't reduce the damage below 1).</p>\n<hr />\n<p><strong>FoundryVTT</strong>: This spell is auomated for creatures.&nbsp; It does impose a limit on reducing tiny and enlarging gargantuan creatures, as the VTT does not support those sizes.</p>",
      "chat": "<p>You cause a creature or an object you can see within range to grow larger or smaller for the duration. Choose either a creature or an object that is neither worn nor carried. If the target is unwilling, it can make a Constitution saving throw. On a success, the spell has no effect.</p>\n<p>If the target is a creature, everything it is wearing and carrying changes size with it. Any item dropped by an affected creature returns to normal size at once.</p>\n<p><strong>Enlarge.</strong> The target's size doubles in all dimensions, and its weight is multiplied by eight. This growth increases its size by one category-- from Medium to Large, for example. If there isn't enough room for the target to double its size, the creature or object attains the maximum possible size in the space available. Until the spell ends, the target also has advantage on Strength checks and Strength saving throws. The target's weapons also grow to match its new size. While these weapons are enlarged, the target's attacks with them deal 1d4 extra damage.</p>\n<p><strong>Reduce.</strong> The target's size is halved in all dimensions, and its weight is reduced to one-eighth of normal. This reduction decreases its size by one category--from Medium to Small, for example. Until the spell ends, the target also has disadvantage on Strength checks and Strength saving throws. The target's weapons also shrink to match its new size. While these weapons are reduced, the target's attacks with them deal 1d4 less damage (this can't reduce the damage below 1).</p>",
      "unidentified": ""
    },
    "source": "Basic Rules, Player's Handbook pg 237",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": 1,
      "units": "minute"
    },
    "target": {
      "value": 1,
      "width": null,
      "units": "",
      "type": "creature"
    },
    "range": {
      "value": 30,
      "long": null,
      "units": "ft"
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "other",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": null
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "level": 2,
    "school": "trs",
    "components": {
      "value": "a pinch of powdered iron",
      "vocal": true,
      "somatic": true,
      "material": true,
      "ritual": false,
      "concentration": true
    },
    "materials": {
      "value": "a pinch of powdered iron",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "always",
      "prepared": false
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    }
  },
  "effects": [
    {
      "_id": "a7fBAHk1NcIg80wi",
      "flags": {
        "dae": {
          "transfer": false,
          "stackable": false,
          "specialDuration": [],
          "macroRepeat": "none"
        },
        "ActiveAuras": {
          "isAura": false,
          "ignoreSelf": false,
          "hidden": false,
          "height": false,
          "aura": "None",
          "radius": null
        }
      },
      "changes": [
        {
          "key": "macro.itemMacro",
          "value": "",
          "mode": 0,
          "priority": 0
        }
      ],
      "disabled": false,
      "duration": {
        "startTime": null
      },
      "icon": "systems/dnd5e/icons/spells/link-blue-2.jpg",
      "label": "Enlarge/Reduce",
      "tint": null,
      "transfer": false
    }
  ],
  "flags": {
    "ddbimporter": {
      "id": 136712,
      "definitionId": 2084,
      "entityTypeId": 435869154,
      "dndbeyond": {
        "lookup": "generic",
        "lookupName": "generic",
        "level": null,
        "castAtLevel": null
      },
      "sources": [
        {
          "sourceId": 1,
          "pageNumber": null,
          "sourceType": 2
        },
        {
          "sourceId": 2,
          "pageNumber": 237,
          "sourceType": 1
        }
      ],
      "tags": [
        "Buff"
      ]
    },
    "betterRolls5e": {
      "quickVersatile": {
        "altValue": true
      },
      "quickCharges": {
        "value": {
          "use": true,
          "resource": true
        },
        "altValue": {
          "use": true,
          "resource": true
        }
      }
    },
    "dae": {
      "activeEquipped": false,
      "alwaysActive": false
    },
    "midi-qol": {
      "onUseMacroName": "[postActiveEffects]ItemMacro",
      "effectActivation": false
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Enlarge/Reduce",
          "type": "script",
          "author": "ZjFlOWYxZjM5ZTZj",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const MACRONAME = \"Enlarge_Reduce_0.8.js\"\njez.log(MACRONAME)\n/*****************************************************************************************\n * Implement Enlarge/Reduce and allow a choice for the target to accept the effect or \n * attempt a saving throw.\n * \n * Requires: DAE Callback macro: ActorUpdate runAsGM\n * \n * DAE Macro.ItemMacro Execute, Effect Value = \"Macro Name\" @target **Maybe?**\n * \n * HTML Color Codes: https://www.w3schools.com/tags/ref_colornames.asp\n * \n * 01/07/22 0.1 Update Macro from what was already on the spell into my \"normal\" format\n * 01/07/22 0.2 Add dialog allowing acceptance of effect or forcing a saving throw\n * 01/09/22 0.4 Polishing the Apple\n *              - Remove the active effect on a successful save\n *              - Review the postResults messages, especially to show saveDC\n *              - Attempt to refresh token after size is changed\n *              - Test when used by a \"normal\" player\n * 01/10/22 0.5 Added generic functions to test argument types for Token5e and Actor5e\n * 01/10/22 0.6 Change the token update method to avoid apparent race condition\n * 05/03/22 0.7 Update for FoundryVTT 9.x (updateMany)\n * 06/28/22 0.8 Resolved permissions bug and added new library functions\n *****************************************************************************************/\nconst DEBUG = true;\nconst MACRO = MACRONAME.split(\".\")[0]     // Trim of the version number and extension\n// jez.log(\"---------------------------------------------------------------------------\", \"Starting\", `${MACRONAME}`);\n// for (let i = 0; i < args.length; i++) jez.log(`  args[${i}]`, args[i]);\nconst lastArg = args[args.length - 1];\nlet aActor;         // Acting actor, creature that invoked the macro\nlet aToken;         // Acting token, token for creature that invoked the macro\nlet aItem;          // Active Item information, item invoking this macro\nif (lastArg.tokenId) aActor = canvas.tokens.get(lastArg.tokenId).actor; else aActor = game.actors.get(lastArg.actorId);\nif (lastArg.tokenId) aToken = canvas.tokens.get(lastArg.tokenId); else aToken = game.actors.get(lastArg.tokenId);\nif (args[0]?.item) aItem = args[0]?.item; else aItem = lastArg.efData?.flags?.dae?.itemData;\nconst CUSTOM = 0, MULTIPLY = 1, ADD = 2, DOWNGRADE = 3, UPGRADE = 4, OVERRIDE = 5;\nconst SIZE_ARRAY = [\"error\", \"tiny\", \"sm\", \"med\", \"lg\", \"huge\", \"grg\"]\nlet msg = \"\";\nlet errorMsg = \"\";\nlet saveMsg = \"\";\nconst EFFECT_NAME = \"Enlarge/Reduce\"\nconst SAVE_DC = aActor.data.data.attributes.spelldc;\nconst SAVE_TYPE = \"CON\"\nconst GAME_RND = game.combat ? game.combat.round : 0;\n//----------------------------------------------------------------------------------\n// Run the preCheck function to make sure things are setup as best I can check them\n//\nif (!preCheck()) {\n    console.log(errorMsg)\n    ui.notifications.error(errorMsg)\n    return;\n}\n\n//----------------------------------------------------------------------------------\n// Run the main procedures, choosing based on how the macro was invoked\n//\nif (args[0] === \"off\") await doOff();                   // DAE removal\n//if (args[0] === \"on\") await doOn();                     // DAE Application\nif (args[0]?.tag === \"OnUse\") await doOnUse();          // Midi ItemMacro On Use\n\n// jez.log(\"---------------------------------------------------------------------------\",\"Finishing\", MACRONAME);\n\n/***************************************************************************************************\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ***************************************************************************************************/\n\n/***************************************************************************************************\n * Check the setup of things.  Setting the global errorMsg and returning true for ok!\n ***************************************************************************************************/\nfunction preCheck() {\n    if (args[0]?.tag === \"OnUse\") {\n        if (!oneTarget()) return (false)\n    }\n    // jez.log('All looks good, to quote Jean-Luc, \"MAKE IT SO!\"')\n    return (true)\n}\n\n/***************************************************************************************************\n * Perform the code that runs when this macro is invoked as an ItemMacro \"OnUse\"\n ***************************************************************************************************/\n async function doOnUse() {\n    const FUNCNAME = \"doOnUse()\";\n    let tToken = canvas.tokens.get(args[0]?.targets[0]?.id); // First Targeted Token, if any\n    let tActor = tToken?.actor;\n    // jez.log(\"--------------OnUse-----------------\", \"Starting\", `${MACRONAME} ${FUNCNAME}`);\n\n    DialogSaveOrAccept();\n\n    // jez.log(\"--------------OnUse-----------------\", \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n    return (true);\n\n    //----------------------------------------------------------------------------------\n    // \n    async function DialogSaveOrAccept() {\n        // jez.log(SAVE_TYPE.toLowerCase())\n        new Dialog({\n            title: \"Save or Accept Spell\",\n            content: `<div><h2>Attempt Save -OR- Accept Effect</h2>\n            <div><p style=\"color:Green;\">Does <b>${tToken.name}</b> want to attempt <b>DC${SAVE_DC}</b> \n            ${CONFIG.DND5E.abilities[SAVE_TYPE.toLowerCase()]} (${SAVE_TYPE}) save vs \n            ${aToken.name}'s ${aItem.name} spell/effect?</p><div>`,\n            buttons: {\n                save: {\n                    label: \"Attempt Save\",\n                    callback: (html) => {\n                        PerformCallback(html, \"Save\")\n                    }\n                },\n                accept: {\n                    label: \"Accept Effect\",\n                    callback: (html) => {\n                        PerformCallback(html, \"Accept\")\n                    }\n                },\n            },\n            default: \"abort\",\n        }).render(true);\n    }\n\n    //----------------------------------------------------------------------------------\n    // \n    async function PerformCallback(html, mode) {\n        // jez.log(\"PerformCallback() function executing.\", \"html\", html, \"mode\", mode);\n        let result = \"\";\n        if (mode === \"Save\") {\n            if (await attemptSave()) {  // Save was made\n                result = \"Saved\"\n                // jez.log(\"PerformCallback obtained status:\", result);\n                msg = `<p style=\"color:DarkRed;\"><b>${tToken.name}</b> avoids the effect of <b>${aToken.name}'s</b> ${aItem.name} \n                spell with a successful save.\n                ${saveMsg}`\n                postResults(msg);\n             } else {                    // Save failed\n                result = \"Failed\"\n                // jez.log(\"PerformCallback obtained status:\", result);\n                doEnlargeReduce();\n            }\n        } else if (mode === \"Accept\") {\n            result = \"Accepted\"\n            // jez.log(\"PerformCallback obtained status:\", result);\n            saveMsg = `<p>${tToken.name} <b>declined</b> to attempt a <b>DC${SAVE_DC} ${SAVE_TYPE}</b> saving throw.</p>`\n            doEnlargeReduce();\n        }\n    }\n    //----------------------------------------------------------------------------------\n    // Return true on success, false on failure\n    //\n    async function attemptSave() {\n        const FUNCNAME = \"attemptSave()\";\n        // jez.log(`--------------${FUNCNAME}-----------`, \"Starting\", `${MACRONAME} ${FUNCNAME}`);\n        let saved = false;\n\n        const flavor = `${CONFIG.DND5E.abilities[SAVE_TYPE.toLowerCase()]} <b>DC${SAVE_DC}</b>\n             to avoid <b>${aItem.name}</b> effect`;\n        // jez.log(\"---- Save Information ---\", \"SAVE_TYPE\", SAVE_TYPE, \"SAVE_DC\", SAVE_DC, \"flavor\", flavor);\n\n        let save = (await tActor.rollAbilitySave(SAVE_TYPE.toLowerCase(), { flavor, chatMessage: true, fastforward: true })).total;\n        // jez.log(\"save\", save);\n        if (save > SAVE_DC) {\n            // jez.log(`save was made with a ${save}`);\n            saved = true;\n            saveMsg = `<p style=\"color:Green;\">${tToken.name} <b>made</b> its save with a <b>${save}</b> \n                        versus a <b>DC${SAVE_DC} ${SAVE_TYPE}</b> saving throw.</p>`\n            // Remove the effect already applied by DAE to the target, testing to make sure it exists\n            let tActorExistingEffect = await tActor.effects.find(ef => ef.data.label === EFFECT_NAME)\n            if (tActorExistingEffect) {\n                // jez.log(\"\")\n                // jez.log(`Deleting existing effect`, tActorExistingEffect)\n                await tActorExistingEffect.delete();\n            } else {\n                let msg = `${tToken.name} lacks the ${EFFECT_NAME} effect. This shouldn't happen.`\n                ui.notifications.error(mesg);\n                // jez.log(\"\")\n                // jez.log(msg);\n                return (false);\n            }\n        } else {\n            saveMsg = `<p style=\"color:Red;\">${tToken.name} <b>failed</b> its save with a \n                        <b>${save}</b> versus a <b>DC${SAVE_DC} ${SAVE_TYPE}</b> saving throw.</p>`\n            // jez.log(`save failed with a ${save}`);\n        }\n        // addLightEffect(args[0].uuid, tActor, 60, colorCodes[selection])\n        // jez.log(\"--------------${FUNCNAME}-----------\", \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n        return (saved);\n    }\n    //----------------------------------------------------------------------------------\n    // Actually do the enlarge or reduce\n    //\n    async function doEnlargeReduce() {\n        const FUNCNAME = \"doEnlargeReduce()\";\n        // jez.log(`--------------${FUNCNAME}---------------------`, \"Starting\", `${MACRONAME} ${FUNCNAME}`);\n        let originalWidth = tToken.data.width;\n        let mwak = tActor.data.data.bonuses.mwak.damage;\n        let ogSizeValue = sizeOfToken(tToken); // Original Size of token, 1 = Tiny, ..., 6 = Gargantuan\n        let ogSize = tActor.data.data.traits.size;\n        let ogScale = tActor.data.token.scale;\n        let newScale = ogScale\n        let newWidth = originalWidth\n        await DAE.setFlag(tActor, 'enlageReduceSpell', {\n            \"width\": originalWidth,\n            \"ogMwak\": mwak,\n            \"ogSize\": ogSize,\n            \"ogScale\": ogScale \n        });\n        // jez.log(\"========> tActor.data\", tActor.data)\n        // jez.log(\"========> tActor.data.token.scale\", tActor.data.token.scale)\n        await new Dialog({\n            title: \"Enlarge or Reduce\",\n            buttons: {\n                one: {\n                    label: \"Enlarge\",\n                    callback: async () => {\n                        // jez.log(\"Choice made: Enlarge\")\n                        let bonus = mwak + \"+1d4\";\n                        //------------------------------------------------------------------------------\n                        // Scale our token if it is tiny or small, Change width if it is medium or larger\n                        if (ogSizeValue === 1) { newWidth = 0.8; newScale = 1 }\n                        else if (ogSizeValue === 2) newScale = Math.min(1.1, ogScale * 1.5)\n                        else if (ogSizeValue < 6) newWidth = (originalWidth + 1);\n                        //------------------------------------------------------------------------------\n                        if (ogSizeValue > 5) {\n                            msg = `<p style=\"color:Brown;\"><b>${aToken.name}'s</b> attempt to <b>enlarge</b> ${tToken.name} \n                                    fizzles. <b>${tToken.name}</b> is too large to be further enlarged<p>`\n                            postResults(msg);\n                            return (false);\n                        }\n                        // jez.log(\"Ready to call tActor.update\", \"bonus\", bonus, \"SIZE_ARRAY[ogSizeValue + 1]\", SIZE_ARRAY[ogSizeValue + 1])\n                        // The next line throws a permission error of the form:\n                        // --> Uncaught (in promise) Error: User Jon M. lacks permission to update Actor \n                        // await tActor.update({ \"data.bonuses.mwak.damage\":bonus, \"data.traits.size\":SIZE_ARRAY[ogSizeValue + 1] }); \n                        await jez.actorUpdate(tToken, { \"data.bonuses.mwak.damage\": bonus, \"data.traits.size\": SIZE_ARRAY[ogSizeValue + 1] })\n                        await updateTokenHeightWidth(tToken, newWidth, newScale);\n                        // The next line throws a permission error of the form (ALSO IT SEEMS UNEEDED):\n                        // --> Uncaught (in promise) Error: User Jon M. lacks permission to update Token [rveDGfJ0ygwzHYFb] in parent Scene [MzEyYTVkOTQ4NmZk]\n                        // await tToken.refresh();  // Causes the token to be redrawn *NOW*\n                        // jez.log(`tToken ${tToken.name}`, tToken)\n                        msg = `<p style=\"color:DarkGreen;\">\n                                <b>${aToken.name}'s</b> attempt to <b>enlarge</b> ${tToken.name} is met with success!.</p>\n                                ${saveMsg}\n                                <p>${tToken.name} is now one size category larger.</p>`\n                        postResults(msg);\n                    }\n                },\n                two: {\n                    label: \"Reduce\",\n                    callback: async () => {\n                        // jez.log(\"Choice made: Reduce\")\n                        let bonus = mwak + \"-1d4\";\n                        //------------------------------------------------------------------------------\n                        // Do some funky scaling\n                        if (ogSizeValue === 1) {}\n                        else if (ogSizeValue === 2) { newWidth = 0.5; newScale = 1 }\n                        else if (ogSizeValue === 3) newScale = Math.max(0.7, ogScale * 0.7)\n                        else newWidth = originalWidth - 1;\n                        //------------------------------------------------------------------------------\n                        if (ogSizeValue < 2) {\n                            msg = `<p style=\"color:Brown;\"><b>${aToken.name}'s</b> attempt to <b>reduce</b> ${tToken.name} \n                                    fails. ${tToken.name} is too small to be further reduced.<p>`\n                            postResults(msg);\n                            return (false);\n                        }\n                        await jez.actorUpdate(tToken, { \"data.bonuses.mwak.damage\": bonus, \"data.traits.size\": SIZE_ARRAY[ogSizeValue - 1] })\n                        // jez.log(\"newWidth\", newWidth)\n                        await updateTokenHeightWidth(tToken, newWidth, newScale);\n                        msg = `<p style=\"color:DarkGreen;\"><b>${aToken.name}'s</b> attempt to <b>reduce</b> \n                                ${tToken.name} is met with success!.<p>\n                                ${saveMsg}\n                                ${tToken.name} is now one size category smaller.</p>`\n                        postResults(msg);\n                    }\n                },\n            }\n        }).render(true);\n        // jez.log(`--------------${FUNCNAME}---------------------`, \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n        return;\n    }\n\n    //----------------------------------------------------------------------------------\n    // Obtain size of the target\n    //\n    function sizeOfToken(token1) {\n        const FUNCNAME = \"sizeOfToken(token1)\";\n        // jez.log(`--------------${FUNCNAME}---------------------`, \"Starting\", `${MACRONAME} ${FUNCNAME}`, \"token1\", token1);\n        class CreatureSizes {\n            constructor(size) {\n                this.SizeString = size;\n                switch (size) {\n                    case \"tiny\": this.SizeInt = 1; break;   // 2.5 feet 1/2x1/2\n                    case \"sm\": this.SizeInt = 2; break;     // 5.0 feet   1x1\n                    case \"med\": this.SizeInt = 3; break;    // 5.0 feet   1x1   \n                    case \"lg\": this.SizeInt = 4; break;     // 10  feet   2x2\n                    case \"huge\": this.SizeInt = 5; break;   // 15  feet   3x3\n                    case \"grg\": this.SizeInt = 6; break;    // 20  feet   4x4\n                    default: this.SizeInt = 0;  // Error\n                }\n            }\n        }\n\n        let token1SizeString = token1.document._actor.data.data.traits.size;\n        let token1SizeObject = new CreatureSizes(token1SizeString);\n        let token1Size = token1SizeObject.SizeInt;  // Returns 0 on failure to match size string\n        if (!token1Size) {\n            errorMsg = `Size of ${token1.name}, ${token1SizeString} failed to parse. End ${macroName}<br>`;\n            // jez.log(errorMsg);\n            ui.notifications.error(errorMsg);\n            return (99);\n        }\n        // jez.log(`=====> Token1 ${token1.name}: ${token1SizeString} ${token1Size}`)\n        return (token1Size);\n    }\n}\n/************************************************************************\n * Verify exactly one target selected, boolean return\n ************************************************************************/\nasync function updateTokenHeightWidth(tok, newWidth, newScale) {\n    const FUNCNAME = \"updateTokenHeightWidth(tok, newWidth, newScale)\"\n    // jez.log(`--- Starting --- ${MACRONAME} ${FUNCNAME} ---`, \"tok\", tok, \"newWidth\", newWidth, \"newScale\", newScale);\n    if (jez.isToken5e(tok)) {\n        // jez.log(`Update ${tok.name} updating width to ${newWidth}`)\n        let updates = [];\n        updates.push({\n            _id: tok.id,\n            height: newWidth,\n            scale: newScale,\n            width: newWidth\n        });\n        // jez.log(\"updates\", updates)\n        // canvas.tokens.updateMany(updates);                               // Depricated \n        // The next line throws a permission error of the form:\n        //   Uncaught (in promise) Error: User Jon M. lacks permission to update Token [rveDGfJ0ygwzHYFb] in parent Scene [MzEyYTVkOTQ4NmZk]\n        // game.scenes.current.updateEmbeddedDocuments(\"Token\", updates);   // FoundryVTT 9.x \n        await jez.updateEmbeddedDocs(\"Token\", updates)  \n    } else {\n        errorMsg = `Argument passed was not of object type Token5e`\n        // jez.log(errorMsg, tok)\n        ui.notifications.error(errorMsg)\n        // jez.log(`--- Ending --- ${MACRONAME} ${FUNCNAME} --- false`);\n        return (false)\n    }\n    // jez.log(`--- Ended --- ${MACRONAME} ${FUNCNAME} ---`);\n}\n/************************************************************************\n * Verify exactly one target selected, boolean return\n ************************************************************************/\nfunction oneTarget() {\n    if (!game.user.targets) {\n        errorMsg = `Targeted nothing, must target single token to be acted upon`;\n        // jez.log(errorMsg);\n        return (false);\n    }\n    if (game.user.targets.ids.length != 1) {\n        errorMsg = `Target a single token to be acted upon. Targeted ${game.user.targets.ids.length} tokens`;\n        // jez.log(errorMsg);\n        return (false);\n    }\n    // jez.log(`Targeting one target, a good thing`);\n    return (true);\n}\n/***************************************************************************************************\n * Perform the code that runs when this macro is removed by DAE, set Off\n * \n * https://github.com/fantasycalendar/FoundryVTT-Sequencer/wiki/Sequencer-Effect-Manager#end-effects\n ***************************************************************************************************/\nasync function doOff() {\n    const FUNCNAME = \"doOff()\";\n    // jez.log(\"--------------Off---------------------\", \"Starting\", `${MACRONAME} ${FUNCNAME}`);\n    let flag = DAE.getFlag(aActor, 'enlageReduceSpell');\n    jez.log(\"flag\", flag)\n    if (flag) {\n        await aActor.update({\n            \"data.bonuses.mwak.damage\": flag.ogMwak,\n            \"data.traits.size\": flag.ogSize\n        });\n\n        await updateTokenHeightWidth(aToken, flag.width, flag.ogScale);\n        // aToken.refresh();  // Causes the token to be redrawn *NOW*\n\n        // await aToken.document.data.update({\"width\": flag.width,\"height\": flag.width});\n        await DAE.unsetFlag(aActor, 'enlageReduceSpell');\n        ChatMessage.create({ content: `<b>${aToken.name}</b> is returned to normal size` });\n    } else {\n        msg = `\"DAE.getFlag(aActor, 'enlageReduceSpell') did not find flag value.`\n        console.log(msg)\n    }\n    // jez.log(\"--------------Off---------------------\", \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n    return;\n}\n/***************************************************************************************************\n * Post the results to chat card\n ***************************************************************************************************/\n async function postResults(resultsString) {\n    const lastArg = args[args.length - 1];\n    let chatMessage = game.messages.get(lastArg.itemCardId);\n    let content = await duplicate(chatMessage.data.content);\n    // jez.log(`chatMessage: `,chatMessage);\n    const searchString = /<div class=\"midi-qol-other-roll\">[\\s\\S]*<div class=\"end-midi-qol-other-roll\">/g;\n    const replaceString = `<div class=\"midi-qol-other-roll\"><div class=\"end-midi-qol-other-roll\">${resultsString}`;\n    content = await content.replace(searchString, replaceString);\n    await chatMessage.update({ content: content });\n    await ui.chat.scrollBottom();\n    return;\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "cf": {
      "id": "temp_kw1jjhsz8u"
    },
    "core": {
      "sourceId": "Compendium.My-Shared-DDB.spells.Kvb74CDrE78n10mK"
    },
    "enhancedcombathud": {
      "set1p": false,
      "set2p": false,
      "set3p": false
    },
    "betterCurses": {
      "isCurse": false,
      "curseName": "",
      "formula": "",
      "mwak": false,
      "rwak": false,
      "msak": false,
      "rsak": false
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "exportSource": {
      "world": "travels-in-barovia",
      "system": "dnd5e",
      "coreVersion": "9.269",
      "systemVersion": "1.6.2"
    }
  }
}