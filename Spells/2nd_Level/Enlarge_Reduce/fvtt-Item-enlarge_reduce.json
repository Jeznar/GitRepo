{
  "name": "Enlarge/Reduce",
  "type": "spell",
  "img": "/systems/dnd5e/icons/spells/link-blue-2.jpg",
  "data": {
    "description": {
      "value": "<p>You cause a creature or an object you can see within range to grow larger or smaller for the duration. Choose either a creature or an object that is neither worn nor carried. If the target is unwilling, it can make a Constitution saving throw. On a success, the spell has no effect.</p>\n<p>If the target is a creature, everything it is wearing and carrying changes size with it. Any item dropped by an affected creature returns to normal size at once.</p>\n<p><strong>Enlarge.</strong> The target's size doubles in all dimensions, and its weight is multiplied by eight. This growth increases its size by one category-- from Medium to Large, for example. If there isn't enough room for the target to double its size, the creature or object attains the maximum possible size in the space available. Until the spell ends, the target also has advantage on Strength checks and Strength saving throws. The target's weapons also grow to match its new size. While these weapons are enlarged, the target's attacks with them deal 1d4 extra damage.</p>\n<p><strong>Reduce.</strong> The target's size is halved in all dimensions, and its weight is reduced to one-eighth of normal. This reduction decreases its size by one category--from Medium to Small, for example. Until the spell ends, the target also has disadvantage on Strength checks and Strength saving throws. The target's weapons also shrink to match its new size. While these weapons are reduced, the target's attacks with them deal 1d4 less damage (this can't reduce the damage below 1).</p>",
      "chat": "<p>You cause a creature or an object you can see within range to grow larger or smaller for the duration. Choose either a creature or an object that is neither worn nor carried. If the target is unwilling, it can make a Constitution saving throw. On a success, the spell has no effect.</p>\n<p>If the target is a creature, everything it is wearing and carrying changes size with it. Any item dropped by an affected creature returns to normal size at once.</p>\n<p><strong>Enlarge.</strong> The target's size doubles in all dimensions, and its weight is multiplied by eight. This growth increases its size by one category-- from Medium to Large, for example. If there isn't enough room for the target to double its size, the creature or object attains the maximum possible size in the space available. Until the spell ends, the target also has advantage on Strength checks and Strength saving throws. The target's weapons also grow to match its new size. While these weapons are enlarged, the target's attacks with them deal 1d4 extra damage.</p>\n<p><strong>Reduce.</strong> The target's size is halved in all dimensions, and its weight is reduced to one-eighth of normal. This reduction decreases its size by one category--from Medium to Small, for example. Until the spell ends, the target also has disadvantage on Strength checks and Strength saving throws. The target's weapons also shrink to match its new size. While these weapons are reduced, the target's attacks with them deal 1d4 less damage (this can't reduce the damage below 1).</p>",
      "unidentified": ""
    },
    "source": "Basic Rules, Player's Handbook pg 237",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": 1,
      "units": "minute"
    },
    "target": {
      "value": 1,
      "width": null,
      "units": "",
      "type": "creature"
    },
    "range": {
      "value": 30,
      "long": null,
      "units": "ft"
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "other",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": null
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "level": 2,
    "school": "trs",
    "components": {
      "value": "a pinch of powdered iron",
      "vocal": true,
      "somatic": true,
      "material": true,
      "ritual": false,
      "concentration": true
    },
    "materials": {
      "value": "a pinch of powdered iron",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "prepared",
      "prepared": false
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    }
  },
  "effects": [
    {
      "_id": "a7fBAHk1NcIg80wi",
      "flags": {
        "dae": {
          "transfer": false,
          "stackable": false,
          "specialDuration": [],
          "macroRepeat": "none"
        },
        "ActiveAuras": {
          "isAura": false,
          "ignoreSelf": false,
          "hidden": false,
          "height": false,
          "aura": "None",
          "radius": null
        }
      },
      "changes": [
        {
          "key": "macro.itemMacro",
          "value": "",
          "mode": 0,
          "priority": 0
        }
      ],
      "disabled": false,
      "duration": {
        "startTime": null
      },
      "icon": "systems/dnd5e/icons/spells/link-blue-2.jpg",
      "label": "Enlarge/Reduce",
      "tint": null,
      "transfer": false
    }
  ],
  "sort": 0,
  "flags": {
    "ddbimporter": {
      "id": 136712,
      "definitionId": 2084,
      "entityTypeId": 435869154,
      "dndbeyond": {
        "lookup": "generic",
        "lookupName": "generic",
        "level": null,
        "castAtLevel": null
      },
      "sources": [
        {
          "sourceId": 1,
          "pageNumber": null,
          "sourceType": 2
        },
        {
          "sourceId": 2,
          "pageNumber": 237,
          "sourceType": 1
        }
      ],
      "tags": [
        "Buff"
      ]
    },
    "betterRolls5e": {
      "quickVersatile": {
        "altValue": true
      },
      "quickCharges": {
        "value": {
          "use": true,
          "resource": true
        },
        "altValue": {
          "use": true,
          "resource": true
        }
      }
    },
    "dae": {
      "activeEquipped": false,
      "alwaysActive": false
    },
    "midi-qol": {
      "onUseMacroName": "ItemMacro"
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Enlarge/Reduce",
          "type": "script",
          "author": "ZjFlOWYxZjM5ZTZj",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const MACRONAME = \"Enlarge_Reduce_0.7.js\"\nconsole.log(MACRONAME)\n/*****************************************************************************************\n * Implement Enlarge/Reduce and allow a choice for the target to accept the effect or \n * attempt a saving throw.\n * \n * DAE Macro.ItemMacro Execute, Effect Value = \"Macro Name\" @target **Maybe?**\n * \n * HTML Color Codes: https://www.w3schools.com/tags/ref_colornames.asp\n * \n * 01/07/22 0.1 Update Macro from what was already on the spell into my \"normal\" format\n * 01/07/22 0.2 Add dialog allowing acceptance of effect or forcing a saving throw\n * 01/09/22 0.4 Polishing the Apple\n *              - Remove the active effect on a successful save\n *              - Review the postResults messages, especially to show saveDC\n *              - Attempt to refresh token after size is changed\n *              - Test when used by a \"normal\" player\n * 01/10/22 0.5 Added generic functions to test argument types for Token5e and Actor5e\n * 01/10/22 0.6 Change the token update method to avoid apparent race condition\n * 05/03/22 0.7 Update for FoundryVTT 9.x (updateMany)\n *****************************************************************************************/\nconst DEBUG = true;\nconst MACRO = MACRONAME.split(\".\")[0]     // Trim of the version number and extension\nlog(\"---------------------------------------------------------------------------\",\n    \"Starting\", `${MACRONAME}`);\nfor (let i = 0; i < args.length; i++) log(`  args[${i}]`, args[i]);\nconst lastArg = args[args.length - 1];\nlet aActor;         // Acting actor, creature that invoked the macro\nlet aToken;         // Acting token, token for creature that invoked the macro\nlet aItem;          // Active Item information, item invoking this macro\nif (lastArg.tokenId) aActor = canvas.tokens.get(lastArg.tokenId).actor; else aActor = game.actors.get(lastArg.actorId);\nif (lastArg.tokenId) aToken = canvas.tokens.get(lastArg.tokenId); else aToken = game.actors.get(lastArg.tokenId);\nif (args[0]?.item) aItem = args[0]?.item; else aItem = lastArg.efData?.flags?.dae?.itemData;\nconst CUSTOM = 0, MULTIPLY = 1, ADD = 2, DOWNGRADE = 3, UPGRADE = 4, OVERRIDE = 5;\nconst SIZE_ARRAY = [\"error\", \"tiny\", \"sm\", \"med\", \"lg\", \"huge\", \"grg\"]\nlog(\"------- Global Values Set -------\",\n    `Active Token (aToken) ${aToken?.constructor.name} ${aToken?.name}`, aToken,\n    `Active Actor (aActor) ${aActor?.constructor.name} ${aActor?.name}`, aActor,\n    `Active Item (aItem) ${aItem?.constructor.name} ${aItem?.name}`, aItem)\nlet msg = \"\";\nlet errorMsg = \"\";\nlet saveMsg = \"\";\nconst EFFECT_NAME = \"Enlarge/Reduce\"\nconst SAVE_DC = aActor.data.data.attributes.spelldc;\nconst SAVE_TYPE = \"CON\"\nconst GAME_RND = game.combat ? game.combat.round : 0;\n\n//----------------------------------------------------------------------------------\n// Run the preCheck function to make sure things are setup as best I can check them\n//\nif (!preCheck()) {\n    console.log(errorMsg)\n    ui.notifications.error(errorMsg)\n    return;\n}\n\n//----------------------------------------------------------------------------------\n// Run the main procedures, choosing based on how the macro was invoked\n//\nif (args[0] === \"off\") await doOff();                   // DAE removal\n//if (args[0] === \"on\") await doOn();                     // DAE Application\nif (args[0]?.tag === \"OnUse\") await doOnUse();          // Midi ItemMacro On Use\n\nlog(\"---------------------------------------------------------------------------\",\n    \"Finishing\", MACRONAME);\n\nreturn;\n/***************************************************************************************************\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ***************************************************************************************************/\n\n/***************************************************************************************************\n * Check the setup of things.  Setting the global errorMsg and returning true for ok!\n ***************************************************************************************************/\nfunction preCheck() {\n    if (args[0]?.tag === \"OnUse\") {\n        if (!oneTarget()) return (false)\n    }\n    log('All looks good, to quote Jean-Luc, \"MAKE IT SO!\"')\n    return (true)\n}\n\n/***************************************************************************************************\n * Perform the code that runs when this macro is invoked as an ItemMacro \"OnUse\"\n ***************************************************************************************************/\n async function doOnUse() {\n    const FUNCNAME = \"doOnUse()\";\n    let tToken = canvas.tokens.get(args[0]?.targets[0]?.id); // First Targeted Token, if any\n    let tActor = tToken?.actor;\n    log(\"--------------OnUse-----------------\", \"Starting\", `${MACRONAME} ${FUNCNAME}`,\n        `First Targeted Token (tToken) of ${args[0].targets?.length}, ${tToken?.name}`, tToken,\n        `First Targeted Actor (tActor) ${tActor?.name}`, tActor);\n\n    DialogSaveOrAccept();\n\n    log(\"--------------OnUse-----------------\", \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n    return (true);\n\n    //----------------------------------------------------------------------------------\n    // \n    async function DialogSaveOrAccept() {\n        log(SAVE_TYPE.toLowerCase())\n        new Dialog({\n            title: \"Save or Accept Spell\",\n            content: `<div><h2>Attempt Save -OR- Accept Effect</h2>\n            <div><p style=\"color:Green;\">Does <b>${tToken.name}</b> want to attempt <b>DC${SAVE_DC}</b> \n            ${CONFIG.DND5E.abilities[SAVE_TYPE.toLowerCase()]} (${SAVE_TYPE}) save vs \n            ${aToken.name}'s ${aItem.name} spell/effect?</p><div>`,\n            buttons: {\n                save: {\n                    label: \"Attempt Save\",\n                    callback: (html) => {\n                        PerformCallback(html, \"Save\")\n                    }\n                },\n                accept: {\n                    label: \"Accept Effect\",\n                    callback: (html) => {\n                        PerformCallback(html, \"Accept\")\n                    }\n                },\n            },\n            default: \"abort\",\n        }).render(true);\n    }\n\n    //----------------------------------------------------------------------------------\n    // \n    async function PerformCallback(html, mode) {\n        log(\"PerformCallback() function executing.\", \"html\", html, \"mode\", mode);\n        let result = \"\";\n        if (mode === \"Save\") {\n            if (await attemptSave()) {  // Save was made\n                result = \"Saved\"\n                log(\"PerformCallback obtained status:\", result);\n                msg = `<p style=\"color:DarkRed;\"><b>${tToken.name}</b> avoids the effect of <b>${aToken.name}'s</b> ${aItem.name} \n                spell with a successful save.\n                ${saveMsg}`\n                postResults(msg);\n             } else {                    // Save failed\n                result = \"Failed\"\n                log(\"PerformCallback obtained status:\", result);\n                doEnlargeReduce();\n            }\n        } else if (mode === \"Accept\") {\n            result = \"Accepted\"\n            log(\"PerformCallback obtained status:\", result);\n            saveMsg = `<p>${tToken.name} <b>declined</b> to attempt a <b>DC${SAVE_DC} ${SAVE_TYPE}</b> saving throw.</p>`\n            doEnlargeReduce();\n        }\n    }\n    //----------------------------------------------------------------------------------\n    // Return true on success, false on failure\n    //\n     async function attemptSave() {\n         const FUNCNAME = \"attemptSave()\";\n         log(`--------------${FUNCNAME}-----------`, \"Starting\", `${MACRONAME} ${FUNCNAME}`);\n         let saved = false;\n\n         const flavor = `${CONFIG.DND5E.abilities[SAVE_TYPE.toLowerCase()]} <b>DC${SAVE_DC}</b>\n             to avoid <b>${aItem.name}</b> effect`;\n         log(\"---- Save Information ---\", \"SAVE_TYPE\", SAVE_TYPE, \"SAVE_DC\", SAVE_DC, \"flavor\", flavor);\n\n         let save = (await tActor.rollAbilitySave(SAVE_TYPE.toLowerCase(), { flavor, chatMessage: true, fastforward: true })).total;\n         log(\"save\", save);\n         if (save > SAVE_DC) {\n             log(`save was made with a ${save}`);\n             saved = true;\n             saveMsg = `<p style=\"color:Green;\">${tToken.name} <b>made</b> its save with a <b>${save}</b> \n                        versus a <b>DC${SAVE_DC} ${SAVE_TYPE}</b> saving throw.</p>`          \n             // Remove the effect already applied by DAE to the target, testing to make sure it exists\n             let tActorExistingEffect = await tActor.effects.find(ef => ef.data.label === EFFECT_NAME)\n             if (tActorExistingEffect) {\n                 log(\"\")\n                 log(`Deleting existing effect`, tActorExistingEffect)\n                 await tActorExistingEffect.delete();\n             } else {\n                 let msg = `${tToken.name} lacks the ${EFFECT_NAME} effect. This shouldn't happen.`\n                 ui.notifications.error(mesg);\n                 log(\"\")\n                 log(msg);\n                 return (false);\n             }\n         } else {\n             saveMsg = `<p style=\"color:Red;\">${tToken.name} <b>failed</b> its save with a \n                        <b>${save}</b> versus a <b>DC${SAVE_DC} ${SAVE_TYPE}</b> saving throw.</p>`\n             log(`save failed with a ${save}`);\n         }\n         // addLightEffect(args[0].uuid, tActor, 60, colorCodes[selection])\n         log(\"--------------${FUNCNAME}-----------\", \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n         return (saved);\n     }\n\n     //----------------------------------------------------------------------------------\n     // Actually do the enlarge or reduce\n     //\n     async function doEnlargeReduce() {\n         const FUNCNAME = \"doEnlargeReduce()\";\n         log(`--------------${FUNCNAME}---------------------`, \"Starting\", `${MACRONAME} ${FUNCNAME}`);\n         let originalWidth = tToken.data.width;\n         let mwak = tActor.data.data.bonuses.mwak.damage;\n         let ogSizeValue = sizeOfToken(tToken); // Original Size of token, 1 = Tiny, ..., 6 = Gargantuan\n         let ogSize = tActor.data.data.traits.size;\n         await DAE.setFlag(tActor, 'enlageReduceSpell', {\n            \"width\": originalWidth,\n            \"ogMwak\": mwak,\n            \"ogSize\": ogSize\n        });\n\n         await new Dialog({\n             title: \"Enlarge or Reduce\",\n             buttons: {\n                 one: {\n                     label: \"Enlarge\",\n                     callback: async () => {\n                         log(\"Choice made: Enlarge\")\n                         let bonus = mwak + \"+1d4\";\n                         let newWidth = (originalWidth + 1);\n                         if (ogSizeValue > 5) { \n                             msg = `<p style=\"color:Brown;\"><b>${aToken.name}'s</b> attempt to <b>enlarge</b> ${tToken.name} \n                                    fizzles. <b>${tToken.name}</b> is too large to be further enlarged<p>`\n                             postResults(msg);\n                             return (false);\n                         }\n                         await tActor.update({ \"data.bonuses.mwak.damage\": bonus, \n                                               \"data.traits.size\": SIZE_ARRAY[ogSizeValue + 1] });\n                         await jezUpdateTokenHeightWidth(tToken, newWidth);\n                         tToken.refresh();  // Causes the token to be redrawn *NOW*\n                         log(`tToken ${tToken.name}`, tToken)\n                         msg = `<p style=\"color:DarkGreen;\">\n                                <b>${aToken.name}'s</b> attempt to <b>enlarge</b> ${tToken.name} is met with success!.</p>\n                                ${saveMsg}\n                                <p>${tToken.name} is now one size category larger.</p>`\n                         postResults(msg);\n                     }\n                 },\n                 two: {\n                     label: \"Reduce\",\n                     callback: async () => {\n                         log(\"Choice made: Reduce\")\n                         let bonus = mwak + \"-1d4\";\n                         let newWidth = (originalWidth > 1) ? (originalWidth - 1) : (originalWidth - 0.25);\n                         if (ogSizeValue < 2) {\n                             msg = `<p style=\"color:Brown;\"><b>${aToken.name}'s</b> attempt to <b>enlarge</b> ${tToken.name} \n                                    fails. ${tToken.name} is too small to be further reduced.<p>`\n                             postResults(msg);\n                             return (false);\n                         }\n                         await tActor.update({ \"data.bonuses.mwak.damage\": bonus, \"data.traits.size\": SIZE_ARRAY[ogSizeValue - 1] });\n                         await jezUpdateTokenHeightWidth(tToken, newWidth);\n                         msg = `<p style=\"color:DarkGreen;\"><b>${aToken.name}'s</b> attempt to <b>reduce</b> \n                                ${tToken.name} is met with success!.<p>\n                                ${saveMsg}\n                                ${tToken.name} is now one size category smaller.</p>`\n                         postResults(msg);\n                         await wait(500);\n                         await tToken.refresh();  // Causes the token to be redrawn *NOW*\n                     }\n                 },\n             }\n         }).render(true);\n         log(`--------------${FUNCNAME}---------------------`, \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n         return;\n     }\n\n     //----------------------------------------------------------------------------------\n     // Obtain size of the target\n     //\n     function sizeOfToken(token1) {\n         const FUNCNAME = \"sizeOfToken(token1)\";\n         log(`--------------${FUNCNAME}---------------------`, \"Starting\", `${MACRONAME} ${FUNCNAME}`, \"token1\", token1);\n         class CreatureSizes {\n             constructor(size) {\n                 this.SizeString = size;\n                 switch (size) {\n                     case \"tiny\": this.SizeInt = 1; break;\n                     case \"sm\": this.SizeInt = 2; break;\n                     case \"med\": this.SizeInt = 3; break;\n                     case \"lg\": this.SizeInt = 4; break;\n                     case \"huge\": this.SizeInt = 5; break;\n                     case \"grg\": this.SizeInt = 6; break;\n                     default: this.SizeInt = 0;  // Error Condition\n                 }\n             }\n         }\n         \n         let token1SizeString = token1.document._actor.data.data.traits.size;\n         let token1SizeObject = new CreatureSizes(token1SizeString);\n         let token1Size = token1SizeObject.SizeInt;  // Returns 0 on failure to match size string\n         if (!token1Size) {\n             errorMsg = `Size of ${token1.name}, ${token1SizeString} failed to parse. End ${macroName}<br>`;\n             log(errorMsg);\n             ui.notifications.error(errorMsg);\n             return (99);\n         }\n         log(`=====> Token1 ${token1.name}: ${token1SizeString} ${token1Size}`)\n         return (token1Size);\n     }\n}\n\n/************************************************************************\n * Verify exactly one target selected, boolean return\n ************************************************************************/\nasync function jezUpdateTokenHeightWidth(tok, newWidth) {\n    if (jezIsToken5e(tok)) {\n        log(`Update ${tok.name} updating width to ${newWidth}`)\n        let updates = [];\n        updates.push({\n            _id: tok.id,\n            height: newWidth,\n            width: newWidth\n        });\n        // canvas.tokens.updateMany(updates);                           // Depricated \n        game.scenes.current.updateEmbeddedDocuments(\"Token\", updates);  // FoundryVTT 9.x \n        return(true);\n    } else {\n        errorMsg = `Argument passed was not of object type Token5e`\n        log(errorMsg, tok)\n        ui.notifications.error(errorMsg)\n        return(false)\n    }\n}\n\n/************************************************************************\n * Verify exactly one target selected, boolean return\n ************************************************************************/\nfunction oneTarget() {\n    if (!game.user.targets) {\n        errorMsg = `Targeted nothing, must target single token to be acted upon`;\n        log(errorMsg);\n        return (false);\n    }\n    if (game.user.targets.ids.length != 1) {\n        errorMsg = `Target a single token to be acted upon. Targeted ${game.user.targets.ids.length} tokens`;\n        log(errorMsg);\n        return (false);\n    }   \n    log(`Targeting one target, a good thing`);\n    return (true);\n}\n\n\n\n/***************************************************************************************************\n * Perform the code that runs when this macro is removed by DAE, set Off\n * \n * https://github.com/fantasycalendar/FoundryVTT-Sequencer/wiki/Sequencer-Effect-Manager#end-effects\n ***************************************************************************************************/\nasync function doOff() {\n    const FUNCNAME = \"doOff()\";\n    log(\"--------------Off---------------------\", \"Starting\", `${MACRONAME} ${FUNCNAME}`);\n    let flag = DAE.getFlag(aActor, 'enlageReduceSpell');\n    log(\"flag\", flag)\n    if (flag) {\n        await aActor.update({\n            \"data.bonuses.mwak.damage\": flag.ogMwak,\n            \"data.traits.size\": flag.ogSize\n        });\n\n        await jezUpdateTokenHeightWidth(aToken, flag.width);\n        aToken.refresh();  // Causes the token to be redrawn *NOW*\n\n        // await aToken.document.data.update({\"width\": flag.width,\"height\": flag.width});\n        await DAE.unsetFlag(aActor, 'enlageReduceSpell');\n        ChatMessage.create({ content: `<b>${aToken.name}</b> is returned to normal size` });\n    } else {\n        msg = `\"DAE.getFlag(aActor, 'enlageReduceSpell') did not find flag value.`\n        log(msg)\n    }\n    log(\"--------------Off---------------------\", \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n    return;\n}\n\n/***************************************************************************************************\n * Post the results to chat card\n ***************************************************************************************************/\n async function postResults(resultsString) {\n    const lastArg = args[args.length - 1];\n\n    let chatMessage = game.messages.get(lastArg.itemCardId);\n    let content = await duplicate(chatMessage.data.content);\n    log(`chatMessage: `,chatMessage);\n    const searchString = /<div class=\"midi-qol-other-roll\">[\\s\\S]*<div class=\"end-midi-qol-other-roll\">/g;\n    const replaceString = `<div class=\"midi-qol-other-roll\"><div class=\"end-midi-qol-other-roll\">${resultsString}`;\n    content = await content.replace(searchString, replaceString);\n    await chatMessage.update({ content: content });\n    await ui.chat.scrollBottom();\n    return;\n}\n\n/***************************************************************************************************\n * DEBUG Logging\n * \n * If passed an odd number of arguments, put the first on a line by itself in the log,\n * otherwise print them to the log seperated by a colon.  \n * \n * If more than two arguments, add numbered continuation lines. \n ***************************************************************************************************/\nfunction log(...parms) {\n    if (!DEBUG) return;             // If DEBUG is false or null, then simply return\n    let numParms = parms.length;    // Number of parameters received\n    let i = 0;                      // Loop counter\n    let lines = 1;                  // Line counter \n\n    if (numParms % 2) {  // Odd number of arguments\n        console.log(parms[i++])\n        for ( i; i<numParms; i=i+2) console.log(` ${lines++})`, parms[i],\":\",parms[i+1]);\n    } else {            // Even number of arguments\n        console.log(parms[i],\":\",parms[i+1]);\n        i = 2;\n        for ( i; i<numParms; i=i+2) console.log(` ${lines++})`, parms[i],\":\",parms[i+1]);\n    }\n}\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\n\n/***************************************************************************************************\n * Return true if passed argument is of object type \"Token5e\"\n ***************************************************************************************************/\nfunction jezIsToken5e(obj) {\n    if (obj?.constructor.name === \"Token5e\") return(true)\n    return(false)\n}\n\n/***************************************************************************************************\n * Return true if passed argument is of object type \"Token5e\"\n ***************************************************************************************************/\n function jezIsActor5e(obj) {\n    if (obj?.constructor.name === \"Actor5e\") return(true)\n    return(false)\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "cf": {
      "id": "temp_kw1jjhsz8u"
    },
    "core": {
      "sourceId": "Compendium.My-Shared-DDB.spells.Kvb74CDrE78n10mK"
    },
    "enhancedcombathud": {
      "set1p": false,
      "set2p": false,
      "set3p": false
    },
    "betterCurses": {
      "isCurse": false,
      "curseName": "",
      "formula": "",
      "mwak": false,
      "rwak": false,
      "msak": false,
      "rsak": false
    },
    "exportSource": {
      "world": "travels-in-barovia",
      "system": "dnd5e",
      "coreVersion": "0.8.9",
      "systemVersion": "1.5.3"
    }
  }
}