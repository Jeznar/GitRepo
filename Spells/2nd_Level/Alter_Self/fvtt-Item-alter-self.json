{
  "name": "Alter Self",
  "type": "spell",
  "img": "Icons_JGB/Spells/2nd_Level/Alter_Self.png",
  "data": {
    "description": {
      "value": "<p>You assume a different form. When you cast the spell, choose one of the following options, the effects of which last for the duration of the spell. While the spell lasts, <span style=\"text-decoration:underline\">you can end one option as an action to gain the benefits of a different one.</span></p>\n<h3><strong>Aquatic Adaptation</strong></h3>\n<p>You adapt your body to an aquatic environment, sprouting gills and growing webbing between your fingers. You can <strong>breathe underwater</strong> and gain a <strong>swimming speed</strong> equal to your walking speed.</p>\n<h3><strong>Change Appearance</strong></h3>\n<p>Â You transform your appearance. You decide what you look like, including your:</p>\n<ul>\n<li>height,</li>\n<li>weight,</li>\n<li>facial features,</li>\n<li>sound of your voice,</li>\n<li>hair length,</li>\n<li>coloration, and</li>\n<li>distinguishing characteristics, if any.</li>\n</ul>\n<p>You can make yourself appear as a member of <strong>another race,</strong> though none of your statistics change. You also <strong>can't appear as a creature of a different size </strong>than you, and your <strong>basic shape stays the same</strong>; if you're bipedal, you can't use this spell to become quadrupedal, for instance. At any time for the duration of the spell, you can use your action to change your appearance in this way again.</p>\n<h3><strong>Natural Weapons</strong></h3>\n<p>You grow claws, fangs, spines, horns, or a different natural weapon of your choice. Your unarmed strikes deal <strong>1d6 bludgeoning, piercing, or slashing damage,</strong> as appropriate to the natural weapon you chose, and you are proficient with your unarmed strikes. Finally, the <strong>natural weapon is magic</strong> and you have a <strong>+1 bonus</strong> to the <strong>attack</strong> and <strong>damage</strong> rolls you make using it.</p>",
      "chat": "<p>You assume a different form. When you cast the spell, choose one of the following options, the effects of which last for the duration of the spell. While the spell lasts, you can end one option as an action to gain the benefits of a different one.</p>\n<p><strong>Aquatic Adaptation.</strong> You adapt your body to an aquatic environment, sprouting gills and growing webbing between your fingers. You can breathe underwater and gain a swimming speed equal to your walking speed.</p>\n<p><strong>Change Appearance.</strong> You transform your appearance. You decide what you look like, including your height, weight, facial features, sound of your voice, hair length, coloration, and distinguishing characteristics, if any. You can make yourself appear as a member of another race, though none of your statistics change. You also can't appear as a creature of a different size than you, and your basic shape stays the same; if you're bipedal, you can't use this spell to become quadrupedal, for instance. At any time for the duration of the spell, you can use your action to change your appearance in this way again.</p>\n<p><strong>Natural Weapons.</strong> You grow claws, fangs, spines, horns, or a different natural weapon of your choice. Your unarmed strikes deal 1d6 bludgeoning, piercing, or slashing damage, as appropriate to the natural weapon you chose, and you are proficient with your unarmed strikes. Finally, the natural weapon is magic and you have a +1 bonus to the attack and damage rolls you make using it.</p>",
      "unidentified": ""
    },
    "source": "Basic Rules, Player's Handbook pg 211",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": 60,
      "units": "minute"
    },
    "target": {
      "value": null,
      "width": null,
      "units": "",
      "type": "self"
    },
    "range": {
      "value": null,
      "long": null,
      "units": "self"
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "",
      "target": "",
      "amount": null
    },
    "ability": "",
    "actionType": "other",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": null
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "level": 2,
    "school": "trs",
    "components": {
      "value": "",
      "vocal": true,
      "somatic": true,
      "material": false,
      "ritual": false,
      "concentration": true
    },
    "materials": {
      "value": "",
      "consumed": false,
      "cost": 0,
      "supply": 0
    },
    "preparation": {
      "mode": "always",
      "prepared": false
    },
    "scaling": {
      "mode": "none",
      "formula": ""
    },
    "attunement": null
  },
  "effects": [
    {
      "_id": "lphUfYcGqCRL8BYY",
      "changes": [
        {
          "key": "macro.itemMacro",
          "mode": 0,
          "value": "0",
          "priority": "20"
        }
      ],
      "disabled": false,
      "duration": {
        "startTime": null,
        "turns": 60,
        "seconds": 3600
      },
      "icon": "Icons_JGB/Spells/2nd_Level/Alter_Self.png",
      "label": "Alter Self",
      "transfer": false,
      "flags": {
        "dae": {
          "stackable": "none",
          "macroRepeat": "none",
          "specialDuration": [],
          "transfer": false,
          "selfTarget": false,
          "durationExpression": ""
        },
        "dnd5e-helpers": {
          "rest-effect": "Short Rest"
        },
        "ActiveAuras": {
          "isAura": false,
          "aura": "None",
          "radius": null,
          "alignment": "",
          "type": "",
          "ignoreSelf": false,
          "height": false,
          "hidden": false,
          "hostile": false,
          "onlyOnce": false,
          "displayTemp": false
        },
        "core": {
          "statusId": ""
        }
      },
      "tint": "",
      "selectedKey": "macro.itemMacro"
    }
  ],
  "flags": {
    "ddbimporter": {
      "id": 136028,
      "definitionId": 1992,
      "entityTypeId": 435869154,
      "dndbeyond": {
        "lookup": "generic",
        "lookupName": "generic",
        "level": null,
        "castAtLevel": null
      },
      "sources": [
        {
          "sourceId": 1,
          "pageNumber": null,
          "sourceType": 2
        },
        {
          "sourceId": 2,
          "pageNumber": 211,
          "sourceType": 1
        }
      ],
      "tags": [
        "Shapechanging"
      ]
    },
    "betterRolls5e": {
      "quickVersatile": {
        "altValue": true
      },
      "quickCharges": {
        "value": {
          "use": true,
          "resource": true
        },
        "altValue": {
          "use": true,
          "resource": true
        }
      }
    },
    "dae": {
      "activeEquipped": false,
      "alwaysActive": false
    },
    "midi-qol": {
      "onUseMacroName": "[postActiveEffects]ItemMacro,[postActiveEffects]Run_RuneVFX_onSelf",
      "effectActivation": false,
      "forceCEOn": false
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Alter Self",
          "type": "script",
          "author": "ZjFlOWYxZjM5ZTZj",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const MACRONAME = \"Alter_Self.0.5.js\"\n/*****************************************************************************************\n * Alter Self\n * \n * Present a dialog that allows caster to choose one of the three effects, one has three \n * sub choices, so 5 options on dialog.\n *  - Aquatic Adaptation: Active effect granting a swim speed equal to walking\n *  - Change Appearance: Active effect with notation about appearance change.\n *  - Natural Weapon: Create a temporary item giving a proficient 1d6+1 damage, magical, \n *    and +1 to hit, weapon of \n *    - bludgeoning, \n *    - piercing, or \n *    - slashing damage type.\n *  - Each turn at start of turn present another dialog that asks if actor wants to spend \n *    an action to repeat the choice.  If they repeat, present same dialog choice.  \n * \n * 01/14/22 0.1 Creation of Macro\n * 01/15/22 0.2 Another Day Another Version\n * 05/02/22 0.3 Update for Foundry 9.x\n * 05/16/22 0.4 Update (again) for Foundry 9.x\n * 08/01/22 0.5 Added convenientDescriptions\n *****************************************************************************************/\nconst DEBUG = true;\nconst MACRO = MACRONAME.split(\".\")[0]     // Trim of the version number and extension\njez.log(`============== Starting === ${MACRONAME} =================`);\nfor (let i = 0; i < args.length; i++) jez.log(`  args[${i}]`, args[i]);\nconst lastArg = args[args.length - 1];\nlet aActor;         // Acting actor, creature that invoked the macro\nlet aToken;         // Acting token, token for creature that invoked the macro\nlet aItem;          // Active Item information, item invoking this macro\nif (lastArg.tokenId) aActor = canvas.tokens.get(lastArg.tokenId).actor; else aActor = game.actors.get(lastArg.actorId);\nif (lastArg.tokenId) aToken = canvas.tokens.get(lastArg.tokenId); else aToken = game.actors.get(lastArg.tokenId);\nif (args[0]?.item) aItem = args[0]?.item; else aItem = lastArg.efData?.flags?.dae?.itemData;\njez.log(\"------- Global Values Set -------\",\n    `Active Token (aToken) ${aToken?.name}`, aToken,\n    `Active Actor (aActor) ${aActor?.name}`, aActor,\n    `Active Item (aItem) ${aItem?.name}`, aItem)\nlet msg = \"\";\nlet errorMsg = \"\";\nlet gameRound = game.combat ? game.combat.round : 0;\nconst FIRST_BUFF = aItem.name;\nconst AQUATIC_BUFF = \"Acquatic Adaptation\"\nconst AQUATIC_IMG = \"Icons_JGB/Spells/2nd_Level/Aquatic_Adaptation.png\"\nconst CHANGE_BUFF = \"Change Appearance\"\nconst CHANGE_IMG = \"Icons_JGB/Spells/1st_Level/Disguised.png\"\nconst WEAP_BUFF = \"Natural Weapons\"\nconst WEAP_IMG = \"Icons_JGB/Monster_Features/claws.png\"\nconst WEAP_NAME = \"Natural Weapon (Alter Self)\"\nconst MACRO_HELPER = \"Alter_Self_Helper\"\nconst UPDATE_EFFECT_NAME = \"Update Alter Self Effect\"\nlet chatCard = null;\n//----------------------------------------------------------------------------------\n// Run the main procedures, choosing based on how the macro was invoked\n//\nif (args[0] === \"off\") await doOff();                   // DAE removal\nif (args[0] === \"on\") await doOn();                     // DAE Application\nif (args[0]?.tag === \"OnUse\") await doOnUse();          // Midi ItemMacro On Use\njez.log(`============== Finishing === ${MACRONAME} =================`);\n/***************************************************************************************************\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ***************************************************************************************************\n * Perform the code that runs when this macro is removed by DAE, set Off\n * \n * https://github.com/fantasycalendar/FoundryVTT-Sequencer/wiki/Sequencer-Effect-Manager#end-effects\n ***************************************************************************************************/\n async function doOff() {\n    const FUNCNAME = \"doOff()\";\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    let oldEffect = null;\n    jez.log(`Removing: >${AQUATIC_BUFF}< if present`)\n    oldEffect = aActor.effects.find(ef => ef.data.label === AQUATIC_BUFF) ?? null; // Added a null case.\n    await oldEffect?.delete();\n    jez.log(`Removing: >${CHANGE_BUFF}< if present`)\n    oldEffect = aActor.effects.find(ef => ef.data.label === CHANGE_BUFF) ?? null; // Added a null case.\n    await oldEffect?.delete();\n    jez.log(`Removing: >${WEAP_BUFF}< if present`)\n    oldEffect = aActor.effects.find(ef => ef.data.label === WEAP_BUFF) ?? null; // Added a null case.\n    await oldEffect?.delete();\n    jez.log(`Deleting: >${WEAP_NAME}< if present`)\n    //await jezDeleteItem(WEAP_NAME);\n    await jez.deleteItems(WEAP_NAME, \"weapon\", aActor);\n    jez.log(`Deleting: >${UPDATE_EFFECT_NAME}< if present`)\n    //await jezDeleteItem(UPDATE_EFFECT_NAME);   \n    await jez.deleteItems(UPDATE_EFFECT_NAME, \"spell\", aActor);\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    return;\n  }\n/***************************************************************************************************\n * Perform the code that runs when this macro is removed by DAE, set On\n ***************************************************************************************************/\nasync function doOn() {\n    const FUNCNAME = \"doOn()\";\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    jez.log(`Deleting: >${WEAP_NAME}< if present`)\n    await jez.deleteItems(WEAP_NAME, \"weapon\", aActor);\n    jez.log(`Deleting: >${UPDATE_EFFECT_NAME}< if present`)\n    await jez.deleteItems(UPDATE_EFFECT_NAME, \"spell\", aActor);\n    //----------------------------------------------------------------------------------------------\n    // Build the dialog variables\n    //\n    const alterOptions = [\n        \"Aquatic Adaptation: Grants swim speed and water breathing.\",\n        \"Change Appearance: Visual (only) changes to appearance.\",\n        \"Slashing Natural Weapon, with +1 magical bonus.\",\n        \"Piercing Natural Weapon, with +1 magical bonus.\",\n        \"Bludgeoning Natural Weapon, with +1 magical bonus.\"\n    ]\n    const queryTitle = \"Select Item in Question\"\n    const queryText = \"Pick one from drop down list\"\n    //----------------------------------------------------------------------------------------------\n    // Pop the dialog and connect to callback\n    //\n    pickFromListArray(queryTitle, queryText, pickItemCallBack, alterOptions);\n    //----------------------------------------------------------------------------------------------\n    // Modify recently created effect to have a convenientDescription\n    //\n    let effect = await aToken.actor.effects.find(i => i.data.label === FIRST_BUFF);\n    if (!effect) return jez.badNews(`Could not find ${FIRST_BUFF} effect on ${aToken.name}`,\"e\")\n    const C_DESC = `With an Action may alter certain elements of body or appearance`\n    await effect.update({ flags: { convenientDescription: C_DESC } });\n    //\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    return;\n}\n/***************************************************************************************************\n * Perform the code that runs when this macro is invoked as an ItemMacro \"OnUse\"\n ***************************************************************************************************/\n async function doOnUse() {\n    const FUNCNAME = \"doOnUse()\";\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n\n    createEffectUpdate()\n    // https://www.w3schools.com/tags/ref_colornames.asp\n    msg = `<p style=\"color:blue;font-size:14px;\">\n    ${aToken.name} is using magic to change appearance and some features.<br><br>\n    ${aToken.name} will be able to change this effect each turn at the cost of an action.`\n    postResults(msg);\n    \n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    return (true);\n}\n\n/***************************************************************************************************\n * Callback function to handle menu choice.\n ***************************************************************************************************/\nasync function pickItemCallBack(selection) {\n    jez.log(\"pickItemCallBack\", selection)\n    if (!selection) return;\n    let choice = selection.split(\" \")[0];     // Trim off the version number and extension\n    jez.log(`Selection: ${choice}!`)\n    let concEffect = aActor.effects.find(ef => ef.data.label === \"Concentrating\");\n    let remainingSecs = concEffect ? concEffect?.data.duration.seconds : 3600\n    jez.log(`Proceed with ${choice} for ${remainingSecs} seconds`, concEffect)\n    let effectData = null;\n    let cardImg = null;\n\n    let ceDesc\n    switch (choice) {\n        case \"Aquatic\":\n            jez.log(`acquire gills and fins`)\n            ceDesc = `Now has gills and fins, can breathe underwater and gains swimming speed equal to walking.`\n            let swimSpeed = aActor.data.data.attributes.movement?.walk || 1;\n            effectData = {\n                label: AQUATIC_BUFF, \n                icon: AQUATIC_IMG,\n                origin: lastArg.uuid,\n                disabled: false,\n                duration: { seconds: remainingSecs, startTime: game.time.worldTime },\n                flags: { convenientDescription: ceDesc },\n                changes: [\n                    {key: `data.attributes.movement.swim`, mode: jez.UPGRADE, value: swimSpeed, priority: 20},\n                    {key: `flags.gm-notes.notes`, mode: jez.CUSTOM, value: \"Water Breathing\", priority: 20},\n                ]\n            };\n            jez.log(`Add effect ${aItem.name} to ${aToken.name}`)  \n            await MidiQOL.socket().executeAsGM(\"createEffects\",{actorUuid:aToken.actor.uuid, effects: [effectData] });\n            msg=`${aToken.name} has alterered shape to adapt to an aquatic environment.  ${aToken.name} now has water \n            breathing and a swim speed equal to walking speed.`;\n            cardImg = AQUATIC_IMG;\n            break;\n        case \"Change\":\n            jez.log(`Change visual appearance`)\n            ceDesc = `Altered visual appearance`\n            effectData = {\n                label: CHANGE_BUFF, \n                icon: CHANGE_IMG,\n                origin: lastArg.uuid,\n                disabled: false,\n                duration: { seconds: remainingSecs, startTime: game.time.worldTime },\n                flags: { convenientDescription: ceDesc },\n                changes: [\n                    {key: `flags.gm-notes.notes`, mode: jez.CUSTOM, value: \"Physical Appearance Changed\", priority: 20},\n                ]\n            };\n            jez.log(`Add effect ${aItem.name} to ${aToken.name}`)  \n            await MidiQOL.socket().executeAsGM(\"createEffects\",{actorUuid:aToken.actor.uuid, effects: [effectData] });\n            msg=`${aToken.name} has altered various aspects of physical appearance.`;\n            cardImg = CHANGE_IMG;\n            break;\n        case \"Slashing\":\n        case \"Piercing\":\n        case \"Bludgeoning\":\n            jez.log(`Natural Weapon with damage type: ${choice.toLowerCase()}`)\n            ceDesc = `Has sprouted natural weapons`\n            effectData = {\n                label: WEAP_BUFF, \n                icon: WEAP_IMG,\n                origin: lastArg.uuid,\n                disabled: false,\n                duration: { seconds: remainingSecs, startTime: game.time.worldTime },\n                flags: { convenientDescription: ceDesc },\n                changes: [\n                    {key: `flags.gm-notes.notes`, mode: jez.CUSTOM, value: `Natural ${choice} Weapon Added`, priority: 20},\n                    {key: `data.traits.weaponProf.custom`, mode: jez.CUSTOM, value: `${WEAP_NAME}`, priority: 20},                  \n                ]\n            };\n            jez.log(`Add effect ${aItem.name} to ${aToken.name}`)  \n            await MidiQOL.socket().executeAsGM(\"createEffects\",{actorUuid:aToken.actor.uuid, effects: [effectData] });\n            createWeapon(choice)\n            msg=`${aToken.name} has created a ${choice} natural weapon.<br><br>\n            <b>FoundryVTT:</b> A new temporary item has been created in Inventory:Weapons, on ${aToken.name}'s sheet, \n            that can be used for attacks.`;\n            cardImg = WEAP_IMG;\n            break;\n        default:\n            errorMsg = `Disturbingly, reached end of switch without a match for ==>${choice}<==`\n            ui.notifications.error(msg);\n            jez.log(errorMsg)\n            return (choice)\n    }\n    msg += \"<br><br>This effect may be altered each turn at the cost of an action.\"\n    jezPostMessage({color:\"purple\", fSize:14, msg:msg, title:\"Alter Self Effect\", icon:cardImg })\n    return(choice)\n}\n\n/****************************************************************************************\n * Create and instant and rather temprary item in inventory to represent the natural weap\n ****************************************************************************************/\nasync function createWeapon(damType) {\n    const FUNCNAME = `createWeapon(${damType})`;\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n\n    let strMod = aActor.data.data.abilities.str.mod\n    let dexMod = aActor.data.data.abilities.dex.mod\n    let bestMod = \"str\"\n    if (dexMod > strMod) bestMod = \"dex\"\n    jez.log(\"Pick skill type\", \"strMod\", strMod, \"dexMod\", dexMod, \"bestMod ==>\", bestMod)\n\n    let descValue = `Use claws, fangs, spines, horns, or a different natural weapon \n    of your choice.<br><br>\n    Your unarmed strike with this weapon deals <b>1d6+1 ${damType}</b> damage, you are \n    proficient with this weapon. Finally, the natural weapon is <b>magic</b> and you \n    have a <b>+1 bonus</b> to attack rolls you make using it.`\n    let itemData = [{\n        \"name\": WEAP_NAME,\n        \"type\": \"weapon\",\n        \"data\": {\n            \"ability\": `${bestMod}`,\n            \"actionType\": \"mwak\",\n            \"activation\": {\n                \"cost\": 1,\n                \"type\": \"action\"\n            },\n            \"attackBonus\": 1,\n            \"damage\": {\n                \"parts\": [[`1d6 +1 +@mod`, `${damType.toLowerCase()}`]],  // Set base damage\n\n            },\n            \"description\": {\"value\": descValue },\n            \"equipped\": true,\n            \"prof\": { \"hasProficiency\": true },\n            \"proficient\": true,\n            \"properties\": {\n                \"mgc\": \"true\",  // Mark the new item as magic\n            },\n            \"source\": `Alter Self: ${damType} Weapon`,\n            \"weaponType\": \"natural\"\n\n        },\n        \"img\": WEAP_IMG,\n        \"effects\": []\n    }];\n    await aActor.createEmbeddedDocuments(\"Item\", itemData);\n\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    return;\n}\n/****************************************************************************************\n * Create and instant and rather temprary item in inventory to represent the natural weap\n ****************************************************************************************/\n async function createEffectUpdate() {\n    const FUNCNAME = `createEffectUpdate()`;\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    let descValue = `<b>${aToken.name}</b> may spend an action to update the effect(s) of \n    their current <b>Alter Self</b> spell.`\n    jez.log(\"descValue\", descValue)\n    let itemData = [{\n        \"data\": {\n            \"ability\": \"\",\n            \"actionType\": \"util\",\n            \"activation\": {\n                \"condition\": \"Must have pre-existing Alter Self effect.\",\n                \"type\" : \"action\",\n                \"cost\" : 1,\n            },\n            \"description\": { \"value\": descValue },\n            \"formula\": \"\",\n            \"level\": 0,\n            \"preparation\": {\n                \"mode\": \"innate\",\n                \"prepared\": false\n            },\n            \"school\": \"trs\",\n            \"source\": \"Alter Self Spell\",\n        },\n        \"effects\": [],\n        \"flags\": {\n            \"midi-qol\": {\n                \"onUseMacroName\": \"Alter_Self_Helper\"\n            }\n        },\n        \"img\": args[0].item.img,\n        \"name\": UPDATE_EFFECT_NAME,\n        \"type\": \"spell\",\n    }];\n    jez.log(\"itemData\",itemData)\n    await aActor.createEmbeddedDocuments(\"Item\", itemData);\n\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    return;\n }\n/****************************************************************************************\n * Create and process selection dialog, passing it onto specified callback function\n ***************************************************************************************/\n function pickFromListArray(queryTitle, queryText, pickCallBack, queryOptions) {\n    const FUNCNAME = \"pickFromList(queryTitle, queryText, ...queryOptions)\";\n    jez.log(\"---------------------------------------------------------------------------\",\n        `Starting`, `${MACRONAME} ${FUNCNAME}`,\n        `queryTitle`, queryTitle,\n        `queryText`, queryText,\n        `pickCallBack`, pickCallBack,\n        `queryOptions`, queryOptions);\n\n    if (typeof(pickCallBack)!=\"function\" ) {\n        let msg = `pickFromList given invalid pickCallBack, it is a ${typeof(pickCallBack)}`\n        ui.notifications.error(msg);\n        jez.log(msg);\n        return\n    }   \n\n    if (!queryTitle || !queryText || !queryOptions) {\n        let msg = `pickFromList arguments should be (queryTitle, queryText, pickCallBack, [queryOptions]),\n                   but yours are: ${queryTitle}, ${queryText}, ${pickCallBack}, ${queryOptions}`;\n        ui.notifications.error(msg);\n        jez.log(msg);\n        return\n    }\n\n    let template = `\n    <div>\n    <div class=\"form-group\">\n        <label>${queryText}</label>\n        <select id=\"selectedOption\">`\n    for (let option of queryOptions) {\n        template += `<option value=\"${option}\">${option}</option>`\n    }\n    template += `</select>\n    </div></div>`\n\n    new Dialog({\n        title: queryTitle,\n        content: template,\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: 'OK',\n                callback: async (html) => {\n                    const selectedOption = html.find('#selectedOption')[0].value\n                    jez.log('selected option', selectedOption)\n                    pickCallBack(selectedOption)\n                },\n            },\n            cancel: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: 'Cancel',\n                callback: async (html) => {\n                    jez.log('canceled')\n                    pickCallBack(null)\n                },\n            },\n        },\n        default: 'cancel',\n    }).render(true)\n\n    jez.log(\"---------------------------------------------------------------------------\",\n        `Finished`, `${MACRONAME} ${FUNCNAME}`);\n        return;\n}\n/***************************************************************************************\n * Function to delete an item from actor\n *\n * Parameters\n *  - itemName: A string naming the item to be found in actor's inventory\n *  - actor: Optional actor to be searched, defaults to actor launching this macro\n ***************************************************************************************/\n/*async function jezDeleteItem(itemName, actor) {\n    const FUNCNAME = \"deleteItem(itemName, actor)\";\n    let defActor = null;\n    if (lastArg.tokenId) defActor = canvas.tokens.get(lastArg.tokenId).actor; \n    else defActor = game.actors.get(lastArg.actorId);\n    actor = actor ? actor : defActor; // Set actor if not supplied\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`,\n        \"itemName\", itemName, `actor ${actor?.name}`, actor);\n\n    if (!jezIsActor5e(actor)) {\n        errorMsg = `Obtained actor argument is not of type Actor5E (${actor?.constructor.name})`\n        jez.log(errorMsg)\n        jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} ==> FALSE --------------`);\n        return (false);\n    }\n    let item = actor.items.find(item => item.data.name === itemName && \n        (item.type === \"weapon\" || item.type === \"spell\"))\n    if (item == null || item == undefined) {\n        errorMsg = `${actor.name} does not have ${itemName}`\n        jez.log(errorMsg);\n        jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} ==> FALSE --------------`);\n        return (false);\n    }\n    await aActor.deleteOwnedItem(item._id);\n    jez.log(`${actor.name} had (past tense) ${item.name}`, item);\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} ==> TRUE -----------------`);\n    return (true);\n}*/\n/***************************************************************************************************\n * Return true if passed argument is of object type \"Token5e\"\n ***************************************************************************************************/\n function jezIsActor5e(obj) {\n    if (obj?.constructor.name === \"Actor5e\") return(true)\n    return(false)\n}\n/***************************************************************************************************\n * Obtain the Actor5e objext corresponding to the passed ID\n ***************************************************************************************************/\nfunction jezGetActor5EfromID(passedID) {\n    let myActor = game.actors.get(passedID)\n    jez.log(`Obtained actor ${myActor.name}`, myActor)\n    return(myActor)\n}\n/***************************************************************************************************\n * Post the results to chat card\n ***************************************************************************************************/\n async function postResults(resultsString) {\n    const lastArg = args[args.length - 1];\n\n    let chatMessage = game.messages.get(lastArg.itemCardId);\n    let content = await duplicate(chatMessage.data.content);\n    jez.log(`chatMessage: `,chatMessage);\n    //const searchString = /<div class=\"midi-qol-other-roll\">[\\s\\S]*<div class=\"end-midi-qol-other-roll\">/g;\n    //const replaceString = `<div class=\"midi-qol-other-roll\"><div class=\"end-midi-qol-other-roll\">${resultsString}`;\n    const searchString = /<div class=\"end-midi-qol-saves-display\">/g;\n    const replaceString = `<div class=\"end-midi-qol-saves-display\">${resultsString}`;\n    content = await content.replace(searchString, replaceString);\n    await chatMessage.update({ content: content });\n    await ui.chat.scrollBottom();\n    return;\n}\n/***************************************************************************************************\n * Post a new chat message -- msgParm should be a string for a simple message or an object with \n * some or all of these fields set below for the chat object.  \n * \n * Example Calls:\n *  jezPostMessage(\"Hi there!\")\n *  jezPostMessage({color:\"purple\", fSize:18, msg:\"Bazinga\", title:\"Sheldon says...\" })\n * \n ***************************************************************************************************/\nasync function jezPostMessage(msgParm) {\n    const FUNCNAME = \"postChatMessage(msgParm)\";\n    jez.log(`--------------${FUNCNAME}-----------`, \"Starting\", `${MACRONAME} ${FUNCNAME}`,\n        \"msgParm\", msgParm);\n    let typeOfParm = typeof (msgParm)\n    switch (typeOfParm) {\n        case \"string\":\n            await ChatMessage.create({ content: msgParm });\n            break;\n        case \"object\":\n            let chat = {} \n            chat.title = msgParm?.title || \"Generic Chat Message\"\n            chat.fSize = msgParm?.fSize || 12\n            chat.color = msgParm?.color || \"black\"   \n            chat.icon  = msgParm?.icon  || \"icons/vtt-512.png\"   \n            chat.msg   = msgParm?.msg   || \"Maybe say something useful...\"  \n            chatCard = `\n            <div class=\"dnd5e chat-card item-card midi-qol-item-card\">\n                <header class=\"card-header flexrow\">\n                    <img src=\"${chat.icon}\" title=\"${chat.title}\" width=\"36\" height=\"36\">\n                    <h3 class=\"item-name\">${chat.title}</h3>\n                </header>\n                <div class=\"card-buttons\">\n                    <p style=\"color:${chat.color};font-size:${chat.fSize}px\">\n                        ${chat.msg}</p>\n                </div>\n            </div>`\n            await ChatMessage.create({ content: chatCard });\n            break;\n        default:\n            errorMsg`Icky Poo Poo!  Parameter passed was neither a string nor object (${typeOfParm})`\n            jez.log(errorMsg, msgParm)\n            ui.notifications.error(errorMsg)\n    }\n    await jez.wait(100);\n    await ui.chat.scrollBottom();\n    jez.log(`--------------${FUNCNAME}-----------`, \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n    return;\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "cf": {
      "id": "temp_kw1jjhsz8u"
    },
    "core": {
      "sourceId": "Compendium.My-Shared-DDB.spells.Pr5yxZRZBb2I4qbk"
    },
    "enhancedcombathud": {
      "set1p": false,
      "set2p": false,
      "set3p": false
    },
    "betterCurses": {
      "isCurse": false,
      "curseName": "",
      "formula": "",
      "mwak": false,
      "rwak": false,
      "msak": false,
      "rsak": false
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "exportSource": {
      "world": "travels-in-barovia-ce",
      "system": "dnd5e",
      "coreVersion": "9.269",
      "systemVersion": "1.6.2"
    }
  }
}