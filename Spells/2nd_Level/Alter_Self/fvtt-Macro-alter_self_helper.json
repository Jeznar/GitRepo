{
  "name": "Alter_Self_Helper",
  "type": "script",
  "author": "ZjFlOWYxZjM5ZTZj",
  "img": "Icons_JGB/Spells/2nd_Level/Alter_Self.png",
  "scope": "global",
  "command": "const MACRONAME = \"Alter_Self_Helper.0.3\"\n/*****************************************************************************************\n * Alter Self Helper\n * \n * Presents the user with an option to update the effects of a prexisting ALter Self spell\n * \n * 01/15/22 0.1 Creation of Macro\n * 05/02/22 0.3 JGB Update for Foundry 9.x\n *****************************************************************************************/\nconst MACRO = MACRONAME.split(\".\")[0]     // Trim of the version number and extension\njez.log(`============== Starting === ${MACRONAME} =================`);\nfor (let i = 0; i < args.length; i++) jez.log(`  args[${i}]`, args[i]);\nconst lastArg = args[args.length - 1];\nlet aActor;         // Acting actor, creature that invoked the macro\nlet aToken;         // Acting token, token for creature that invoked the macro\nlet aItem;          // Active Item information, item invoking this macro\nif (lastArg.tokenId) aActor = canvas.tokens.get(lastArg.tokenId).actor; else aActor = game.actors.get(lastArg.actorId);\nif (lastArg.tokenId) aToken = canvas.tokens.get(lastArg.tokenId); else aToken = game.actors.get(lastArg.tokenId);\nif (args[0]?.item) aItem = args[0]?.item; else aItem = lastArg.efData?.flags?.dae?.itemData;\nconst CUSTOM = 0, MULTIPLY = 1, ADD = 2, DOWNGRADE = 3, UPGRADE = 4, OVERRIDE = 5;\njez.log(\"------- Global Values Set -------\",\n    `Active Token (aToken) ${aToken?.name}`, aToken,\n    `Active Actor (aActor) ${aActor?.name}`, aActor,\n    `Active Item (aItem) ${aItem?.name}`, aItem)\nlet msg = \"\";\nlet errorMsg = \"\";\nlet gameRound = game.combat ? game.combat.round : 0;\nconst FIRST_BUFF = aItem.name;\nconst AQUATIC_BUFF = \"Acquatic Adaptation\"\nconst AQUATIC_IMG = \"Icons_JGB/Spells/2nd_Level/Aquatic_Adaptation.png\"\nconst CHANGE_BUFF = \"Change Appearance\"\nconst CHANGE_IMG = \"Icons_JGB/Spells/1st Level/Disguised.png\"\nconst WEAP_BUFF = \"Natural Weapons\"\nconst WEAP_IMG = \"Icons_JGB/Monster_Features/claws.png\"\nconst WEAP_NAME = \"Natural Weapon (Alter Self)\"\nlet chatCard = null;\n//----------------------------------------------------------------------------------\n// Run the main procedures, choosing based on how the macro was invoked\n//\n//if (args[0] === \"off\") await doOff();                   // DAE removal\n//if (args[0] === \"on\") await doOn();                     // DAE Application\nif (args[0]?.tag === \"OnUse\") await doOnUse();          // Midi ItemMacro On Use\njez.log(`============== Finishing === ${MACRONAME} =================`);\n/***************************************************************************************************\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n ***************************************************************************************************\n * Perform the code that runs when this macro is removed by DAE, set On\n ***************************************************************************************************/\nasync function doOn() {\n    const FUNCNAME = \"doOn()\";\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    jez.log(\"A place for things to be done\");\n\n    const alterOptions = [\n        \"Aquatic Adaptation: Grants swim speed and water breathing.\",\n        \"Change Appearance: Visual (only) changes to appearance.\",\n        \"Slashing Natural Weapon, with +1 magical bonus.\",\n        \"Piercing Natural Weapon, with +1 magical bonus.\",\n        \"Bludgeoning Natural Weapon, with +1 magical bonus.\"\n    ]\n    const queryTitle = \"Select Item in Question\"\n    const queryText = \"Pick one from drop down list\"\n    pickFromListArray(queryTitle, queryText, pickItemCallBack, alterOptions);\n\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    return;\n}\n\n/***************************************************************************************************\n * Perform the code that runs when this macro is invoked as an ItemMacro \"OnUse\"\n ***************************************************************************************************/\n async function doOnUse() {\n    const FUNCNAME = \"doOnUse()\";\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n\n    //---------------------------------------------------------------------------------------------\n    // Remove prexisting effects of Alterself sell\n    //\n    let oldEffect = null;\n    jez.log(`Removing: ${AQUATIC_BUFF} if present`)\n    oldEffect = aActor.effects.find(ef => ef.data.label === AQUATIC_BUFF) ?? null; // Added a null case.\n    await oldEffect?.delete();\n    jez.log(`Removing: ${CHANGE_BUFF} if present`)\n    oldEffect = aActor.effects.find(ef => ef.data.label === CHANGE_BUFF) ?? null; // Added a null case.\n    await oldEffect?.delete();\n    jez.log(`Removing: ${WEAP_BUFF} if present`)\n    oldEffect = aActor.effects.find(ef => ef.data.label === WEAP_BUFF) ?? null; // Added a null case.\n    await oldEffect?.delete();\n    jez.log(`Deleting: ${WEAP_NAME} if present`)\n    // await jezDeleteItem(WEAP_NAME);\n    await jez.deleteItems(WEAP_NAME, \"weapon\", aActor);\n    //---------------------------------------------------------------------------------------------\n    // query the user for choice via a dialog, proceed from there to a callback.\n    //\n    const alterOptions = [\n        \"Aquatic Adaptation: Grants swim speed and water breathing.\",\n        \"Change Appearance: Visual (only) changes to appearance.\",\n        \"Slashing Natural Weapon, with +1 magical bonus.\",\n        \"Piercing Natural Weapon, with +1 magical bonus.\",\n        \"Bludgeoning Natural Weapon, with +1 magical bonus.\"\n    ]\n    const queryTitle = \"Select Item in Question\"\n    const queryText = \"Pick one from drop down list\"\n    pickFromListArray(queryTitle, queryText, pickItemCallBack, alterOptions);\n\n    // https://www.w3schools.com/tags/ref_colornames.asp\n    msg = `<p style=\"color:blue;font-size:14px;\">\n    ${aToken.name} is changing aspects of the magic that has altered him/her.<br><br>\n    ${aToken.name} will be able to change this effect each turn at the cost of an action.`\n    postResults(msg);\n    \n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    return (true);\n}\n\n/***************************************************************************************************\n * Callback function to handle menu choice.\n ***************************************************************************************************/\nasync function pickItemCallBack(selection) {\n    jez.log(\"pickItemCallBack\", selection)\n    if (!selection) return;\n    let choice = selection.split(\" \")[0];     // Trim off the version number and extension\n    jez.log(`Selection: ${choice}!`)\n    let baseEffect = aActor.effects.find(ef => ef.data.label === FIRST_BUFF) ?? null; // Added a null case.\n    let remaingTurns = baseEffect ? baseEffect?.data.duration.turns : 62\n    jez.log(`Proceed with ${choice} for ${remaingTurns} turns`, baseEffect)\n    let effectData = null;\n    let cardImg = null;\n\n    switch (choice) {\n        case \"Aquatic\":\n            jez.log(`acquire gills and fins`)\n            let swimSpeed = aActor.data.data.attributes.movement?.walk || 1;\n            effectData = {\n                label: AQUATIC_BUFF, \n                icon: AQUATIC_IMG,\n                origin: lastArg.uuid,\n                disabled: false,\n                duration: { turns: remaingTurns, startRound: gameRound, startTime: game.time.worldTime },\n                changes: [\n                    {key: `data.attributes.movement.swim`, mode: UPGRADE, value: swimSpeed, priority: 20},\n                    {key: `flags.gm-notes.notes`, mode: CUSTOM, value: \"Water Breathing\", priority: 20},\n                ]\n            };\n            jez.log(`Add effect ${aItem.name} to ${aToken.name}`)  \n            await MidiQOL.socket().executeAsGM(\"createEffects\",{actorUuid:aToken.actor.uuid, effects: [effectData] });\n            msg=`${aToken.name} has alterered shape to adapt to an aquatic environment.  ${aToken.name} now has water \n            breathing and a swim speed equal to walking speed.`;\n            cardImg = AQUATIC_IMG;\n            break;\n        case \"Change\":\n            jez.log(`Change visual appearance`)\n            effectData = {\n                label: CHANGE_BUFF, \n                icon: CHANGE_IMG,\n                origin: lastArg.uuid,\n                disabled: false,\n                duration: { turns: remaingTurns, startRound: gameRound, startTime: game.time.worldTime },\n                changes: [\n                    {key: `flags.gm-notes.notes`, mode: CUSTOM, value: \"Physical Appearance Changed\", priority: 20},\n                ]\n            };\n            jez.log(`Add effect ${aItem.name} to ${aToken.name}`)  \n            await MidiQOL.socket().executeAsGM(\"createEffects\",{actorUuid:aToken.actor.uuid, effects: [effectData] });\n            msg=`${aToken.name} has altered various aspects of physical appearance.`;\n            cardImg = CHANGE_IMG;\n            break;\n        case \"Slashing\":\n        case \"Piercing\":\n        case \"Bludgeoning\":\n            jez.log(`Natural Weapon with damage type: ${choice.toLowerCase()}`)\n            effectData = {\n                label: WEAP_BUFF, \n                icon: WEAP_IMG,\n                origin: lastArg.uuid,\n                disabled: false,\n                duration: { turns: remaingTurns, startRound: gameRound, startTime: game.time.worldTime },\n                changes: [\n                    {key: `flags.gm-notes.notes`, mode: CUSTOM, value: `Natural ${choice} Weapon Added`, priority: 20},\n                    {key: `data.traits.weaponProf.custom`, mode: CUSTOM, value: `${WEAP_NAME}`, priority: 20},                  \n                ]\n            };\n            jez.log(`Add effect ${aItem.name} to ${aToken.name}`)  \n            await MidiQOL.socket().executeAsGM(\"createEffects\",{actorUuid:aToken.actor.uuid, effects: [effectData] });\n            createWeapon(choice)\n            msg=`${aToken.name} has created a ${choice} natural weapon.<br><br>\n            <b>FoundryVTT:</b> A new temporary item has been created in Inventory:Weapons, on ${aToken.name}'s sheet, \n            that can be used for attacks.`;\n            cardImg = WEAP_IMG;\n            break;\n        default:\n            errorMsg = `Disturbingly, reached end of switch without a match for ==>${choice}<==`\n            ui.notifications.error(msg);\n            jez.log(errorMsg)\n            return (choice)\n    }\n    msg += \"<br><br>This effect may be altered each turn at the cost of an action.\"\n    jezPostMessage({color:\"purple\", fSize:14, msg:msg, title:\"Alter Self Effect\", icon:cardImg })\n    return(choice)\n}\n\n/****************************************************************************************\n * Create and instant and rather temprary item in inventory to represent the natural weap\n ****************************************************************************************/\nasync function createWeapon(damType) {\n    const FUNCNAME = `createWeapon(${damType})`;\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`);\n\n    let strMod = aActor.data.data.abilities.str.mod\n    let dexMod = aActor.data.data.abilities.dex.mod\n    let bestMod = \"str\"\n    if (dexMod > strMod) bestMod = \"dex\"\n    jez.log(\"Pick skill type\", \"strMod\", strMod, \"dexMod\", dexMod, \"bestMod ==>\", bestMod)\n\n    let descValue = `Use claws, fangs, spines, horns, or a different natural weapon \n    of your choice.<br><br>\n    Your unarmed strike with this weapon deals <b>1d6+1 ${damType}</b> damage, you are \n    proficient with this weapon. Finally, the natural weapon is <b>magic</b> and you \n    have a <b>+1 bonus</b> to attack rolls you make using it.`\n    let itemData = [{\n        \"name\": WEAP_NAME,\n        \"type\": \"weapon\",\n        \"data\": {\n            \"ability\": `${bestMod}`,\n            \"actionType\": \"mwak\",\n            \"activation\": {\n                \"cost\": 1,\n                \"type\": \"action\"\n            },\n            \"attackBonus\": 1,\n            \"damage\": {\n                \"parts\": [[`1d6 +1 +@mod`, `${damType.toLowerCase()}`]],  // Set base damage\n\n            },\n            \"description\": {\"value\": descValue },\n            \"equipped\": true,\n            \"prof\": { \"hasProficiency\": true },\n            \"proficient\": true,\n            \"properties\": {\n                \"mgc\": \"true\",  // Mark the new item as magic\n            },\n            \"source\": `Alter Self: ${damType} Weapon`,\n            \"weaponType\": \"natural\"\n\n        },\n        \"img\": WEAP_IMG,\n        \"effects\": []\n    }];\n    await aActor.createEmbeddedDocuments(\"Item\", itemData);\n\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} -----------------`);\n    return;\n}\n/****************************************************************************************\n * Create and process selection dialog, passing it onto specified callback function\n ***************************************************************************************/\n function pickFromListArray(queryTitle, queryText, pickCallBack, queryOptions) {\n    const FUNCNAME = \"pickFromList(queryTitle, queryText, ...queryOptions)\";\n    jez.log(\"---------------------------------------------------------------------------\",\n        `Starting`, `${MACRONAME} ${FUNCNAME}`,\n        `queryTitle`, queryTitle,\n        `queryText`, queryText,\n        `pickCallBack`, pickCallBack,\n        `queryOptions`, queryOptions);\n\n    if (typeof(pickCallBack)!=\"function\" ) {\n        let msg = `pickFromList given invalid pickCallBack, it is a ${typeof(pickCallBack)}`\n        ui.notifications.error(msg);\n        jez.log(msg);\n        return\n    }   \n\n    if (!queryTitle || !queryText || !queryOptions) {\n        let msg = `pickFromList arguments should be (queryTitle, queryText, pickCallBack, [queryOptions]),\n                   but yours are: ${queryTitle}, ${queryText}, ${pickCallBack}, ${queryOptions}`;\n        ui.notifications.error(msg);\n        jez.log(msg);\n        return\n    }\n\n    let template = `\n    <div>\n    <div class=\"form-group\">\n        <label>${queryText}</label>\n        <select id=\"selectedOption\">`\n    for (let option of queryOptions) {\n        template += `<option value=\"${option}\">${option}</option>`\n    }\n    template += `</select>\n    </div></div>`\n\n    new Dialog({\n        title: queryTitle,\n        content: template,\n        buttons: {\n            ok: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: 'OK',\n                callback: async (html) => {\n                    const selectedOption = html.find('#selectedOption')[0].value\n                    jez.log('selected option', selectedOption)\n                    pickCallBack(selectedOption)\n                },\n            },\n            cancel: {\n                icon: '<i class=\"fas fa-times\"></i>',\n                label: 'Cancel',\n                callback: async (html) => {\n                    jez.log('canceled')\n                    pickCallBack(null)\n                },\n            },\n        },\n        default: 'cancel',\n    }).render(true)\n\n    jez.log(\"---------------------------------------------------------------------------\",\n        `Finished`, `${MACRONAME} ${FUNCNAME}`);\n        return;\n}\n/***************************************************************************************\n * Function to delete an item from actor\n *\n * Parameters\n *  - itemName: A string naming the item to be found in actor's inventory\n *  - actor: Optional actor to be searched, defaults to actor launching this macro\n ***************************************************************************************/\n/*async function jezDeleteItem(itemName, actor) {\n    const FUNCNAME = \"deleteItem(itemName, actor)\";\n    let defActor = null;\n    if (lastArg.tokenId) defActor = canvas.tokens.get(lastArg.tokenId).actor; \n    else defActor = game.actors.get(lastArg.actorId);\n    actor = actor ? actor : defActor; // Set actor if not supplied\n    jez.log(`-------------- Starting --- ${MACRONAME} ${FUNCNAME} -----------------`,\n        \"itemName\", itemName, `actor ${actor?.name}`, actor);\n\n    if (!jezIsActor5e(actor)) {\n        errorMsg = `Obtained actor argument is not of type Actor5E (${actor?.constructor.name})`\n        jez.log(errorMsg)\n        jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} ==> FALSE --------------`);\n        return (false);\n    }\n\n    let item = actor.items.find(item => item.data.name === itemName && item.type === \"weapon\")\n    if (item == null || item == undefined) {\n        errorMsg = `${actor.name} does not have ${itemName}`\n        jez.log(errorMsg);\n        jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} ==> FALSE --------------`);\n        return (false);\n    }\n\n    await aActor.deleteOwnedItem(item._id);\n    jez.log(`${actor.name} had (past tense) ${item.name}`, item);\n    jez.log(`-------------- Finished --- ${MACRONAME} ${FUNCNAME} ==> TRUE -----------------`);\n    return (true);\n}*/\n/***************************************************************************************************\n * Return true if passed argument is of object type \"Token5e\"\n ***************************************************************************************************/\n function jezIsActor5e(obj) {\n    if (obj?.constructor.name === \"Actor5e\") return(true)\n    return(false)\n}\n/***************************************************************************************************\n * Obtain the Actor5e objext corresponding to the passed ID\n ***************************************************************************************************/\nfunction jezGetActor5EfromID(passedID) {\n    let myActor = game.actors.get(passedID)\n    jez.log(`Obtained actor ${myActor.name}`, myActor)\n    return(myActor)\n}\n\n/***************************************************************************************************\n * Post the results to chat card\n ***************************************************************************************************/\n async function postResults(resultsString) {\n    const lastArg = args[args.length - 1];\n\n    let chatMessage = game.messages.get(lastArg.itemCardId);\n    let content = await duplicate(chatMessage.data.content);\n    jez.log(`chatMessage: `,chatMessage);\n    //const searchString = /<div class=\"midi-qol-other-roll\">[\\s\\S]*<div class=\"end-midi-qol-other-roll\">/g;\n    //const replaceString = `<div class=\"midi-qol-other-roll\"><div class=\"end-midi-qol-other-roll\">${resultsString}`;\n    const searchString = /<div class=\"end-midi-qol-saves-display\">/g;\n    const replaceString = `<div class=\"end-midi-qol-saves-display\">${resultsString}`;\n    content = await content.replace(searchString, replaceString);\n    await chatMessage.update({ content: content });\n    await ui.chat.scrollBottom();\n    return;\n}\n/***************************************************************************************************\n * Post a new chat message -- msgParm should be a string for a simple message or an object with \n * some or all of these fields set below for the chat object.  \n * \n * Example Calls:\n *  jezPostMessage(\"Hi there!\")\n *  jezPostMessage({color:\"purple\", fSize:18, msg:\"Bazinga\", title:\"Sheldon says...\" })\n * \n ***************************************************************************************************/\nasync function jezPostMessage(msgParm) {\n    const FUNCNAME = \"postChatMessage(msgParm)\";\n    jez.log(`--------------${FUNCNAME}-----------`, \"Starting\", `${MACRONAME} ${FUNCNAME}`,\n        \"msgParm\", msgParm);\n    let typeOfParm = typeof (msgParm)\n    switch (typeOfParm) {\n        case \"string\":\n            await ChatMessage.create({ content: msgParm });\n            break;\n        case \"object\":\n            let chat = {} \n            chat.title = msgParm?.title || \"Generic Chat Message\"\n            chat.fSize = msgParm?.fSize || 12\n            chat.color = msgParm?.color || \"black\"   \n            chat.icon  = msgParm?.icon  || \"icons/vtt-512.png\"   \n            chat.msg   = msgParm?.msg   || \"Maybe say something useful...\"  \n            chatCard = `\n            <div class=\"dnd5e chat-card item-card midi-qol-item-card\">\n                <header class=\"card-header flexrow\">\n                    <img src=\"${chat.icon}\" title=\"${chat.title}\" width=\"36\" height=\"36\">\n                    <h3 class=\"item-name\">${chat.title}</h3>\n                </header>\n                <div class=\"card-buttons\">\n                    <p style=\"color:${chat.color};font-size:${chat.fSize}px\">\n                        ${chat.msg}</p>\n                </div>\n            </div>`\n            await ChatMessage.create({ content: chatCard });\n            break;\n        default:\n            errorMsg`Icky Poo Poo!  Parameter passed was neither a string nor object (${typeOfParm})`\n            jez.log(errorMsg, msgParm)\n            ui.notifications.error(errorMsg)\n    }\n    await jez.wait(100);\n    await ui.chat.scrollBottom();\n    jez.log(`--------------${FUNCNAME}-----------`, \"Finished\", `${MACRONAME} ${FUNCNAME}`);\n    return;\n}",
  "flags": {
    "combat-utility-belt": {
      "macroTrigger": ""
    },
    "advanced-macros": {
      "runAsGM": false
    },
    "exportSource": {
      "world": "travels-in-barovia",
      "system": "dnd5e",
      "coreVersion": "9.269",
      "systemVersion": "1.6.0"
    }
  }
}