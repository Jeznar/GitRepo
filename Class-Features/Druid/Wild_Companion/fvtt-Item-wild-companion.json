{
  "name": "Wild Companion",
  "type": "feat",
  "img": "worlds/travels-in-barovia/NoFuzzball11.png",
  "data": {
    "description": {
      "value": "<p>You gain the ability to summon a spirit that assumes an animal form: as an action, you can expend a <strong>use of your Wild Shape feature </strong>to cast the find familiar spell, without material components.</p>\n<p>When you cast the spell in this way, the familiar is a <strong>fey instead of a beast</strong>, and the familiar <strong>disappears after a number of hours equal to half your druid level</strong>.</p>\n<hr />\n<p><strong>FoundryVTT</strong>: This is automated.</p>",
      "chat": "",
      "unidentified": ""
    },
    "source": "Tashaâ€™s Cauldron of Everything",
    "activation": {
      "type": "action",
      "cost": 1,
      "condition": ""
    },
    "duration": {
      "value": 2,
      "units": "hour"
    },
    "target": {
      "value": null,
      "width": null,
      "units": "",
      "type": ""
    },
    "range": {
      "value": 10,
      "long": null,
      "units": "ft"
    },
    "uses": {
      "value": 0,
      "max": "0",
      "per": ""
    },
    "consume": {
      "type": "attribute",
      "target": "",
      "amount": 1
    },
    "ability": "",
    "actionType": "util",
    "attackBonus": 0,
    "chatFlavor": "",
    "critical": {
      "threshold": null,
      "damage": null
    },
    "damage": {
      "parts": [],
      "versatile": ""
    },
    "formula": "",
    "save": {
      "ability": "",
      "dc": null,
      "scaling": "spell"
    },
    "requirements": "Druid 2nd Lvl",
    "recharge": {
      "value": null,
      "charged": false
    }
  },
  "effects": [
    {
      "_id": "Y9ZlojxL8EAemsjz",
      "changes": [
        {
          "key": "macro.execute",
          "mode": 0,
          "value": "Summon @token @unique Fuzzball 100 100",
          "priority": "20"
        }
      ],
      "disabled": false,
      "duration": {
        "startTime": null,
        "seconds": 3600
      },
      "icon": "worlds/travels-in-barovia/NoFuzzball11.png",
      "label": "Wild Companion",
      "transfer": false,
      "flags": {
        "dae": {
          "stackable": "none",
          "macroRepeat": "none",
          "specialDuration": [],
          "transfer": false
        },
        "ActiveAuras": {
          "isAura": false,
          "aura": "None",
          "radius": null,
          "alignment": "",
          "type": "",
          "ignoreSelf": false,
          "height": false,
          "hidden": false,
          "hostile": false,
          "onlyOnce": false
        }
      },
      "tint": null,
      "selectedKey": "macro.execute"
    }
  ],
  "flags": {
    "ddbimporter": {
      "id": 3021781,
      "data": {
        "id": 3021781,
        "definitionKey": "class-feature:3021781",
        "entityTypeId": 12168134,
        "displayOrder": 2,
        "name": "Wild Companion",
        "description": "<p><em>2nd-level druid feature</em><br />You gain the ability to summon a spirit that assumes an animal form: as an action, you can expend a use of your Wild Shape feature to cast the find familiar spell, without material components.</p>\r\n<p>When you cast the spell in this way, the familiar is a fey instead of a beast, and the familiar disappears after a number of hours equal to half your druid level.</p>",
        "snippet": "As an action, you can expend a use of your <em>Wild Shape</em> feature to cast the find familiar spell, without material components.\r\nWhen you cast the spell in this way, the familiar is a fey instead of a beast, and the familiar disappears after {{(classlevel/2)@rounddown#unsigned}} hours.",
        "activation": null,
        "multiClassDescription": "",
        "requiredLevel": 2,
        "isSubClassFeature": false,
        "limitedUse": [
          {
            "level": null,
            "uses": 1
          }
        ],
        "hideInBuilder": false,
        "hideInSheet": false,
        "sourceId": 67,
        "sourcePageNumber": 35,
        "creatureRules": [],
        "levelScales": [],
        "infusionRules": [],
        "spellListIds": [],
        "classId": 3,
        "featureType": 2,
        "sources": [
          {
            "sourceId": 67,
            "pageNumber": null,
            "sourceType": 1
          }
        ],
        "affectedFeatureDefinitionKeys": [],
        "entityType": "class-feature",
        "entityID": "3021781"
      },
      "featureId": 3021781,
      "requiredLevel": 2,
      "class": "Druid",
      "classId": 3,
      "subClass": ""
    },
    "core": {
      "sourceId": "Compendium.My-Shared-DDB.classfeatures.omWtQAmC3030HXwc"
    },
    "magicitems": {
      "enabled": false,
      "equipped": false,
      "attuned": false,
      "charges": "0",
      "chargeType": "c1",
      "destroy": false,
      "destroyFlavorText": "reaches 0 charges: it crumbles into ashes and is destroyed.",
      "rechargeable": false,
      "recharge": "0",
      "rechargeType": "t1",
      "rechargeUnit": "r1",
      "sorting": "l"
    },
    "betterCurses": {
      "isCurse": false,
      "curseName": "",
      "formula": "",
      "mwak": false,
      "rwak": false,
      "msak": false,
      "rsak": false
    },
    "itemacro": {
      "macro": {
        "data": {
          "_id": null,
          "name": "Wild Companion",
          "type": "script",
          "author": "ZjFlOWYxZjM5ZTZj",
          "img": "icons/svg/dice-target.svg",
          "scope": "global",
          "command": "const MACRONAME = \"Wild_Companion.0.1.js\"\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Built directly on the Find Familiar spell with the addition of:\n * \n * 1. Use of a Wild Shape charge\n * 2. Adding existance timer to the summon\n * 3. Change of type to Fey for the summoned critter.\n * \n * This ability requires a:\n *  - resource named as defined by const RESOURCE_NAME or daily uses on the item\n *  - presence of a feature named by const FEATURE\n * \n * Look in the sidebar for creatures that can serve as fams and provide a list of options for\n * the find fam spell. Then, execute the summon with jez.spawnAt (WarpGate)\n * \n Assumptions & Preconditions\n * Name to be used for the familiar has been set with \"Set Familiar Name\"\n * One or more familiars are stored in the folder defined by FAM_FLDR (\"Familiars\")\n * Familiars, if any, for Chain Locks stored in FAM_FLDR_CHAIN (\"Familiars Pact of the Chain\")\n * Feature named PACT_OF_THE_CHAIN (\"Pact of the Chain\") spelled exactly enables Chain Lock\n * Familiars have unique names, i.e. there is only one \"bat,\" \"raven,\" etc.\n * Feature CHAIN_MASTER_PACT, if present results in message reminding that this is not automated.\n\n * 12/09/22 0.1 Creation from Find_Familiar.1.7.js\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nconst MACRO = MACRONAME.split(\".\")[0]       // Trim of the version number and extension\nconst TAG = `${MACRO} |`\nconst TL = 0;                               // Trace Level for this macro\nconst FAM_FLDR = \"Familiars\"\nconst FAM_FLDR_CHAIN = \"Familiars Pact of the Chain\"\nconst PACT_OF_THE_CHAIN = \"Pact of the Chain\"\nconst CHAIN_MASTER_PACT = \"Invocation: Investment of the Chain Master\"\nconst CHAIN_MASTER_VOICE = \"Invocation: Voice of the Chain Master\"\nconst SPELL_NAME = `Wild Companion`\nconst TEMPLATE_SPELL = \"%%Swap Senses (Familiar)%%\" // Name as expected in Items Directory \n\nlet msg = \"\";                               // Global message string\n//---------------------------------------------------------------------------------------------------\nif (TL > 1) jez.trace(`=== Starting === ${MACRONAME} ===`);\nif (TL > 2) for (let i = 0; i < args.length; i++) jez.trace(`  args[${i}]`, args[i]);\nconst LAST_ARG = args[args.length - 1];\n//---------------------------------------------------------------------------------------------------\n// Set standard variables\nconst L_ARG = args[args.length - 1]; // See https://gitlab.com/tposney/dae#lastarg for contents\nlet aToken = (L_ARG.tokenId) ? canvas.tokens.get(L_ARG.tokenId) : game.actors.get(L_ARG.tokenId)\nlet aActor = aToken.actor;\nlet aItem = (args[0]?.item) ? args[0]?.item : L_ARG.efData?.flags?.dae?.itemData\nconst VERSION = Math.floor(game.VERSION);\nconst GAME_RND = game.combat ? game.combat.round : 0;\n//---------------------------------------------------------------------------------------------------\n// Set Macro specific globals\n//\nconst FIRST_NAME_TOKEN = aToken.name.split(\" \")[0]     // Grab the first word from the selection\nlet famNames = []   // Global array to hold the list of familiar names\nconst FLAG_NAME = \"familiar_name\"\nconst FAM_NAME = DAE.getFlag(aActor, FLAG_NAME)\n//---------------------------------------------------------------------------------------------------\n// Values needed for use of the resource (Wildshapes)\n//\nconst ACTOR_DATA = await aActor.getRollData();\nconst RESOURCE_NAME = \"Wildshapes\";\nconst IS_NPC = (aToken.document._actor.data.type === \"npc\") ? true : false;\nif (TL > 2) jez.trace(`${TAG} Macro Variables`,\n    \"VERSION       \", VERSION,\n    \"ACTOR_DATA    \", ACTOR_DATA,\n    \"RESOURCE_NAME \", RESOURCE_NAME,\n    \"IS_NPC        \", IS_NPC)\n//---------------------------------------------------------------------------------------------------\n// Run the main procedures, choosing based on how the macro was invoked\n//\nif (args[0] === \"off\") await doOff({ traceLvl: TL });                           // DAE removal\nif (args[0]?.tag === \"OnUse\") await doOnUse({ traceLvl: TL });  // Midi ItemMacro On Use\n// jez.log(`============== Finishing === ${MACRONAME} =================`);\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n *    END_OF_MAIN_MACRO_BODY\n *                                END_OF_MAIN_MACRO_BODY\n *                                                             END_OF_MAIN_MACRO_BODY\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********\n * Post results to the chat card\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nfunction postResults(msg) {\n    const FUNCNAME = \"postResults(msg)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL > 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 2) jez.trace(\"postResults Parameters\", \"msg\", msg)\n    //-----------------------------------------------------------------------------------------------\n    let chatMsg = game.messages.get(args[args.length - 1].itemCardId);\n    jez.addMessage(chatMsg, { color: jez.randomDarkColor(), fSize: 14, msg: msg, tag: \"saves\" });\n    if (TL > 1) jez.trace(`${TAG}--- Finished ---`);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Perform the code that runs when this macro is invoked as an ItemMacro \"OnUse\"\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function doOnUse(options = {}) {\n    const FUNCNAME = \"doOnUse()\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    await jez.wait(100)\n    //---------------------------------------------------------------------------------------------------\n    // Make sure we have required FEATURE\n    //\n    // Note the feature being searched must be coded here in lower case\n    // const FEATURE = aActor.itemTypes.feat.find(item => [\"wild companion\"].some(x =>\n    const FEATURE = aActor.itemTypes.feat.find(item => [SPELL_NAME.toLowerCase()].some(x =>\n        (item.name).toLowerCase().includes(x)));\n    if (TL > 1) jez.trace(`${TAG} FEATURE ${FEATURE?.name}`, FEATURE)\n    if (!FEATURE) return jez.badNews(`${TAG} Missing item \"${SPELL_NAME}\" feature`, 'e')\n    //------------------------------------------------------------------------------------------\n    // Prepare for and pop a simple dialog asking if resource should be used\n    //\n    const Q_TITLE = `Consume Resource?`\n    let qText = `<p>${aToken.name} is using <b>${SPELL_NAME}</b> to summon a fey familiar.  This bypasses\n    the normal component requirements for Find Familiar but consumes one charge of <b>Wildshape.</b></p>\n    <p>If you want to spend the charge (or use the NPC alternative), click <b>\"Yes\"</b>.</p>\n    <p>If you want to bypass spending the charge (with GM permission) click <b>\"No\"</b>.</p>\n    <p>If you want to cancel the spell click <b>\"Close\"</b> (top right of dialog).</p>`\n    const SPEND_RESOURCE = await Dialog.confirm({ title: Q_TITLE, content: qText, });\n    console.log('SPEND_RESOURCE', SPEND_RESOURCE)\n    if (SPEND_RESOURCE === null) return jez.badNews(`${SPELL_NAME} cancelled by player.`,'i')\n    //---------------------------------------------------------------------------------------------------\n    // Deal with casting resource -- this needs to consider NPC and PC data structures\n    //\n    if (SPEND_RESOURCE) {\n        const CONTINUE = await spendResource({ traceLvl: TL })\n        if (!CONTINUE) return jez.badNews(`${SPELL_NAME} cancelled for lack of WildShapes`,'w')\n    }\n    //---------------------------------------------------------------------------------------------------\n    // Obtain the list of familiars that can be choosen from\n    // \n    famOpts = getFamiliarOptions({ traceLvl: TL })\n    if (!famOpts) return jez.badNews(`No familiars to choose from found`, \"e\")\n    //---------------------------------------------------------------------------------------------------\n    // Build an array of familiar names, sort it and make sure they are unique\n    //\n    for (let i = 0; i < famOpts.length; i++) famNames.push(famOpts[i].name)\n    famNames = famNames.sort()\n    for (let i = 1; i < famNames.length; i++)\n        if (famNames[i - 1] === famNames[i])\n            return jez.badNews(`Duplicate familiar option (${famNames[i]} found, not allowed)`, \"e\")\n    //---------------------------------------------------------------------------------------------------\n    // Check to see if aItem.name contains a shortcut selection for familiar to be summoned.  That is\n    // a string folling the last dash character (if any) in aItem.name\n    //\n    let shortCutFamName = \"\"\n    const NAME_TOKENS = aItem.name.split(\"-\")\n    if (NAME_TOKENS.length > 1) {\n        // Set short cut name to last token with leading & trailing white space stripped\n        shortCutFamName = NAME_TOKENS[NAME_TOKENS.length - 1].trim()\n        if (TL > 1) jez.trace(`${TAG} Shortcut familiar name specified: ${shortCutFamName}`);\n        if (!famNames.includes(shortCutFamName)) {  // Is the shortcut name an allowed choice?\n            jez.badNews(`Familiar's Actor for shortcut, \"${shortCutFamName}\" not found.`, \"w\");\n            shortCutFamName = \"\"\n        }\n    }\n    //-----------------------------------------------------------------------------------------------\n    // If we have more than one familiar choice and no shortcut, setup and run a dialog to select the \n    // familiar; otherwise skip dialog and proceed\n    //\n    if (famNames.length > 1 && !shortCutFamName) popDialog1(famNames, { traceLvl: TL })\n    else callBack1(shortCutFamName)\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Spend the resource\n * \n * Returns an array of the options available\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function spendResource(options = {}) {\n    const FUNCNAME = \"spendResource(options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //---------------------------------------------------------------------------------------------------\n    // Function variables\n    //\n    let resourceSlot = null\n    let curtRes, curtMax\n    //--------------------------------------------------------------------------------------------\n    //\n    if (IS_NPC) {   // Process resources for an NPC\n        const ITEM_USES = await jez.getItemUses(FEATURE, { traceLvl: TL })\n        if (TL > 2) jez.trace(`${TAG} Resource Values for NPC: ${aToken.name}`, \"ITEM_USES\", ITEM_USES)\n        curtRes = ITEM_USES.value;\n        curtMax = ITEM_USES.max;\n    }\n    else {\n        let resourceList = [{ name: \"primary\" }, { name: \"secondary\" }, { name: \"tertiary\" }];\n        let resourceValues = Object.values(ACTOR_DATA.resources);\n        let resourceTable = mergeObject(resourceList, resourceValues);\n        let findResourceSlot = resourceTable.find(i => i.label.toLowerCase() === RESOURCE_NAME.toLowerCase());\n        if (!findResourceSlot) return jez.badNews(`${TAG} ${RESOURCE_NAME} Resource is missing on \n        ${aToken.name}, Please add it.`);\n        resourceSlot = findResourceSlot.name;\n        curtRes = ACTOR_DATA.resources[resourceSlot].value;\n        curtMax = ACTOR_DATA.resources[resourceSlot].max;\n        if (TL > 2) jez.trace(`${TAG} Resource Values for PC: ${aToken.name}`,\n            \"resourceList     \", resourceList,\n            \"resourceTable    \", resourceTable,\n            \"findResourceSlot \", findResourceSlot)\n    }\n    if (TL > 2) jez.trace(`${TAG} Resource Values`,\n        \"curtRes \", curtRes,\n        \"curtMax \", curtMax)\n    if (curtRes < 1) return false;\n    //-----------------------------------------------------------------------------------------------\n    // Decrement our resource -- this needs to consider NPC and PC data structures\n    //\n    if (IS_NPC) {   // Decrement resource for an NPC\n        jez.setItemUses(FEATURE, curtRes - 1, { traceLvl: TL })\n    }\n    else {          // Decrement resource for a PC\n        let updates = {};\n        let resources = VERSION > 9 ? `system.resources.${resourceSlot}.value` :\n            `data.resources.${resourceSlot}.value`;\n        updates[resources] = curtRes - 1;\n        await aActor.update(updates);\n    }\n    await jez.wait(300);\n    return true\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Grab Familiar Options\n * \n * Returns an array of the options available\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nfunction getFamiliarOptions(options = {}) {\n    const FUNCNAME = \"getFamiliarOptions(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //--------------------------------------------------------------------------------------------\n    // Grab the folder of fams from the actor directory (sidebar)\n    //\n    let famFold = game.folders.find(item => item.data.name === FAM_FLDR)\n    if (!famFold) return jez.badNews(`Could not find a folder named ${FAM_FLDR}`, \"e\")\n    if (TL > 3) jez.trace(`${TAG} Familiar Folder`, famFold)\n    //--------------------------------------------------------------------------------------------\n    // Make sure at least one familiar exists in the folder\n    //\n    if (!famFold.content || famFold.content.length === 0)\n        return jez.badNews(`No familiars found in the ${FAM_FLDR} folder`, \"e\")\n    //--------------------------------------------------------------------------------------------\n    // Convert the folder data into an array of handy actor objects\n    //\n    let famArray = []\n    for (let i = 0; i < famFold.content.length; i++) {\n        famArray[i] = {\n            name: famFold.content[i].name,\n            id: famFold.content[i].id,\n            actor5e: famFold.content[i]\n        }\n    }\n    let famCnt = famArray.length\n    //--------------------------------------------------------------------------------------------\n    // Does the caster have the \"Pact of the Chain\" (PACT_OF_THE_CHAIN) feature, and thus \n    // more options?\n    //\n    let chainLock = false   // Boolean flag indicating caster is a chain lock (or not)\n    if (aActor.items.find(i => i.name === PACT_OF_THE_CHAIN)) chainLock = true\n    if (TL > 2)\n        if (chainLock) jez.trace(`${TAG} ${FIRST_NAME_TOKEN} is a Chain Warlock`)\n        else jez.trace(`${TAG} ${FIRST_NAME_TOKEN} is not a Chain Warlock`)\n    //--------------------------------------------------------------------------------------------\n    // If we're dealing with a Chain Lock, need to add in the additional familiar options\n    //\n    if (chainLock) {\n        let chainFamFold = game.folders.find(item => item.data.name === FAM_FLDR_CHAIN)\n        if (!chainFamFold)\n            jez.badNews(`Could not find chain lock familiar folder \"${FAM_FLDR_CHAIN}\"`, \"w\")\n        else {\n            if (TL > 3) jez.trace(`${TAG} Chain Lock Familiar Folder`, chainFamFold)\n            for (let i = famCnt; i < chainFamFold.content.length + famCnt; i++) {\n                if (TL > 4) jez.trace(`${TAG} Processing`, chainFamFold.content[i - famCnt].name)\n                famArray[i] = {\n                    name: chainFamFold.content[i - famCnt].name,\n                    id: chainFamFold.content[i - famCnt].id,\n                    actor5e: chainFamFold.content[i - famCnt]\n                }\n            }\n        }\n    }\n    //--------------------------------------------------------------------------------------------\n    // Depending on TL, spit out what we have assembled\n    //\n    for (let i = 0; i < famArray.length; i++) {\n        if (TL > 3) jez.trace(`${TAG} ${i + 1} Familiar`, famArray[i].name)\n        if (TL > 5) jez.trace(`${TAG} ${i + 1} Familiar`, famArray[i].id)\n        if (TL > 4) jez.trace(`${TAG} ${i + 1} Familiar`, famArray[i].actor5e)\n    }\n    //--------------------------------------------------------------------------------------------\n    // Return results\n    //\n    return famArray\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Create the dialog to select a familiar\n * \n **********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function popDialog1(famNames, options = {}) {\n    const FUNCNAME = \"popDialog1(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"famNames\", famNames,\n        \"options\", options);\n    //-----------------------------------------------------------------------------------------------\n    // Obtain the list of familiars that can be choosen from\n    // \n    const queryTitle = \"What form for Familiar?\"\n    const queryText = \"Select the form for the familiar from drop down list\"\n    jez.pickFromListArray(queryTitle, queryText, callBack1, famNames);\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Process the selection from the dialog offering list of familiar forms.\n * \n **********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function callBack1(itemSelected) {\n    const FUNCNAME = \"callBack1(itemSelected)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"itemSelected\", itemSelected);\n    //-----------------------------------------------------------------------------------------------\n    //\n    if (TL > 1) jez.trace(`${TAG} itemCallBack: Item \"${itemSelected}\" selected in the dialog`)\n    //--------------------------------------------------------------------------------------------\n    // If cancel button was selected on the preceding dialog, null is returned ==> Terminate\n    //\n    if (itemSelected === null) return;\n    //--------------------------------------------------------------------------------------------\n    // If nothing was selected call preceding function and terminate this one\n    //\n    if (!itemSelected) {\n        if (TL > 1) jez.trace(`${TAG} No selection passed to ${FUNCNAME}, trying again.`)\n        popDialog1(famNames, { traceLvl: TL })\n        return;\n    }\n    //--------------------------------------------------------------------------------------------\n    // If an existing Find_Familiar effect exists on calling actor, delete it\n    //\n    existingEffect = aActor.effects.find(ef => ef.data.label === SPELL_NAME)\n    if (existingEffect) {\n        await existingEffect.delete();\n        // await jez.deleteItems(SPELL_NAME, \"feat\", aToken.actor);\n        msg = `<b>${aToken.name}</b> previously existing familiar has been dismissed.`\n        jez.postMessage({\n            color: jez.randomDarkColor(), fSize: 13, icon: aToken.data.img, msg: msg,\n            title: `Existing Familiar Dismissed`, token: aToken\n        })\n    }\n    //--------------------------------------------------------------------------------------------\n    // Build basic data object for the summon\n    //\n    if (TL > 1) jez.trace(`${TAG} Actually summon the familiar ${itemSelected}`)\n    let famName = FAM_NAME ?? `${FIRST_NAME_TOKEN}'s ${itemSelected}`\n    const NEW_SPELL = `Swap Senses with ${famName}`\n    if (TL > 2) jez.trace(`${TAG} Familiar name: ${famName}`)\n    let argObj = {\n        defaultRange: 10,\n        duration: 3000,                     // Duration of the intro VFX\n        introTime: 1000,                    // Amount of time to wait for Intro VFX\n        introVFX: '~Energy/SwirlingSparkles_01_Regular_${color}_400x400.webm', // default introVFX file\n        minionName: famName,\n        outroVFX: '~Fireworks/Firework*_02_Regular_${color}_600x600.webm', // default outroVFX file\n        scale: 0.4,\t\t\t\t\t\t\t// Default value but needs tuning at times\n        source: aToken,                     // Coords for source (with a center), typically aToken\n        templateName: itemSelected,         // Name of the actor in the actor directory\n        traceLvl: 0\n    }\n    //-----------------------------------------------------------------------------------------------\n    // If a temp ability to swap senses for this familiar exists, delete it\n    //\n    let itemFound = aActor.items.find(item => item.data.name === NEW_SPELL && item.type === \"spell\")\n    if (itemFound) {\n        await itemFound.delete();\n        msg = `\"${NEW_SPELL}\" has been deleted from ${aToken.name}'s spell book`\n        jez.badNews(msg, \"i\");\n    }\n    //--------------------------------------------------------------------------------------------------\n    // Nab the data for our soon to be summoned critter so we can have the right image (img) and use it\n    // to update the img and width attributes or set basic image to match this item\n    //\n    let summonData = await game.actors.getName(itemSelected)\n    argObj.img = summonData ? summonData.img : aItem.img\n    argObj.width = summonData ? summonData.data.token.width : 1\n    if (TL > 2) jez.trace(`${TAG} argObj`, argObj)\n    //--------------------------------------------------------------------------------------------------\n    // Does the caster have the CHAIN_MASTER_VOICE feature?  Set boolean appropriately\n    //\n    // let chainMasterVoice = false   // Boolean flag indicating caster has CHAIN_MASTER_VOICE invocation\n    // if (aActor.items.find(i => i.name === CHAIN_MASTER_VOICE)) chainMasterVoice = true\n    //--------------------------------------------------------------------------------------------------\n    // Create an updates object that will mutate the disposition of the familiar to match master's\n    //\n    if (TL > 1) jez.trace(`${TAG} Building a custom update object for familiar to mutate disposition`)\n    argObj.updates = {\n        actor: { \n            name: famName,\n            data: {\n                details: {\n                    type: {\n                        value: \"fey\"\n                    }\n                }\n            }\n        },\n        token: {\n            name: famName,\n            disposition: aActor.data.token.disposition,\n        },\n        embedded: { Item: {} } // Need an empty entry here to hold one or more additions\n    }\n    //--------------------------------------------------------------------------------------------------\n    // Does the caster have the CHAIN_MASTER_PACT feature, and thus needs special treatment?\n    //\n    let chainMasterPact = false   // Boolean flag indicating caster has CHAIN_MASTER_PACT invocation\n    if (aActor.items.find(i => i.name === CHAIN_MASTER_PACT)) chainMasterPact = true\n    if (chainMasterPact) {\n        jez.badNews(`Features provided by ${CHAIN_MASTER_PACT} are not automated other than save DC`, \"i\")\n        const SPELL_DC = jez.getSpellDC(aActor)\n        if (TL > 1) jez.trace(`${TAG} ${FIRST_NAME_TOKEN} has ${CHAIN_MASTER_PACT}`)\n        // ---------------------------------------------------------------------------------------------\n        // Does the familiar being summoned have weapon/spell item(s) with a flat saving throw?\n        // If so build an array containingthe names of those items.\n        //\n        let saveItems = []\n        let items = summonData.items.contents\n        for (let i = 0; i < items.length; i++) {\n            if (items[i].data.type === \"weapon\" || items[i].data.type === \"spell\") {\n                if (items[i].data.data.save.dc && items[i].data.data.save.scaling === \"flat\") {\n                    if (TL > 2) jez.trace(`${TAG} TODO: Item ${items[i].name} needs to have its flat save value adjusted`)\n                    saveItems.push(items[i].name)\n                }\n            }\n        }\n        // ---------------------------------------------------------------------------------------------       \n        // If one or more items contain flat saving throws, craft a custom update data structure\n        //\n        if (saveItems.length > 0) {\n            for (let i = 0; i < saveItems.length; i++) {\n                if (TL > 2) jez.trace(`${TAG} Add data to adjust save for Item: \"${saveItems[i]}\"`)\n                argObj.updates.embedded.Item[saveItems[i]] = { 'data.save.dc': SPELL_DC }\n            }\n            if (TL > 1) jez.trace(`${TAG} argObj.updates`, argObj.updates)\n        }\n    }\n    else if (TL > 2) jez.trace(`${TAG} ${FIRST_NAME_TOKEN} lacks ${CHAIN_MASTER_PACT}`)\n    //--------------------------------------------------------------------------------------------------\n    // Do the actual summon\n    //\n    let fTokenId = await jez.spawnAt(itemSelected, aToken, aActor, aItem, argObj)\n    if (TL > 1) jez.trace(`${TAG} Token ID of summoned familiar`, fTokenId)\n    //--------------------------------------------------------------------------------------------------\n    // Add watchdog effect to the summoning token \n    //\n    const CLASS_LEVEL = jez.getClassLevel(aToken, 'Druid', { traceLvl: TL })\n    const DURATION = CLASS_LEVEL * 1800\n    addWatchdogEffect(fTokenId, famName, DURATION, {traceLvl: TL})\n    //-------------------------------------------------------------------------------------------------\n    // Add the Swap Senses 'spell' to spell book\n    // \n    if (copyEditItem(aToken, famName, NEW_SPELL)) {\n        msg = `An At-Will Spell \"${NEW_SPELL}\" has been added to ${aToken.name}`\n        jez.badNews(msg, \"i\");\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Add some additional items to the familiar if they are not already present\n    //\n    let fToken = canvas.tokens.placeables.find(ef => ef.id === fTokenId[0]) // fToken: Familiar Token\n    if (TL > 1) jez.trace(`${TAG} Familiar Token data`, fToken)\n    await copyItem(fToken, \"feat\", \"Help\", { traceLvl: TL })\n    await copyItem(fToken, \"feat\", \"Hinder\", { traceLvl: TL })\n    await copyItem(fToken, \"feat\", \"Familiar\", { traceLvl: TL })\n    if (chainMasterPact)\n        await copyItem(fToken, \"feat\", \"Familiar - Pact of the Chain Master\", { traceLvl: TL })\n    if (chainMasterPact)\n        await copyItem(fToken, \"feat\", \"Familiar - Voice of the Chain Master\", { traceLvl: TL })\n    //-----------------------------------------------------------------------------------------------\n    // Add timer to delete the summoned  creature at the appropriate time:\n    // RAW: \"familiar disappears after a number of hours equal to half your druid level.\"\n    //\n    await addTimerEffect(fToken.actor.uuid, famName, DURATION, {traceLvl:TL})\n    //-----------------------------------------------------------------------------------------------\n    // Post message about the summons\n    //\n    msg = `<b>${aToken.name}</b> has summoned ${famName} in the form of a ${itemSelected} as their \n    familiar.`\n    postResults(msg)\n    return\n}\n/***************************************************************************************************\n * Add an effect to our recently summoned familiar to delete itself at the end of the spell duration\n * \n *                 >>> This is not actually needed as WatchDog handles duration <<<\n * \n * Expected input is a single token id and the name of the familiar\n ***************************************************************************************************/\nasync function addTimerEffect(familiarUuid, famName, seconds, options = {}) {\n    const FUNCNAME = \"addTimerEffect(familiarUuid, famName, seconds, options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} Starting --- `);\n    if (TL > 1) jez.trace(`${TAG} Starting ---`, \"familiarUuid\", familiarUuid, \"famName\", famName,\n        'seconds', seconds, 'options', options);\n    //------------------------------------------------------------------------------------------------\n    // Set function variables/constants\n    //\n    // const CLOCK_IMG = \"Icons_JGB/Misc/alarm_clock.png\" -- Nice clock icon\n    const CLOCK_IMG = \"\"    // Causes icon to not appear in scene\n    const CE_DESC = `Summoned ${famName} will remain for up to ${seconds/3600} hours`\n    //------------------------------------------------------------------------------------------------\n    // Proceed!\n    //\n    let effectData = {\n        label: aItem.name,\n        icon: CLOCK_IMG,\n        origin: LAST_ARG.uuid,\n        disabled: false,\n        duration: {\n            rounds: seconds / 6, startRound: GAME_RND,\n            seconds: seconds, startTime: game.time.worldTime,\n            token: aToken.uuid, stackable: false\n        },\n        flags: { \n            convenientDescription: CE_DESC \n        },\n        changes: [\n            { key: `macro.execute`, mode: jez.CUSTOM, value: `Dismiss_Tokens ${familiarUuid}`, priority: 20 },\n        ]\n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: familiarUuid, effects: [effectData] });\n}\n/***************************************************************************************************\n * Add an effect to the using actor that can perform additional actions on the summoned actor.\n * \n * Expected input is a single token id and the name of the familiar\n ***************************************************************************************************/\nasync function addWatchdogEffect(tokenId, famName, seconds, options = {}) {\n    const FUNCNAME = \"addWatchdogEffect(tokenId)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} Starting --- `);\n    if (TL > 1) jez.trace(`${TAG} Starting ---`, \"tokenId\", tokenId, \"famName\", famName,\n        'seconds', seconds, 'options', options);\n    //------------------------------------------------------------------------------------------------\n    // Make sure DEL_TOKEN_MACRO exists and is GM execute enabled\n    //\n    const DEL_TOKEN_MACRO = \"DeleteTokenMacro\";\n    const delTokenMacro = game.macros.getName(DEL_TOKEN_MACRO);\n    if (!delTokenMacro)\n        return jez.badNews(`Cannot locate ${DEL_TOKEN_MACRO} GM Macro, skipping watchdog`);\n    if (!delTokenMacro.data.flags[\"advanced-macros\"].runAsGM)\n        return jez.badNews(`${DEL_TOKEN_MACRO} \"Execute as GM\" not checked, skipping watchdog`);\n    //------------------------------------------------------------------------------------------------\n    // Proceed with adding watchdog\n    //\n    const CE_DESC = `Summoned ${famName} will remain for up to ${seconds/3600} hours`\n    let effectData = {\n        label: SPELL_NAME,\n        icon: aItem.img,\n        origin: LAST_ARG.uuid,\n        disabled: false,\n        duration: {\n            rounds: seconds / 6, startRound: GAME_RND,\n            seconds: seconds, startTime: game.time.worldTime,\n            token: aToken.uuid, stackable: false\n        },\n        flags: {\n            dae: { macroRepeat: \"none\" },\n            convenientDescription: CE_DESC\n        },\n        changes: [\n            { key: `macro.execute`, mode: jez.ADD, value: `DeleteTokenMacro ${tokenId}`, priority: 20 },\n            { key: `macro.itemMacro`, mode: jez.CUSTOM, value: `0`, priority: 20 },\n        ]\n    };\n    if (TL > 1) jez.trace(`${FNAME} | effectData`, effectData);\n    if (TL > 3) jez.trace(`${FNAME} | MidiQOL.socket().executeAsGM(\"createEffects\"`, \"aToken.actor.uuid\",\n        aToken.actor.uuid, \"effectData\", effectData);\n    await MidiQOL.socket().executeAsGM(\"createEffects\",\n        { actorUuid: aToken.actor.uuid, effects: [effectData] });\n    if (TL > 0) jez.trace(`---  Finished --- ${MACRO} ${FNAME} ---`);\n}\n/***************************************************************************************************\n* Copy the temporary item to actor's spell book and edit it as appropriate\n***************************************************************************************************/\nasync function copyEditItem(token5e, familiarName, NEW_SPELL) {\n    const FUNCNAME = \"copyEditItem(token5e)\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n\n    if (TL === 1) jez.trace(`${TAG} Starting --- `);\n    if (TL > 1) jez.trace(`${TAG} Starting ---`, \"token5e\", token5e, \"familiarName\", familiarName,\n        \"NEW_SPELL\", NEW_SPELL);\n    //----------------------------------------------------------------------------------------------\n    let oldActorItem = token5e.actor.data.items.getName(NEW_SPELL)\n    if (oldActorItem) await deleteItem(token5e.actor, oldActorItem)\n    //----------------------------------------------------------------------------------------------\n    if (TL > 1) jez.trace(`${TAG} Get the item from the Items directory add to ${aToken.name}`)\n    let itemObj = game.items.getName(TEMPLATE_SPELL)\n    if (!itemObj) {\n        msg = `Failed to find ${TEMPLATE_SPELL} in the Items Directory`\n        ui.notifications.error(msg);\n        postResults(msg)\n        return (false)\n    }\n    console.log('Item5E fetched by Name', itemObj)\n    await replaceItem(token5e.actor, itemObj)\n    //----------------------------------------------------------------------------------------------\n    if (TL > 1) jez.trace(`${TAG} Edit the item on ${aToken.name}'s actor, `)\n    let aActorItem = token5e.actor.data.items.getName(TEMPLATE_SPELL)\n    if (TL > 1) jez.trace(`${TAG} aActorItem`, aActorItem)\n    if (!aActorItem) {\n        msg = `Failed to find ${TEMPLATE_SPELL} on ${token5e.name}`\n        ui.notifications.error(msg);\n        postResults(msg)\n        return (false)\n    }\n    //-----------------------------------------------------------------------------------------------\n    if (TL > 1) jez.trace(`${TAG} Remove the don't change this message assumed to be embedded in the \n        item description.  It should be of the form: <p><strong>%%*%%</strong></p> followed by white \n        space`)\n    const searchString = `<p><strong>%%.*%%</strong></p>[\\s\\n\\r]*`;\n    const regExp = new RegExp(searchString, \"g\");\n    const replaceString = ``;\n    let content = await duplicate(aActorItem.data.data.description.value);\n    content = await content.replace(regExp, replaceString);\n    let itemUpdate = {\n        'name': NEW_SPELL,\n        'data.description.value': content,\n    }\n    if (TL > 1) jez.trace(`${TAG} Updating Item`, itemUpdate)\n    await aActorItem.update(itemUpdate)\n    if (TL > 1) jez.trace(`${TAG} --- Finished`);\n    return (true);\n}\n/*************************************************************************************\n * replaceItem\n * \n * Replace or Add targetItem to inventory of actor5e passed as parms\n *************************************************************************************/\nasync function replaceItem(actor5e, targetItem) {\n    await deleteItem(actor5e, targetItem)\n    return (actor5e.createEmbeddedDocuments(\"Item\", [targetItem.data]))\n}\n/*************************************************************************************\n * deleteItem\n * \n * Delete targetItem to inventory of actor5e passed as parms\n *************************************************************************************/\nasync function deleteItem(actor5e, targetItem) {\n    let itemFound = actor5e.items.find(item => item.data.name === targetItem.data.name && item.type === targetItem.type)\n    if (itemFound) await itemFound.delete();\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Delete any existing temp abilities for this spell\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function doOff(options={}) {\n    const FUNCNAME = \"doOff(options={})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TL = options.traceLvl ?? 0\n    const TAG = `${MACRO} ${FNAME} |`\n    if (TL > 0) jez.trace(`${TAG} --- Starting ---`);\n    //-----------------------------------------------------------------------------------------------\n    // If a temp ability to swap senses for a familiar exists, delete it\n    //\n    deleteTempSpells({ traceLvl: TL })\n    if (TL > 3) jez.trace(`${TAG} | More Detailed Trace Info.`)\n\n    if (TL > 1) jez.trace(`${TAG} --- Finished ---`);\n    return;\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Delete existing temporary spell items, if any.  They must be at-will spells that start with \n * NEW_SPELL_PREFIX\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function deleteTempSpells(options = {}) {\n    const FUNCNAME = \"deleteTempSpell(options = {})\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"options\", options);\n    //-----------------------------------------------------------------------------------------------\n    // Delete all of the at-will spells that start with NEW_SPELL_PREFIX\n    //\n    const NEW_SPELL_PREFIX = \"Swap Senses with\"\n    let itemFound = null\n    while (itemFound = aActor.items.find(item => item.data.name.startsWith(NEW_SPELL_PREFIX) &&\n        item.type === \"spell\" && item.data.data.preparation.mode === \"atwill\")) {\n        await itemFound.delete();\n        jez.badNews(`At-Will Spell \"${itemFound.name}\" has been deleted from ${aToken.name}'s spell book`, 'i')\n        await jez.wait(50)\n    }\n}\n/*********1*********2*********3*********4*********5*********6*********7*********8*********9*********0\n * Copy a feature (e.g. Help Action) from the item directory to the specified actor's sheet.  Check\n * for various error conditions. \n * \n * This is similar to copyEditItem(token5e, familiarName, NEW_SPELL) with less editing\n *********1*********2*********3*********4*********5*********6*********7*********8*********9*********/\nasync function copyItem(token5e, TYPE, NAME, options = {}) {\n    const FUNCNAME = \"copyItem(token5e, TYPE, NAME, options = {}))\";\n    const FNAME = FUNCNAME.split(\"(\")[0]\n    const TAG = `${MACRO} ${FNAME} |`\n    const TL = options.traceLvl ?? 0\n    if (TL === 1) jez.trace(`${TAG} --- Starting ---`);\n    if (TL > 1) jez.trace(`${TAG} --- Starting --- ${FUNCNAME} ---`, \"token5e\", token5e, \"TYPE\", TYPE,\n        \"NAME\", NAME, \"options\", options);\n    //-----------------------------------------------------------------------------------------------\n    // Does the target token's actor currently have an item called NAME of type TYPE?  If so, return\n    //\n    if (token5e.actor.items.find(i => i.name === NAME && i.type === TYPE)) {\n        if (TL > 1) jez.trace(`${TAG} ${TYPE} named \"${NAME}\" already exists on ${token5e.name}`)\n        return\n    }\n    //-----------------------------------------------------------------------------------------------\n    // Does an item called NAME of type TYPE exist in the item directory?  If not complain & return\n    // If it does, keep the data around for subsequent usage.\n    //\n    const ITEM_DATA = game.items.find(i => i.data.name === NAME && i.type === TYPE)\n    if (TL > 1) jez.trace(`${TAG} Retreived from item directory`, ITEM_DATA)\n    if (!ITEM_DATA) return jez.badNews(`Could not find ${TYPE} named \"${NAME}\"`, \"w\")\n    //-----------------------------------------------------------------------------------------------\n    // Copy the item to our token5e's actor\n    //\n    await replaceItem(token5e.actor, ITEM_DATA)\n    //-----------------------------------------------------------------------------------------------\n    // Chill for a moment and return\n    //\n    await jez.wait(50)\n    if (TL > 1) jez.trace(`${TAG} --- Finished`);\n    return (true);\n}",
          "folder": null,
          "sort": 0,
          "permission": {
            "default": 0
          },
          "flags": {}
        }
      }
    },
    "enhancedcombathud": {
      "set1p": false,
      "set2p": false,
      "set3p": false
    },
    "midi-qol": {
      "onUseMacroName": "[postActiveEffects]ItemMacro",
      "effectActivation": false
    },
    "midiProperties": {
      "nodam": false,
      "fulldam": false,
      "halfdam": false,
      "rollOther": false,
      "critOther": false,
      "magicdam": false,
      "magiceffect": false,
      "concentration": false,
      "toggleEffect": false
    },
    "exportSource": {
      "world": "travels-in-barovia-ce",
      "system": "dnd5e",
      "coreVersion": "9.280",
      "systemVersion": "1.6.2"
    }
  }
}